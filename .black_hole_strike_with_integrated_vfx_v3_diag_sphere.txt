-- Black Hole Strike with Integrated Ball VFX v3 (DIAGNOSTIC - Simple Sphere)
-- This script combines the original Black Hole Strike logic 
-- with the persistent ball VFX tracking (based on v11 test script).
-- Ball VFX (represented by a RED SPHERE) starts 4 seconds after button press and stops automatically after 5.5 seconds.

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local TweenService = game:GetService("TweenService")

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character -- Will be updated
local humanoid -- Will be updated
local rootPart -- Will be updated
local playerValues -- Will be updated

-- // Remote Event Acquisition
local ShootRemote = nil
local function findShootRemoteStandardPath()
    print("BHS_IntegratedVFX_v3_Diag: Attempting Standard Path for ShootRemote...")
    local knitPath = ReplicatedStorage:FindFirstChild("Packages",5)
    if not knitPath then warn("BHS_IntegratedVFX_v3_Diag: Packages not found in ReplicatedStorage"); return nil end
    local knitService = knitPath:FindFirstChild("Knit",5)
    if not knitService then warn("BHS_IntegratedVFX_v3_Diag: Knit not found in Packages"); return nil end
    local ballServicePath = knitService:FindFirstChild("Services",5)
    if not ballServicePath then warn("BHS_IntegratedVFX_v3_Diag: Services not found in Knit"); return nil end
    local ballService = ballServicePath:FindFirstChild("BallService",5)
    if not ballService then warn("BHS_IntegratedVFX_v3_Diag: BallService not found in Services"); return nil end
    local rePath = ballService:FindFirstChild("RE",5)
    if not rePath then warn("BHS_IntegratedVFX_v3_Diag: RE not found in BallService"); return nil end
    local remote = rePath:FindFirstChild("Shoot",5)
    
    if remote and remote:IsA("RemoteEvent")then
        print("BHS_IntegratedVFX_v3_Diag: ShootRemote FOUND via Standard Path:",remote);
        return remote
    else
        warn("BHS_IntegratedVFX_v3_Diag: ShootRemote NOT found via Standard Path!");
        return nil
    end
end
ShootRemote = findShootRemoteStandardPath()

-- // --- CONFIGURABLE VALUES (Black Hole Strike v22 Base + Integrated Ball VFX v3 Diag) --- //
local ABILITY_KEY_BHS = Enum.KeyCode.G -- User can change this
local COOLDOWN_BHS = 5 -- Cooldown in seconds (can be adjusted)

-- Shot Parameters
local ADJUSTABLE_INITIAL_FIREPOWER_BHS = 20 -- Power for the initial FireServer call
local ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS = 4 -- Delay AFTER button press BEFORE the shot is fired. Adjust to sync shot timing.
local ADJUSTABLE_SHOT_SPEED_BHS = 300    -- Speed of the ball (studs/second)
local SHOT_DURATION_BHS = 3   -- Duration BodyVelocity/BodyForce are active

-- Animation Parameters
local ANIMATION_ID_BHS = "rbxassetid://88134271748429" -- The main animation ID
local ANIMATION_DELAY_BHS = 0.1 -- Delay AFTER button press BEFORE animation starts.
local ANIMATION_SPEED_BHS = 1.5 -- Speed multiplier (e.g., 2 = twice as fast).
local ANIMATION_DURATION_BHS = 4.5  -- How long the animation should play in seconds (0 or less means play full length).
local ANIMATION_LOOPED_BHS = false -- Whether the animation should loop (ignored if ANIMATION_DURATION_BHS > 0)

-- SFX Parameters (SIMPLIFIED - Plays ONCE after delay, no loop/duration/cleanup)
local SFX_ID_BHS = "rbxassetid://5773418559" -- SFX ID
local SFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE SFX starts.
local SFX_VOLUME_BHS = 1 -- Volume for the SFX (0 to 1).

-- Character VFX Parameters (Original BHS VFX)
local VFX_ENABLED_BHS = true -- Set to false to disable this VFX
local VFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE VFX starts.
local VFX_DURATION_MULTIPLIER_BHS = 1.0 -- Adjust VFX duration (1.0 = default, 0.5 = half, 2.0 = double)

-- // --- Integrated Ball VFX Configuration (DIAGNOSTIC - RED SPHERE) --- //
local BALL_VFX_ENABLED = true -- Set to false to disable the integrated ball VFX (red sphere)
local BALL_VFX_SCRIPT_NAME = "BHS_IntegratedBallVFX_v3_Diag"
local BALL_VFX_START_DELAY = 4.0 -- Seconds after button press to START ball VFX (red sphere)
local BALL_VFX_DURATION = 5.5   -- Seconds the ball VFX (red sphere) should remain active AFTER starting
local TELEPORT_THRESHOLD_SQ = (50 * 50) -- Squared distance threshold to detect teleports (adjust if needed)
local STABILITY_FRAMES_REQUIRED = 3 -- How many consecutive frames the ball must be stable after a teleport
local MAX_WAIT_TIME_AFTER_TELEPORT = 5.0 -- Max seconds to wait for ball to stabilize before giving up

-- // --- END CONFIGURABLE VALUES --- //

local ABILITY_NAME_BHS = "BlackHoleStrike_IntegratedVFX_v3_Diag"
local BUTTON_NAME_BHS = "BlackHoleStrikeButton_IntegratedVFX_v3_Diag"
local TIMER_TEXT_BHS = "BLACK HOLE STRIKE (DIAG)" -- Button text
local LAYOUT_ORDER_BHS = 7 -- Adjust as needed

local lastAbilityTime_BHS = 0
local blackHoleStrikeButton = nil
local isAbilityActive_BHS = false
local currentAnimationTrack_BHS = nil -- Variable to hold the active animation track

-- // --- Integrated Ball VFX State Variables --- //
local ballVFXPart = nil -- This will be the red sphere
local ballVFXHeartbeatConnection = nil
local ballVFXStopTimerConnection = nil -- To manage the auto-stop timer
local lastBallPosition = nil
local currentFollowState = "NORMAL" -- NORMAL, WAIT_BALL, WAIT_STABILITY
local stabilityCounter = 0
local waitStartTime = 0

-- // Helper Functions (Original BHS + Ball VFX Helpers)
local function findBall(retries, delay)
    retries = retries or 3; delay = delay or 0.1; local ball = nil
    for i = 1, retries do
        local f = Workspace:FindFirstChild("Football")
        if f then
            local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL", true) -- Added recursive find
            if b and b:IsA("BasePart") then ball = b; break
            elseif f:IsA("Model") and f.PrimaryPart and f.PrimaryPart:IsA("BasePart") then ball = f.PrimaryPart; break
            elseif f:IsA("BasePart") then ball = f; break end
        end
        if i < retries then task.wait(delay) end
    end
    return ball
end

local function cleanupAllMovers(target)
    if not target or not target.Parent then return end
    for _, mover in ipairs(target:GetChildren()) do
        if mover:IsA("BodyMover") then
            mover:Destroy()
        end
    end
end

local function playAnimation(humanoidRef, animationId, speed, looped)
    if not humanoidRef or not humanoidRef.Parent then return nil, nil end
    local animator = humanoidRef:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoidRef)
    local anim = Instance.new("Animation"); anim.AnimationId = animationId
    local track = animator:LoadAnimation(anim)
    if speed and speed ~= 1 then track:AdjustSpeed(speed) end
    track.Looped = looped
    track:Play()
    return track, anim 
end

local function playSound(soundId, volume)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = math.clamp(volume or 1, 0, 1) 
    sound.Looped = false
    sound.Parent = Workspace
    sound:Play()
    Debris:AddItem(sound, sound.TimeLength + 0.5) -- Add Debris cleanup
    return sound
end

local function IsReady_BHS() return tick() - lastAbilityTime_BHS >= COOLDOWN_BHS end

local function StartCooldown_BHS()
    lastAbilityTime_BHS = tick()
    if blackHoleStrikeButton then
        local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local tweenInfo = TweenInfo.new(COOLDOWN_BHS, Enum.EasingStyle.Linear)
                local targetProperties = {Offset = Vector2.new(0, 1)}
                uiGradient.Offset = Vector2.new(0, 0)
                local tween = TweenService:Create(uiGradient, tweenInfo, targetProperties)
                tween:Play()
            end
        end
    end
end

-- // --- Integrated Ball VFX Helper Functions (DIAGNOSTIC - RED SPHERE) --- //
local function createBallVFXPart()
    if ballVFXPart and ballVFXPart.Parent then ballVFXPart:Destroy() end -- Destroy previous if exists
    print(BALL_VFX_SCRIPT_NAME .. ": Creating Ball VFX Part (DIAGNOSTIC RED SPHERE)")
    local effectPart = Instance.new("Part")
    effectPart.Name = BALL_VFX_SCRIPT_NAME .. "_VFXPart_DiagSphere"
    effectPart.Shape = Enum.PartType.Ball
    effectPart.Size = Vector3.new(1.5, 1.5, 1.5) -- Make it visible
    effectPart.Color = Color3.fromRGB(255, 0, 0) -- Bright Red
    effectPart.Material = Enum.Material.Neon -- Make it glow slightly
    effectPart.Anchored = true -- Keep anchored, we set CFrame directly
    effectPart.CanCollide = false
    effectPart.CanTouch = false
    effectPart.Massless = true
    effectPart.Transparency = 0 -- Fully visible
    effectPart.Parent = Workspace

    -- NO PARTICLE EMITTERS IN DIAGNOSTIC VERSION

    ballVFXPart = effectPart -- Assign to the global state variable
    return effectPart
end

local function setBallEmittersEnabled(enabled) -- Renamed for clarity
    if not ballVFXPart or not ballVFXPart.Parent then return end
    -- In diagnostic mode, this just controls the visibility of the sphere
    if enabled then
        if ballVFXPart.Transparency ~= 0 then
            ballVFXPart.Transparency = 0
        end
    else
        if ballVFXPart.Transparency ~= 1 then
            ballVFXPart.Transparency = 1
        end
    end
end

-- // --- Integrated Ball VFX Heartbeat Update Function (Same logic as v2) --- //
local function BallVFXFollowHeartbeat(deltaTime)
    if not ballVFXPart or not ballVFXPart.Parent then
        print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - VFX Part missing, stopping.")
        if ballVFXHeartbeatConnection then ballVFXHeartbeatConnection:Disconnect(); ballVFXHeartbeatConnection = nil end
        return
    end

    local ball = findBall(1, 0) -- Only 1 retry needed here, findBall is called every frame

    if ball then
        local currentPosition = ball.Position
        local teleported = false

        if lastBallPosition then
            if (currentPosition - lastBallPosition).Magnitude > math.sqrt(TELEPORT_THRESHOLD_SQ) then -- Use sqrt here for comparison
                teleported = true
                print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Teleport detected! Distance: " .. string.format("%.2f", (currentPosition - lastBallPosition).Magnitude))
            end
        end

        if currentFollowState == "NORMAL" then
            if teleported then
                print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Entering WAIT_BALL state.")
                currentFollowState = "WAIT_BALL"
                setBallEmittersEnabled(false) -- Hide sphere
                stabilityCounter = 0
                waitStartTime = tick()
                lastBallPosition = nil -- Forget last position after teleport
            else
                -- Normal update
                ballVFXPart.CFrame = ball.CFrame
                setBallEmittersEnabled(true) -- Show sphere
                lastBallPosition = currentPosition
            end
        elseif currentFollowState == "WAIT_BALL" then
            if tick() - waitStartTime > MAX_WAIT_TIME_AFTER_TELEPORT then
                 print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - WAIT_BALL timeout. Returning to NORMAL (Sphere hidden).")
                 currentFollowState = "NORMAL"
                 setBallEmittersEnabled(false)
                 lastBallPosition = nil
            else
                -- Found ball, now check stability
                print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Found ball after teleport, entering WAIT_STABILITY.")
                currentFollowState = "WAIT_STABILITY"
                stabilityCounter = 0
                lastBallPosition = currentPosition -- Start tracking stability from here
                setBallEmittersEnabled(false) -- Keep hidden until stable
            end
        elseif currentFollowState == "WAIT_STABILITY" then
             if tick() - waitStartTime > MAX_WAIT_TIME_AFTER_TELEPORT then
                 print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - WAIT_STABILITY timeout. Returning to NORMAL (Sphere hidden).")
                 currentFollowState = "NORMAL"
                 setBallEmittersEnabled(false)
                 lastBallPosition = nil
             elseif teleported then
                 -- Ball jumped AGAIN while waiting for stability
                 print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Teleport detected during WAIT_STABILITY! Resetting wait.")
                 currentFollowState = "WAIT_BALL" -- Go back to waiting for the ball
                 setBallEmittersEnabled(false)
                 stabilityCounter = 0
                 waitStartTime = tick() -- Reset timeout timer
                 lastBallPosition = nil
             else
                 -- Ball is found and didn't teleport this frame, increment stability counter
                 stabilityCounter = stabilityCounter + 1
                 print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Ball stable for frame " .. stabilityCounter .. "/" .. STABILITY_FRAMES_REQUIRED)
                 if stabilityCounter >= STABILITY_FRAMES_REQUIRED then
                     print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Ball stabilized! Resuming NORMAL follow.")
                     currentFollowState = "NORMAL"
                     ballVFXPart.CFrame = ball.CFrame -- Snap to final stable position
                     setBallEmittersEnabled(true) -- Show sphere
                     lastBallPosition = currentPosition
                 else
                     -- Still waiting for more stable frames
                     lastBallPosition = currentPosition
                 end
             end
        end

    else -- Ball not found
        if currentFollowState == "NORMAL" then
            print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Ball lost during NORMAL. Entering WAIT_BALL.")
            currentFollowState = "WAIT_BALL"
            setBallEmittersEnabled(false)
            stabilityCounter = 0
            waitStartTime = tick()
            lastBallPosition = nil
        elseif currentFollowState == "WAIT_STABILITY" then
             print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - Ball lost during WAIT_STABILITY. Resetting to WAIT_BALL.")
             currentFollowState = "WAIT_BALL"
             setBallEmittersEnabled(false)
             stabilityCounter = 0
             waitStartTime = tick()
             lastBallPosition = nil
        elseif currentFollowState == "WAIT_BALL" then
             if tick() - waitStartTime > MAX_WAIT_TIME_AFTER_TELEPORT then
                 print(BALL_VFX_SCRIPT_NAME .. ": Heartbeat - WAIT_BALL timeout while ball still lost. Returning to NORMAL (Sphere hidden).")
                 currentFollowState = "NORMAL"
                 setBallEmittersEnabled(false)
                 lastBallPosition = nil
             else
                 -- Still waiting for ball to reappear
                 setBallEmittersEnabled(false)
             end
        end
    end
end

-- // --- Function to Start/Stop Ball VFX Tracking (Modified for Auto-Stop) --- //
local function StartBallVFXTracking()
    if not BALL_VFX_ENABLED then return end
    if ballVFXHeartbeatConnection then 
        print(BALL_VFX_SCRIPT_NAME .. ": Ball VFX tracking (Sphere) already active.")
        return 
    end
    
    print(BALL_VFX_SCRIPT_NAME .. ": Starting Ball VFX tracking (Sphere) (will stop after " .. BALL_VFX_DURATION .. "s).")
    -- Create the VFX part if it doesn't exist
    if not ballVFXPart or not ballVFXPart.Parent then
        createBallVFXPart()
    end
    if not ballVFXPart then 
        warn(BALL_VFX_SCRIPT_NAME .. ": Failed to create ball VFX part (Sphere). Cannot start tracking.")
        return
    end
    
    -- Reset state variables
    lastBallPosition = nil
    currentFollowState = "NORMAL"
    stabilityCounter = 0
    waitStartTime = 0
    setBallEmittersEnabled(false) -- Start with sphere hidden until ball is found
    
    -- Connect the heartbeat function
    ballVFXHeartbeatConnection = RunService.Heartbeat:Connect(BallVFXFollowHeartbeat)
    
    -- Schedule the automatic stop
    if ballVFXStopTimerConnection then ballVFXStopTimerConnection:Disconnect() end -- Cancel previous timer if any
    ballVFXStopTimerConnection = task.delay(BALL_VFX_DURATION, function()
        print(BALL_VFX_SCRIPT_NAME .. ": Auto-stopping Ball VFX (Sphere) after " .. BALL_VFX_DURATION .. "s.")
        StopBallVFXTracking()
    end)
end

local function StopBallVFXTracking()
    if not BALL_VFX_ENABLED then return end
    
    -- Disconnect heartbeat and stop timer
    if ballVFXHeartbeatConnection then
        print(BALL_VFX_SCRIPT_NAME .. ": Stopping Ball VFX tracking (Sphere).")
        ballVFXHeartbeatConnection:Disconnect()
        ballVFXHeartbeatConnection = nil
    end
    if ballVFXStopTimerConnection then 
        ballVFXStopTimerConnection = nil -- Clear the reference
    end
    
    -- Destroy VFX part
    if ballVFXPart and ballVFXPart.Parent then
        print(BALL_VFX_SCRIPT_NAME .. ": Destroying Ball VFX part (Sphere).")
        ballVFXPart:Destroy()
        ballVFXPart = nil
    end
    
    -- Reset state variables
    lastBallPosition = nil
    currentFollowState = "NORMAL"
    stabilityCounter = 0
end

-- // Main Ability Execution Logic (Modified for Timed Ball VFX Start)
local function BlackHoleStrike_Execute()
    if isAbilityActive_BHS then print(ABILITY_NAME_BHS .. ": Ability already active."); return end
    
    -- Pre-checks (Same as before)
    character = player.Character or player.CharacterAdded:Wait()
    if not character then print(ABILITY_NAME_BHS .. ": Character not found."); return end
    humanoid = character:FindFirstChildOfClass("Humanoid")
    rootPart = character:FindFirstChild("HumanoidRootPart")
    playerValues = character:FindFirstChild("Values")
    if not (humanoid and rootPart and playerValues) then print(ABILITY_NAME_BHS .. ": Character components missing."); return end
    local hasBallValue = playerValues:FindFirstChild("HasBall")
    if not (hasBallValue and hasBallValue:IsA("BoolValue") and hasBallValue.Value) then print(ABILITY_NAME_BHS .. ": Player does not have ball."); return end
    if not ShootRemote then ShootRemote = findShootRemoteStandardPath(); if not ShootRemote then print(ABILITY_NAME_BHS .. ": ShootRemote missing!"); return end end
    if not IsReady_BHS() then print(ABILITY_NAME_BHS .. ": Ability on cooldown. Time left: " .. string.format("%.1f", COOLDOWN_BHS - (tick() - lastAbilityTime_BHS))); return end

    -- Cleanup potential leftovers before starting (Same as before)
    if rootPart and rootPart.Parent then cleanupAllMovers(rootPart) end
    local ballForPreCleanup = findBall(1,0); if ballForPreCleanup then cleanupAllMovers(ballForPreCleanup) end
    if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
    StopBallVFXTracking() -- Stop any previous ball VFX tracking
    task.wait(0.05)

    -- Activate Ability
    isAbilityActive_BHS = true
    StartCooldown_BHS()
    print(ABILITY_NAME_BHS .. " Activated")

    -- Store references needed inside the spawn
    local currentCharacter_scope = character
    local currentHumanoid_scope = humanoid
    local currentRootPart_scope = rootPart

    task.spawn(function()
        local cleanupGuard_BHS = Instance.new("BoolValue", currentCharacter_scope)
        cleanupGuard_BHS.Name = ABILITY_NAME_BHS .. "_CleanupGuard"
        local ballInstance_thread_scope = nil
        local animationInstance_thread_scope = nil
        if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end

        local function performCleanupAndReset_BHS_Thread()
            if not cleanupGuard_BHS or not cleanupGuard_BHS.Parent then return end; cleanupGuard_BHS:Destroy()
            if currentCharacter_scope and currentCharacter_scope:FindFirstChild("HumanoidRootPart") then cleanupAllMovers(currentCharacter_scope:FindFirstChild("HumanoidRootPart")) end
            local ballToClean = ballInstance_thread_scope or findBall(1,0)
            if ballToClean and ballToClean.Parent then cleanupAllMovers(ballToClean) end
            
            if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then animationInstance_thread_scope:Destroy() end
            
            -- *** Stop Ball VFX Tracking on Cleanup ***
            StopBallVFXTracking()
            
            isAbilityActive_BHS = false
            print(ABILITY_NAME_BHS .. ": Ability finished and cleaned up.")
        end

        local pcallSuccess, pcallResult = pcall(function()
            if not Camera then Camera = Workspace.CurrentCamera end
            if not Camera then warn(ABILITY_NAME_BHS .. ": Camera not found!"); performCleanupAndReset_BHS_Thread(); return end
            local aimVector = Camera.CFrame.LookVector

            -- // --- Schedule Ball VFX Start --- //
            if BALL_VFX_ENABLED then
                task.delay(BALL_VFX_START_DELAY, function()
                    if not cleanupGuard_BHS.Parent then return end -- Check if ability was cancelled
                    print(ABILITY_NAME_BHS .. ": Starting Ball VFX tracking (Sphere) after " .. BALL_VFX_START_DELAY .. "s delay.")
                    StartBallVFXTracking()
                end)
            end

            -- // --- Animation, SFX, Character VFX Scheduling (Same as before) --- //
            -- Schedule Animation
            if ANIMATION_ID_BHS and ANIMATION_ID_BHS ~= "" and currentHumanoid_scope then
                task.delay(ANIMATION_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Playing animation after " .. ANIMATION_DELAY_BHS .. "s delay. Speed: " .. ANIMATION_SPEED_BHS .. ", Duration: " .. (ANIMATION_DURATION_BHS > 0 and ANIMATION_DURATION_BHS .. "s" or "Full"))
                    local track, animInstance = playAnimation(currentHumanoid_scope, ANIMATION_ID_BHS, ANIMATION_SPEED_BHS, ANIMATION_LOOPED_BHS)
                    if track then
                        currentAnimationTrack_BHS = track
                        animationInstance_thread_scope = animInstance
                        if ANIMATION_DURATION_BHS > 0 then
                            task.delay(ANIMATION_DURATION_BHS, function()
                                if not cleanupGuard_BHS.Parent then return end
                                if currentAnimationTrack_BHS and currentAnimationTrack_BHS == track and currentAnimationTrack_BHS.IsPlaying then
                                    print(ABILITY_NAME_BHS .. ": Stopping animation after " .. ANIMATION_DURATION_BHS .. "s duration.")
                                    currentAnimationTrack_BHS:Stop()
                                    if animationInstance_thread_scope and animationInstance_thread_scope.Parent then 
                                        Debris:AddItem(animationInstance_thread_scope, 0.1)
                                        animationInstance_thread_scope = nil
                                    end 
                                end
                            end)
                        elseif not ANIMATION_LOOPED_BHS then 
                            local effectiveLength = track.Length / (track.Speed > 0 and track.Speed or 1)
                            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then
                                Debris:AddItem(animationInstance_thread_scope, effectiveLength + 0.1)
                            end
                        end
                    end
                end)
            end

            -- Schedule SFX (SIMPLIFIED)
            if SFX_ID_BHS and SFX_ID_BHS ~= "" and SFX_ID_BHS ~= "rbxassetid://YOUR_SFX_ID_HERE" then
                 task.delay(SFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Triggering SFX after " .. SFX_DELAY_BHS .. "s delay. ID: " .. SFX_ID_BHS)
                    local sound = playSound(SFX_ID_BHS, SFX_VOLUME_BHS)
                    if sound then
                        print(ABILITY_NAME_BHS .. ": SFX Playing (Volume: " .. sound.Volume .. ", Full Length: " .. sound.TimeLength .. "s)")
                    else
                        warn(ABILITY_NAME_BHS .. ": Failed to create sound instance for SFX.")
                    end
                 end)
            end

            -- Schedule Character VFX (Original BHS VFX)
            if VFX_ENABLED_BHS then
                task.delay(VFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Triggering Character VFX after " .. VFX_DELAY_BHS .. "s delay.")
                    local currentCharacter_vfx = player.Character
                    if not currentCharacter_vfx then print(ABILITY_NAME_BHS .. ": Char VFX - Character not found."); return end
                    local currentRootPart_vfx = currentCharacter_vfx:FindFirstChild("HumanoidRootPart")
                    if not currentRootPart_vfx then print(ABILITY_NAME_BHS .. ": Char VFX - RootPart not found."); return end
                    
                    local effectPart_vfx = Instance.new("Part")
                    effectPart_vfx.Name = ABILITY_NAME_BHS .. "_CharVFX_Part"
                    effectPart_vfx.Anchored = true
                    effectPart_vfx.CanCollide = false
                    effectPart_vfx.Transparency = 1
                    effectPart_vfx.Parent = Workspace
                    
                    local forward_vfx = currentRootPart_vfx.CFrame.LookVector
                    local effectCFrame_vfx = CFrame.new(currentRootPart_vfx.Position + (forward_vfx * 5), currentRootPart_vfx.Position + (forward_vfx * 5) + forward_vfx)
                    effectPart_vfx.CFrame = effectCFrame_vfx
                    
                    local particles_vfx = {}
                    -- ... (Original Character VFX Emitter Creation Code - Assume it's here) ...
                    do
                        local particle = Instance.new("ParticleEmitter")
                        particle.Name = "CharVFX_Emitter1"
                        -- ... Set properties ...
                        particle.Parent = effectPart_vfx
                        table.insert(particles_vfx, particle)
                    end
                    -- ... (End of Original Character VFX Emitter Creation Code) ...
                    
                    for _, particle in ipairs(particles_vfx) do particle.Enabled = true end
                    local maxLifetime_vfx = 0; for _, p in ipairs(particles_vfx) do maxLifetime_vfx = math.max(maxLifetime_vfx, p.Lifetime.Max) end
                    local totalDuration_vfx = maxLifetime_vfx * 1.5 * VFX_DURATION_MULTIPLIER_BHS
                    print(ABILITY_NAME_BHS .. ": Char VFX active. Duration: " .. string.format("%.2f", totalDuration_vfx) .. "s")
                    task.delay(totalDuration_vfx, function()
                        if effectPart_vfx and effectPart_vfx.Parent then
                            print(ABILITY_NAME_BHS .. ": Disabling Char VFX emitters.")
                            for _, p in ipairs(particles_vfx) do if p and p.Parent then p.Enabled = false end end
                            task.wait(1)
                            if effectPart_vfx and effectPart_vfx.Parent then print(ABILITY_NAME_BHS .. ": Destroying Char VFX part."); effectPart_vfx:Destroy() end
                        end
                    end)
                end)
            end

            -- // --- Pre-Shot Delay (Same as before) --- //
            if ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS > 0 then
                print(ABILITY_NAME_BHS .. ": Waiting for pre-shot delay: " .. ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS .. "s before firing.")
                task.wait(ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS)
            end
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled during pre-shot delay."); performCleanupAndReset_BHS_Thread(); return end 

            -- // --- Fire the Shot (Same as before) --- //
            print(ABILITY_NAME_BHS .. ": Firing ShootRemote with power: " .. ADJUSTABLE_INITIAL_FIREPOWER_BHS)
            local sOk, sErr = pcall(ShootRemote.FireServer, ShootRemote, ADJUSTABLE_INITIAL_FIREPOWER_BHS)
            if not sOk then warn(ABILITY_NAME_BHS .. ": ShootRemote:FireServer() failed: ", sErr); performCleanupAndReset_BHS_Thread(); return end

            task.wait(0.1) 
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled after FireServer."); performCleanupAndReset_BHS_Thread(); return end

            -- // --- Find Ball and Apply Body Movers (Same as before) --- //
            ballInstance_thread_scope = findBall() -- Store the ball found after shooting
            if ballInstance_thread_scope then
                print(ABILITY_NAME_BHS .. ": Ball found after FireServer: ", ballInstance_thread_scope:GetFullName())
                
                -- // --- Apply Body Movers (Same as before) --- //
                cleanupAllMovers(ballInstance_thread_scope) -- Clean previous movers
                local direction = aimVector
                
                print(ABILITY_NAME_BHS .. ": Applying BodyVelocity to ball. Speed: " .. ADJUSTABLE_SHOT_SPEED_BHS .. ", Duration: " .. SHOT_DURATION_BHS .. "s")
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = direction * ADJUSTABLE_SHOT_SPEED_BHS
                bodyVelocity.Parent = ballInstance_thread_scope
                Debris:AddItem(bodyVelocity, SHOT_DURATION_BHS)
                
                -- Schedule final cleanup for movers after duration
                task.delay(SHOT_DURATION_BHS + 0.1, function()
                    if ballInstance_thread_scope and ballInstance_thread_scope.Parent then
                         print(ABILITY_NAME_BHS .. ": Removing force/velocity from ball after " .. SHOT_DURATION_BHS .. "s.")
                         cleanupAllMovers(ballInstance_thread_scope)
                    end
                end)

            else
                warn(ABILITY_NAME_BHS .. ": Ball not found after FireServer! Cannot apply movers.")
                -- Don't cleanup immediately, ball VFX might still be scheduled
                -- performCleanupAndReset_BHS_Thread() 
                -- return
            end

            -- // --- Schedule Final Ability Cleanup (Same as before) --- //
            local maxDuration = math.max(ANIMATION_DURATION_BHS > 0 and (ANIMATION_DELAY_BHS + ANIMATION_DURATION_BHS) or 0, 
                                       SHOT_DURATION_BHS > 0 and (ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS + SHOT_DURATION_BHS + 0.2) or 0,
                                       BALL_VFX_ENABLED and (BALL_VFX_START_DELAY + BALL_VFX_DURATION + 0.2) or 0) -- Include Ball VFX duration in cleanup calculation
            local cleanupDelay = maxDuration + 1.0 -- Add buffer
            print(ABILITY_NAME_BHS .. ": Scheduling final cleanup in " .. string.format("%.2f", cleanupDelay) .. "s.")
            task.delay(cleanupDelay, performCleanupAndReset_BHS_Thread)

        end)

        if not pcallSuccess then
            warn(ABILITY_NAME_BHS .. ": Error during execution: ", pcallResult)
            performCleanupAndReset_BHS_Thread() -- Ensure cleanup on error
        end
    end)
end

-- // UI Creation (Modified Button Name)
local function CreateAbilityButton_BHS()
    if not playerGui then print(ABILITY_NAME_BHS .. ": PlayerGui not found."); return end
    local inGameUI = playerGui:WaitForChild("InGameUI", 10); if not inGameUI then warn(ABILITY_NAME_BHS .. ": InGameUI not found!"); return end
    local bottomFrame = inGameUI:WaitForChild("Bottom", 5); if not bottomFrame then warn(ABILITY_NAME_BHS .. ": Bottom frame not found!"); return end
    local abilitiesFrame = bottomFrame:WaitForChild("Abilities", 5); if not abilitiesFrame then warn(ABILITY_NAME_BHS .. ": Abilities frame not found!"); return end
    
    local templateButton = abilitiesFrame:FindFirstChild("1") or abilitiesFrame:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME_BHS .. ": Template button (","1"," or ImageButton) not found! Cannot create button."); return end

    if abilitiesFrame:FindFirstChild(BUTTON_NAME_BHS) then abilitiesFrame[BUTTON_NAME_BHS]:Destroy() end

    blackHoleStrikeButton = templateButton:Clone()
    blackHoleStrikeButton.Name = BUTTON_NAME_BHS
    blackHoleStrikeButton.LayoutOrder = LAYOUT_ORDER_BHS
    blackHoleStrikeButton.Parent = abilitiesFrame

    local abilityTextLabel = blackHoleStrikeButton:FindFirstChild("Title") or blackHoleStrikeButton:FindFirstChild("Timer", true)
    if abilityTextLabel and abilityTextLabel:IsA("TextLabel") then abilityTextLabel.Text = TIMER_TEXT_BHS
    else warn(ABILITY_NAME_BHS .. ": Ability TextLabel (","Title"," or ","Timer",") not found.") end

    local keybindTextLabel = blackHoleStrikeButton:FindFirstChild("Key") or blackHoleStrikeButton:FindFirstChild("Keybind", true)
    if keybindTextLabel and keybindTextLabel:IsA("TextLabel") then keybindTextLabel.Text = ABILITY_KEY_BHS.Name
    else warn(ABILITY_NAME_BHS .. ": Keybind TextLabel (","Key"," or ","Keybind",") not found.") end
    
    local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
    if not cooldownFrame then
        warn(ABILITY_NAME_BHS .. ": Cooldown frame missing in template, creating basic one.")
        cooldownFrame = Instance.new("Frame", blackHoleStrikeButton)
        cooldownFrame.Name = "Cooldown"
        cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        cooldownFrame.BackgroundTransparency = 0.5
        cooldownFrame.BorderSizePixel = 0
        cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
        cooldownFrame.ZIndex = (blackHoleStrikeButton.ZIndex or 1) + 1
        local gradient = Instance.new("UIGradient", cooldownFrame)
        gradient.Rotation = 90
        gradient.Offset = Vector2.new(0,1) -- Start fully covered
    end
    local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
    if uiGradient then uiGradient.Offset = Vector2.new(0,1) end -- Ensure it starts covered
    
    local actualTimerLabel = blackHoleStrikeButton:FindFirstChild("ActualTimer", true)
    if actualTimerLabel then actualTimerLabel:Destroy() end

    blackHoleStrikeButton.MouseButton1Click:Connect(BlackHoleStrike_Execute)
    print(ABILITY_NAME_BHS .. ": Ability button created and connected.")
end

-- // Input Handling
local inputConnection_BHS = nil
local function HandleInput_BHS(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == ABILITY_KEY_BHS and input.UserInputState == Enum.UserInputState.Begin then
            BlackHoleStrike_Execute()
        end
    end
end

-- // Initialization
local function Initialize()
    print(ABILITY_NAME_BHS .. ": Initializing...")
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10)
    CreateAbilityButton_BHS()
    if inputConnection_BHS then inputConnection_BHS:Disconnect() end
    inputConnection_BHS = UserInputService.InputBegan:Connect(HandleInput_BHS)
    print(ABILITY_NAME_BHS .. " Script Loaded. Press " .. ABILITY_KEY_BHS.Name .. " or click the button.")
end

-- // Cleanup on Character Removal / Script Destroy
local function Cleanup_Global()
    print(ABILITY_NAME_BHS .. ": Global Cleanup...")
    isAbilityActive_BHS = false -- Prevent re-triggering during cleanup
    StopBallVFXTracking() -- Ensure ball VFX stops
    if blackHoleStrikeButton and blackHoleStrikeButton.Parent then blackHoleStrikeButton:Destroy(); blackHoleStrikeButton = nil end
    if inputConnection_BHS then inputConnection_BHS:Disconnect(); inputConnection_BHS = nil end
    -- Destroy any lingering cleanup guards
    if character and character.Parent then
        local guard = character:FindFirstChild(ABILITY_NAME_BHS .. "_CleanupGuard")
        if guard then guard:Destroy() end
    end
end

player.CharacterAdded:Connect(function(newChar)
    print(ABILITY_NAME_BHS .. ": New character added. Re-initializing.")
    Cleanup_Global() -- Clean up old stuff first
    task.wait(1) -- Give things a moment to settle
    Initialize()
end)

player.CharacterRemoving:Connect(function(oldChar)
    print(ABILITY_NAME_BHS .. ": Character removing. Cleaning up.")
    Cleanup_Global()
end)

-- Initial setup
Initialize()

-- Handle potential script destruction (e.g., if re-executed)
-- script.Destroying:Connect(Cleanup_Global) -- Uncomment if needed

