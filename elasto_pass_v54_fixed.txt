--[[
    Ability: ELASTO PASS - Standalone Test V54 (Fixed Syntax + Direct VFX Import)
    Creator: Manus (Integrating User Requirements)
    Version: V54 - Fixed syntax errors and directly imported VFX
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui") -- For Highlight
local SoundService = game:GetService("SoundService")

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10)

-- // Remote Event Acquisition (Direct Path - Confirmed Working)
local shootEvent = nil
local function findShootRemoteStandardPath()
    print("Attempting Standard Path...")
    local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil
    if p then k=p:FindFirstChild("Knit",5) end
    if k then s=k:FindFirstChild("Services",5) end
    if s then b=s:FindFirstChild("BallService",5) end
    if b then r=b:FindFirstChild("RE",5) end
    local remote=r and r:FindFirstChild("Shoot",5)
    if remote and remote:IsA("RemoteEvent")then
        print("ShootRemote FOUND via Standard Path:",remote)
        return remote
    else
        warn("ShootRemote NOT found via Standard Path!")
        return nil
    end
end
shootEvent = findShootRemoteStandardPath()
if not shootEvent then warn("!!! CRITICAL: ShootRemote could not be located. Ability may fail. !!!") end

-- // Ability Settings
local ABILITY_NAME = "Elasto Pass" -- Defined in previous fix
local ABILITY_KEY = Enum.KeyCode.C
local BUTTON_NAME = "ElastoPassButton"
local TIMER_TEXT = "Elasto Pass"
local LAYOUT_ORDER = 3
local PASS_SPEED = 400 -- *** Speed 400 *** (Confirmed by user)
local COOLDOWN = 1
local lastElastoPassTime = 0
local passVelocityConnection = nil
local INITIAL_SHOOT_POWER = 30 -- *** Power 30 for initial detach *** (User specified)
local BALL_LIFT_FORCE = 100000 -- From Traumatized Shot
local BALL_LIFT_HEIGHT = 30 -- From Traumatized Shot
local BALL_FREEZE_DURATION = 0.5 -- From Traumatized Shot
local BALL_VFX_DURATION = 4 -- Duration for the Black & White Ball VFX (seconds)
local WAVE_VFX_DURATION = 3 -- Duration for the Wave Kick VFX (seconds)
local HIGHLIGHT_PULSE_SPEED = 1.5 -- Speed of highlight pulsing effect (lower = slower)

-- // Sound/Animation IDs
local SOUND_ID_ELASTO_PASS = "rbxassetid://9125573611" -- Whoosh sound effect
local SOUND_ID_ELASTO_IMPACT = "rbxassetid://9114487369" -- Impact sound effect
local ANIM_ID_ELASTO_PASS = "rbxassetid://137923447090846" -- Animation ID

-- // Target Tracking Variables (For Highlight & Passing)
local currentTargetTeammate = nil -- Player object (equivalent to Ace Style v328)
local targetHighlight = nil
local targetingConnection = nil
local highlightPulseConnection = nil

-- // Multi-use State Management
local isAbilityActive = false
local reinitializationTimer = nil
local abilityExecutionCount = 0

-- // Sound Effects Container
local sfxContainer = Instance.new("Folder")
sfxContainer.Name = "ElastoPassSFX"
sfxContainer.Parent = SoundService

-- // Helper Functions (Includes functions from Traumatized Shot and aPass)
local function IsReady()
    if isAbilityActive then
        print("Elasto Pass: Ability is currently active, cannot use again")
        return false
    end
    
    local last=lastElastoPassTime or 0
    if typeof(last)~="number" then last=0 end
    return tick()-last>=COOLDOWN
end

local function StartCooldown()
    lastElastoPassTime=tick()
    isAbilityActive = true
    abilityExecutionCount = abilityExecutionCount + 1
    print("Elasto Pass: Execution #" .. abilityExecutionCount)
end

-- Enhanced Sound Function with Preloading and Reliability
local function playSound(id, p, volume)
    if not id or id == "rbxassetid://YOUR_SOUND_ID_HERE" then
        print("SFX Skipped (Placeholder)")
        return
    end
    
    if not p or not p.Parent then
        -- Fallback to SoundService if parent is invalid
        p = sfxContainer
    end
    
    -- Check if sound already exists to avoid spam
    local existingSoundName = "ElastoPassSFX_" .. id:match("%d+")
    local existingSound = p:FindFirstChild(existingSoundName)
    if existingSound and existingSound:IsA("Sound") and existingSound.IsPlaying then
        print("SFX already playing, skipping duplicate")
        return existingSound
    end
    
    -- Create new sound
    local s = Instance.new("Sound")
    s.Name = existingSoundName
    s.Volume = volume or 2
    s.SoundId = id
    s.Parent = p
    
    -- Play with error handling
    local success, err = pcall(function() 
        s:Play() 
    end)
    
    if not success then
        warn("Sound Play Fail:", err)
        
        -- Retry with delay
        task.delay(0.1, function()
            if s and s.Parent then
                pcall(function() s:Play() end)
            end
        end)
    else
        print("Playing SFX:", id, "Volume:", s.Volume)
    end
    
    -- Schedule cleanup using Debris
    task.delay(0.1, function()
        if s and s.Parent then
            local duration = s.TimeLength
            if duration <= 0 then duration = 3 end -- Fallback duration
            Debris:AddItem(s, duration + 0.5)
        end
    end)
    
    return s
end

-- Preload sounds for instant playback
local function preloadSounds()
    local sounds = {
        SOUND_ID_ELASTO_PASS,
        SOUND_ID_ELASTO_IMPACT
    }
    
    for _, id in ipairs(sounds) do
        if id and id ~= "rbxassetid://YOUR_SOUND_ID_HERE" then
            local s = Instance.new("Sound")
            s.Name = "Preload_" .. id:match("%d+")
            s.SoundId = id
            s.Volume = 0
            s.Parent = sfxContainer
            
            -- Load sound but don't play
            pcall(function() 
                s.TimeLength 
            end)
            
            -- Schedule cleanup
            task.delay(5, function()
                if s and s.Parent then
                    s:Destroy()
                end
            end)
        end
    end
    print("Preloaded sound effects for instant playback")
end

-- Call preload on script start
task.spawn(preloadSounds)

-- Animation Function (Loads and caches)
local loadedAnims_Pass={}
local function loadAnimation(id)
    if not id or id == "rbxassetid://YOUR_ANIM_ID_HERE" then return nil end

    -- Ensure humanoid and animator exist
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character and character:WaitForChild("Humanoid")
    if not humanoid then warn("loadAnimation: Humanoid not found"); return nil end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then animator = Instance.new("Animator", humanoid) end

    -- Return cached animation if possible
    if loadedAnims_Pass[id] and loadedAnims_Pass[id].Animator == animator then
        return loadedAnims_Pass[id]
    elseif loadedAnims_Pass[id] then -- Destroy old track if animator changed
        pcall(loadedAnims_Pass[id].Destroy, loadedAnims_Pass[id])
        loadedAnims_Pass[id] = nil
    end

    -- Load new animation
    local animInstance = Instance.new("Animation")
    animInstance.AnimationId = id
    animInstance.Parent = humanoid -- Parent temporarily for loading

    local success, animTrack = pcall(animator.LoadAnimation, animator, animInstance)
    animInstance:Destroy() -- Clean up the temporary instance

    if success and animTrack then
        loadedAnims_Pass[id] = animTrack -- Cache the track
        print("Animation Loaded:", id)
        return animTrack
    else
        warn("Animation load failed:", id, "| Error:", animTrack) -- Error message is in 2nd return value on failure
        return nil
    end
end

-- V11: Robust Ball Physics Cleanup Function (from Traumatized Shot)
local function cleanupBallPhysics(ballInstance)
    if not ballInstance or not ballInstance.Parent or not ballInstance:IsA("BasePart") then
        -- print("CleanupBallPhysics: Ball instance invalid or missing.")
        return
    end
    -- print("CleanupBallPhysics: Running cleanup on", ballInstance:GetFullName())
    for _, child in ipairs(ballInstance:GetChildren()) do
        if child:IsA("BodyMover") or child:IsA("BodyGyro") then
            -- print("CleanupBallPhysics: Destroying", child.Name)
            pcall(child.Destroy, child)
        end
    end
end

-- findBall Function (Adapted from Traumatized Shot for robustness)
local function findBallInWorkspace()
    local f = Workspace:FindFirstChild("Football")
    if f then
        local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
        if b and b:IsA("BasePart") then return b
        elseif f:IsA("Model") and f.PrimaryPart then return f.PrimaryPart
        elseif f:IsA("BasePart") then return f
        end
    end
    local charBall = player.Character and player.Character:FindFirstChild("BALL")
    if charBall and charBall.Parent == Workspace and charBall:IsA("BasePart") then
        -- print("findBall: Found ball directly under character in Workspace")
        return charBall
    end
    return nil
end

local function playerHasBall()
    character=player.Character
    if not character then return false end
    local v=character:FindFirstChild("Values")
    local h=v and v:FindFirstChild("HasBall")
    return h and h.Value==true
end

local function isPlayerInTeam(cP,tF)
    if not tF then return false end
    for _,o in ipairs(tF:GetChildren()) do
        if o:IsA("ObjectValue")then
            if o.Value==cP or o.Name==cP.Name then return true end
        end
    end
    return false
end

local function getPlayerTeam(cP)
    local tf=ReplicatedStorage:FindFirstChild("Teams")
    if not tf then return nil end
    local at=tf:FindFirstChild("AwayTeam")
    local ht=tf:FindFirstChild("HomeTeam")
    if not(at and ht)then return nil end
    if isPlayerInTeam(cP,at)then
        return at
    elseif isPlayerInTeam(cP,ht)then
        return ht
    else
        return nil
    end
end

-- // DIRECTLY IMPORTED: Wave Kick VFX Function (From reference file)
local function playWaveKickVFX(duration)
    if not character or not rootPart then
        warn("Wave Kick VFX: Character or HRP missing")
        return
    end
    
    print("Creating Wave Kick VFX for", duration, "seconds")
    
    local effectPart = Instance.new("Part")
    effectPart.Name = "ElastoPassWaveVFX"
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Parent = workspace
    
    local forward = rootPart.CFrame.LookVector
    local effectCFrame = CFrame.new(
        rootPart.Position + (forward * 5),
        rootPart.Position + (forward * 6)
    )
    effectPart.CFrame = effectCFrame
    
    local particles = {}
    local totalRate = 50
    
    -- White Particles (60%)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.Color = ColorSequence.new(Color3.new(1, 1, 1))
        particle.LightEmission = 0.2
        particle.Brightness = 4
        particle.Rate = totalRate * 0.6
        particle.Texture = "rbxassetid://15537584663"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.Lifetime = NumberRange.new(0.25, 0.35)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
        particle.SpreadAngle = Vector2.new(0, 0)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 0)
        })
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Drag = 10
        particle.Speed = NumberRange.new(100, 100)
        particle.Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1.4),
            NumberSequenceKeypoint.new(0.05, 15.4),
            NumberSequenceKeypoint.new(0.18, 19.8),
            NumberSequenceKeypoint.new(1, 20.4)
        })
        particle.Rotation = NumberRange.new(-360, 360)
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Enabled = false
        particle.Parent = effectPart
        table.insert(particles, particle)
    end
    
    -- Black Particles (40%)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.LightEmission = 0
        particle.Brightness = 0
        particle.Rate = totalRate * 0.4
        particle.Texture = "rbxassetid://15537584663"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.Lifetime = NumberRange.new(0.25, 0.35)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
        particle.SpreadAngle = Vector2.new(0, 0)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 0)
        })
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Drag = 10
        particle.Speed = NumberRange.new(100, 100)
        particle.Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1.4),
            NumberSequenceKeypoint.new(0.05, 15.4),
            NumberSequenceKeypoint.new(0.18, 19.8),
            NumberSequenceKeypoint.new(1, 20.4)
        })
        particle.Rotation = NumberRange.new(-360, 360)
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.ZOffset = 0.01
        particle.Enabled = false
        particle.Parent = effectPart
        table.insert(particles, particle)
    end
    
    -- Enable particles
    for _, particle in ipairs(particles) do
        particle.Enabled = true
    end
    
    -- Calculate max lifetime for cleanup
    local maxLifetime = 0
    for _, particle in ipairs(particles) do
        maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
    end
    
    -- Schedule cleanup after specified duration
    task.delay(duration, function()
        for _, particle in ipairs(particles) do
            if particle and particle.Parent then
                particle.Enabled = false
            end
        end
        
        -- Allow particles to finish before removing
        task.delay(maxLifetime + 0.1, function()
            if effectPart and effectPart.Parent then
                Debris:AddItem(effectPart, 0.1)
            end
        end)
    end)
    
    return effectPart
end

-- // DIRECTLY IMPORTED: Ball VFX Function (From reference file)
local function playElastoPassBallVFX(ballPart, duration)
    if not ballPart or not ballPart:IsA("BasePart") or not ballPart.Parent then
        warn("Ball VFX: Invalid ball part")
        return
    end
    
    print("Creating Black & White Ball VFX for", duration, "seconds")
    
    -- Create container for particles
    local effectPart = Instance.new("Part")
    effectPart.Name = "ElastoPassBallVFX"
    effectPart.Anchored = false
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Size = Vector3.new(0.1, 0.1, 0.1)
    
    -- Create weld to ball
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = effectPart
    weld.Part1 = ballPart
    weld.Parent = effectPart
    
    effectPart.CFrame = ballPart.CFrame
    effectPart.Parent = ballPart
    
    local particles = {}
    
    -- White Particles (60%)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.Color = ColorSequence.new(Color3.new(1, 1, 1))
        particle.LightEmission = 0.2
        particle.LightInfluence = 0
        particle.Brightness = 4
        particle.Texture = "rbxassetid://15537584663"
        particle.Lifetime = NumberRange.new(0.3, 0.5)
        particle.Rate = 30
        particle.Speed = NumberRange.new(5, 10)
        particle.SpreadAngle = Vector2.new(180, 180)
        particle.Rotation = NumberRange.new(-360, 360)
        particle.RotSpeed = NumberRange.new(-100, 100)
        particle.Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.5),
            NumberSequenceKeypoint.new(0.5, 1.5),
            NumberSequenceKeypoint.new(1, 0)
        })
        particle.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.2),
            NumberSequenceKeypoint.new(0.8, 0.5),
            NumberSequenceKeypoint.new(1, 1)
        })
        particle.Parent = effectPart
        table.insert(particles, particle)
    end
    
    -- Black Particles (40%)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.LightEmission = 0
        particle.LightInfluence = 0
        particle.Brightness = 0
        particle.Texture = "rbxassetid://15537584663"
        particle.Lifetime = NumberRange.new(0.3, 0.5)
        particle.Rate = 20
        particle.Speed = NumberRange.new(5, 10)
        particle.SpreadAngle = Vector2.new(180, 180)
        particle.Rotation = NumberRange.new(-360, 360)
        particle.RotSpeed = NumberRange.new(-100, 100)
        particle.Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.5),
            NumberSequenceKeypoint.new(0.5, 1.5),
            NumberSequenceKeypoint.new(1, 0)
        })
        particle.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.2),
            NumberSequenceKeypoint.new(0.8, 0.5),
            NumberSequenceKeypoint.new(1, 1)
        })
        particle.ZOffset = 0.01 -- Slight offset to avoid z-fighting
        particle.Parent = effectPart
        table.insert(particles, particle)
    end
    
    -- Enable particles
    for _, particle in ipairs(particles) do
        particle.Enabled = true
    end
    
    -- Schedule cleanup
    task.delay(duration, function()
        if effectPart and effectPart.Parent then
            for _, particle in ipairs(particles) do
                if particle and particle.Parent then
                    particle.Enabled = false
                end
            end
            
            -- Allow particles to finish before removing
            task.delay(0.5, function()
                if effectPart and effectPart.Parent then
                    effectPart:Destroy()
                end
            end)
        end
    end)
    
    return effectPart
end

-- // Teammate Targeting Logic (Enhanced for Oval Black/White Highlight)
local function getValidTeammates()
    local t={}
    for _,p in ipairs(Players:GetPlayers()) do
        if p~=player and p.Team==player.Team and p.Character and p.Character:FindFirstChild("HumanoidRootPart")then
            table.insert(t,p)
        end
    end
    return t
end

-- Create pulsing effect for highlight
local function startHighlightPulseEffect(highlight)
    if not highlight or not highlight.Parent then return end
    
    -- Clean up existing connection
    if highlightPulseConnection and highlightPulseConnection.Connected then
        highlightPulseConnection:Disconnect()
        highlightPulseConnection = nil
    end
    
    local startTime = tick()
    local frame = highlight:FindFirstChildOfClass("Frame")
    if not frame then return end
    
    highlightPulseConnection = RunService.Heartbeat:Connect(function()
        if not highlight or not highlight.Parent or not frame or not frame.Parent then
            if highlightPulseConnection then highlightPulseConnection:Disconnect() end
            return
        end
        
        -- Calculate pulse value (0-1) using sine wave
        local elapsed = (tick() - startTime) * HIGHLIGHT_PULSE_SPEED
        local pulse = (math.sin(elapsed * math.pi) + 1) / 2 -- 0 to 1 pulse
        
        -- Apply pulse to transparency
        frame.BackgroundTransparency = 0.3 + (pulse * 0.4) -- Pulse between 0.3 and 0.7 transparency
    end)
    
    return highlightPulseConnection
end

local function createTeammateHighlight(teammatePlayer)
    if not teammatePlayer or not teammatePlayer.Character then return nil end
    
    -- Clean up existing highlight
    if targetHighlight and targetHighlight.Parent then
        targetHighlight:Destroy()
        targetHighlight = nil
    end
    
    -- Create a BillboardGui for oval highlight
    local highlight = Instance.new("BillboardGui")
    highlight.Name = "ElastoPassTargetHighlight_Oval"
    highlight.AlwaysOnTop = true
    highlight.Size = UDim2.new(4, 0, 6, 0) -- Oval shape (wider than tall)
    highlight.StudsOffset = Vector3.new(0, 0, 0)
    highlight.Adornee = teammatePlayer.Character:FindFirstChild("HumanoidRootPart")
    
    -- Create gradient frame for black/white effect
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 0.3
    frame.BorderSizePixel = 0
    
    -- Create UIGradient for black to white effect
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), -- Black at top
        ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))  -- White at bottom
    })
    gradient.Rotation = 90
    gradient.Parent = frame
    
    -- Create UICorner for oval shape
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.5, 0) -- Rounded corners for oval effect
    corner.Parent = frame
    
    -- Add frame to billboard
    frame.Parent = highlight
    
    -- Parent to PlayerGui for client-side only visibility
    highlight.Parent = playerGui
    
    -- Start pulsing effect
    startHighlightPulseEffect(highlight)
    
    return highlight
end

local function updateTargetTeammate()
    local validTeammates = getValidTeammates()
    local bestTarget = nil
    local closestDistToCenter = math.huge

    if not Camera or not Camera.Parent then return end
    local viewportSize = Camera.ViewportSize
    local centerScreen = viewportSize / 2
    local mousePos = UserInputService:GetMouseLocation()

    for _, teammatePlayer in ipairs(validTeammates) do
        local teammateChar = teammatePlayer.Character
        local teammateHRP = teammateChar and teammateChar:FindFirstChild("HumanoidRootPart")

        if teammateHRP then
            local screenPos, onScreen = Camera:WorldToViewportPoint(teammateHRP.Position)
            if onScreen then
                -- Calculate distance to mouse cursor instead of screen center
                local distToMouse = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                
                if distToMouse < closestDistToCenter then
                    -- Check if there's anything blocking the view
                    local ray = Ray.new(Camera.CFrame.Position, (teammateHRP.Position - Camera.CFrame.Position).Unit * (teammateHRP.Position - Camera.CFrame.Position).Magnitude)
                    local hit,_ = Workspace:FindPartOnRayWithIgnoreList(ray, {character, teammateChar, Workspace:FindFirstChild("Football")})
                    
                    if not hit or hit:IsDescendantOf(teammateChar) then
                        closestDistToCenter = distToMouse
                        bestTarget = teammatePlayer
                    end
                end
            end
        end
    end
    
    -- Update target and highlight
    if currentTargetTeammate ~= bestTarget then
        currentTargetTeammate = bestTarget
        
        if currentTargetTeammate then
            targetHighlight = createTeammateHighlight(currentTargetTeammate)
            -- Play a subtle targeting sound
            playSound(SOUND_ID_ELASTO_IMPACT, sfxContainer, 0.2)
        else
            if targetHighlight and targetHighlight.Parent then
                targetHighlight:Destroy()
                targetHighlight = nil
            end
        end
    end
end

-- Clean up and initialize targeting system
local function initializeTargetingSystem()
    -- Clean up existing connection
    if targetingConnection and targetingConnection.Connected then
        targetingConnection:Disconnect()
        targetingConnection = nil
    end
    
    -- Clean up existing highlight
    if targetHighlight and targetHighlight.Parent then
        targetHighlight:Destroy()
        targetHighlight = nil
    end
    
    -- Reset current target
    currentTargetTeammate = nil
    
    -- Start targeting update loop
    targetingConnection = RunService.Heartbeat:Connect(updateTargetTeammate)
    
    return targetingConnection
end

-- Initialize targeting on script start
initializeTargetingSystem()

-- // Multi-use Reinitialize Function
local function reinitializeAbility()
    print("Elasto Pass: Re-initializing script functions to enable multi-use...")
    
    -- Cancel any pending reinitialize timer
    if reinitializationTimer then
        reinitializationTimer:Disconnect()
        reinitializationTimer = nil
    end
    
    -- Reset active state
    isAbilityActive = false
    
    -- Reset connections
    if passVelocityConnection and passVelocityConnection.Connected then 
        passVelocityConnection:Disconnect()
        passVelocityConnection = nil
    end
    
    if highlightPulseConnection and highlightPulseConnection.Connected then
        highlightPulseConnection:Disconnect()
        highlightPulseConnection = nil
    end
    
    -- Re-initialize targeting system
    initializeTargetingSystem()
    
    print("Elasto Pass: Re-initialization complete, ability is ready for next use.")
end

-- // Ability Function: ELASTO PASS (V54 - Fixed Syntax + Direct VFX Import)
local function ElastoPass()
    if not IsReady() then print(ABILITY_NAME .. " on CD"); return end
	if not playerHasBall() then warn("Elasto Pass: No ball"); return end
	if not shootEvent then warn("Elasto Pass: ShootRemote missing!"); return end

    character = player.Character; if not character then return end
    humanoid = character:WaitForChild("Humanoid") -- Ensure humanoid is fresh
    rootPart = character:FindFirstChild("HumanoidRootPart"); if not rootPart then return end
    if not humanoid then warn("Elasto Pass: Humanoid missing"); return end

	local targetPlayer = currentTargetTeammate
	if not targetPlayer then warn("Elasto Pass: No teammate currently highlighted/targeted."); return end
	local targetChar = targetPlayer.Character; if not targetChar then warn("Elasto Pass: Target char missing."); return end
	local targetHRP = targetChar:FindFirstChild("HumanoidRootPart"); if not targetHRP then warn("Elasto Pass: Target HRP missing."); return end

    StartCooldown()

    -- << Play Animation >> --
    local animTrack = loadAnimation(ANIM_ID_ELASTO_PASS)
    if animTrack then animTrack:Play(); print("Playing Elasto Pass Animation") end

    -- << Play Sound Effects >> --
    -- Initial whoosh sound when button is clicked
    playSound(SOUND_ID_ELASTO_PASS, rootPart, 2.5)
    
    -- << Play Wave Kick VFX >> --
    playWaveKickVFX(WAVE_VFX_DURATION)

    -- 1. Fire Server Event (Power 30 for detach)
	shootEvent:FireServer(INITIAL_SHOOT_POWER)
    print("Fired ShootRemote (Power " .. INITIAL_SHOOT_POWER .. ") to detach ball")

    -- 2. Lift Ball then Pass
	task.spawn(function()
        local ballInWorkspace, startTime = nil, tick(); local findTimeout = 1.5;
        -- print("Elasto Pass: Starting post-shot ball search...")
		repeat
            task.wait(0.03)
            ballInWorkspace = findBallInWorkspace()
        until (ballInWorkspace and ballInWorkspace:IsA("BasePart")) or tick() - startTime > findTimeout

		if not ballInWorkspace then warn("Elasto Pass: Ball not found post-shot."); return end
        -- print("Elasto Pass: Ball Found: ", ballInWorkspace:GetFullName())

        -- << Play Ball VFX >> --
        playElastoPassBallVFX(ballInWorkspace, BALL_VFX_DURATION)
        
        -- << Play Impact Sound >> --
        playSound(SOUND_ID_ELASTO_IMPACT, ballInWorkspace, 1.8)

        cleanupBallPhysics(ballInWorkspace)
        if ballInWorkspace:IsA("BasePart") then ballInWorkspace.Anchored = false end

        local targetLiftPos = ballInWorkspace.Position + Vector3.new(0, BALL_LIFT_HEIGHT, 0);
        local bp = Instance.new("BodyPosition"); bp.Name = "ElastoLiftBP"
        bp.MaxForce = Vector3.new(1e7, 1e7, 1e7); bp.P = BALL_LIFT_FORCE; bp.D = 2500;
        bp.Position = targetLiftPos; bp.Parent = ballInWorkspace
        -- print("Elasto Pass: Applying Lift BodyPosition (P: " .. BALL_LIFT_FORCE .. ")")

        task.wait(BALL_FREEZE_DURATION)

        local currentTargetHRP_Pass = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not ballInWorkspace or not ballInWorkspace.Parent or not bp or not bp.Parent or not currentTargetHRP_Pass or not currentTargetHRP_Pass.Parent then
            warn("Elasto Pass: Ball, BP, or Target lost during freeze.")
            if bp and bp.Parent then pcall(bp.Destroy,bp) end
            if passVelocityConnection and passVelocityConnection.Connected then passVelocityConnection:Disconnect() end
            return
        end

        pcall(bp.Destroy,bp); -- print("Elasto Pass: Removed Lift BodyPosition")

        -- print("Elasto Pass: Starting pass velocity loop towards", targetPlayer.Name)
        if passVelocityConnection and passVelocityConnection.Connected then passVelocityConnection:Disconnect() end

		passVelocityConnection = RunService.Heartbeat:Connect(function(dt)
            local currentTargetHRP_Loop = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
			if not ballInWorkspace or not ballInWorkspace.Parent or not currentTargetHRP_Loop or not currentTargetHRP_Loop.Parent then
                if passVelocityConnection and passVelocityConnection.Connected then passVelocityConnection:Disconnect() end
                -- warn("Pass Loop: Ball or Target lost.")
                return
			end

            local currentTargetPos = currentTargetHRP_Loop.Position
			local direction = (currentTargetPos - ballInWorkspace.Position).Unit
            local distance = (currentTargetPos - ballInWorkspace.Position).Magnitude

            if distance < 5 then
                -- print("Pass Loop: Ball close to target, stopping velocity.")
                if passVelocityConnection and passVelocityConnection.Connected then passVelocityConnection:Disconnect() end
                return
            end

			if ballInWorkspace:IsA("BasePart") then
                ballInWorkspace.AssemblyLinearVelocity = (direction + Vector3.new(0, 0.1, 0)) * PASS_SPEED
            end
		end)

        task.delay(3.0, function()
            if passVelocityConnection and passVelocityConnection.Connected then
                -- print("Pass Loop: Cleanup timer triggered.")
                passVelocityConnection:Disconnect()
            end
        end)
	end)
    
    -- Schedule script re-execution (excluding UI) to fix one-time use issue
    if reinitializationTimer then
        reinitializationTimer:Disconnect()
        reinitializationTimer = nil
    end
    
    reinitializationTimer = task.delay(4, reinitializeAbility)
end

-- // --- UI Setup for ONLY Elasto Pass --- (UNCHANGED)
local elastoPassButton = nil
local function setupSingleButtonUI()
    local playerGui=player:WaitForChild("PlayerGui");local inGameUI=playerGui:WaitForChild("InGameUI",15);if not inGameUI then warn("No InGameUI");return end;local bottom=inGameUI:WaitForChild("Bottom",10);if not bottom then warn("No Bottom");return end;local bottomAbilities=bottom:WaitForChild("Abilities",10);if not bottomAbilities then warn("No Abilities Frame");return end;local templateButton=bottomAbilities:WaitForChild("1", 5)or bottomAbilities:FindFirstChildWhichIsA("ImageButton");if not templateButton then warn("No Template Button");return end
    local oldBtn=bottomAbilities:FindFirstChild(BUTTON_NAME);if oldBtn then oldBtn:Destroy();task.wait(0.1)end;local b=nil;local s=pcall(function()b=templateButton:Clone()end);if not s or not b then warn("Clone fail");return end;b.Name=BUTTON_NAME;b.Parent=bottomAbilities;b.LayoutOrder=LAYOUT_ORDER;local kL=b:WaitForChild("Keybind",2)or b:FindFirstChildWhichIsA("TextLabel",true);local tL=b:WaitForChild("Timer",2)or b:FindFirstChild("AbilityName",true)or b:FindFirstChildWhichIsA("TextLabel",true);local aTL=b:FindFirstChild("ActualTimer",true);if kL and kL:IsA("TextLabel")then pcall(function()kL.Text=ABILITY_KEY.Name end)else warn("KeybindLbl Missing")end;if tL and tL:IsA("TextLabel")then pcall(function()tL.Text=TIMER_TEXT end)else warn("TimerLbl Missing")end;if aTL and aTL:IsA("TextLabel")then pcall(function()aTL.Text=""end)end;local cV=b:FindFirstChild("Cooldown")or b:FindFirstChild("cooldown");if cV then cV:Destroy()end;local aF=b:FindFirstChild("Ability")or b;if aF and aF:IsA("GuiObject")then local cF=Instance.new("Frame");cF.Name="Cooldown";cF.BackgroundColor3=Color3.fromRGB(0,0,0);cF.BackgroundTransparency=0.6;cF.BorderSizePixel=0;cF.Size=UDim2.new(1,0,1,0);cF.Position=UDim2.new(0,0,1,0);cF.AnchorPoint=Vector2.new(0,1);cF.ZIndex=(aF.ZIndex or 1)+1;cF.Parent=aF;local uC=Instance.new("UICorner",cF);local aS=aF.AbsoluteSize;local r=math.max(1,math.min(aS.X,aS.Y)*0.15);uC.CornerRadius=UDim.new(0,r);aF:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()pcall(function()if not uC or not uC.Parent then return end;local nS=aF.AbsoluteSize;local nR=math.max(1,math.min(nS.X,nS.Y)*0.15);uC.CornerRadius=UDim.new(0,nR)end)end)else warn("Ability Frame missing")end;elastoPassButton=b;print("UI Button Created:",ABILITY_NAME);elastoPassButton.Activated:Connect(ElastoPass);print("Connected Activated")
end

-- // --- Single Button Cooldown Update --- (UNCHANGED)
RunService.Heartbeat:Connect(function(dt)
    if elastoPassButton and elastoPassButton.Parent then
        local tl=(lastElastoPassTime or 0)+COOLDOWN-tick()
        local aF=elastoPassButton:FindFirstChild("Ability")or elastoPassButton
        local cF=aF and aF:FindFirstChild("Cooldown")
        local tL=elastoPassButton:FindFirstChild("Timer")or elastoPassButton:FindFirstChild("AbilityName",true)
        if tL and tL:IsA("TextLabel") then
            if tl>0 then
                if cF then
                    local p=math.clamp(tl/COOLDOWN,0,1)
                    pcall(function()if cF and cF.Parent then cF.Size=UDim2.new(1,0,p,0); cF.Visible=true end end)
                end
                local s,e=pcall(function()tL.Text=string.format("%.1fs",tl)end)
                if not s then warn("Cooldown Text Error:",e) end
            else
                if cF then
                    pcall(function() if cF and cF.Parent then cF.Visible=false end end)
                end
                local s,cT=pcall(function() return tL.Text end)
                if s and cT~=TIMER_TEXT then
                    pcall(function() if tL and tL.Parent then tL.Text=TIMER_TEXT end end)
                end
            end
        end
    end
end)

-- // --- Input Handling --- (UNCHANGED)
UserInputService.InputBegan:Connect(function(i,gp)
    if gp then return end
    if i.UserInputType==Enum.UserInputType.Keyboard and i.KeyCode==ABILITY_KEY then
        pcall(ElastoPass)
    end
end)

-- // --- Respawn Handling --- (UNCHANGED)
player.CharacterAdded:Connect(function(nc)
    print("Character Added (Elasto Pass)")
    character=nc
    humanoid=character:WaitForChild("Humanoid")
    rootPart=character:WaitForChild("HumanoidRootPart")
    playerValues=character:WaitForChild("Values",10)
    lastElastoPassTime=0
    isAbilityActive = false
    
    -- Clean up connections and state
    if passVelocityConnection and passVelocityConnection.Connected then passVelocityConnection:Disconnect() end
    if highlightPulseConnection and highlightPulseConnection.Connected then highlightPulseConnection:Disconnect() end
    if reinitializationTimer then reinitializationTimer:Disconnect() end
    
    -- Reset targeting
    currentTargetTeammate=nil
    if targetHighlight and targetHighlight.Parent then targetHighlight:Destroy();targetHighlight=nil end
    
    -- Re-initialize targeting system
    initializeTargetingSystem()
    
    print("Elasto Pass Test: Respawned.")
end)

-- // --- Initial Setup --- (UNCHANGED)
if shootEvent then
    setupSingleButtonUI()
    print(ABILITY_NAME.." Test Script Loaded! (V54)")
else
    warn(ABILITY_NAME.." Test Script FAILED TO LOAD due to missing ShootRemote.")
end
