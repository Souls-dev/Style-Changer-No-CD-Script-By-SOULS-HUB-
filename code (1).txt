--[[
    Style Name: Combined Abilities Pack
    Rarity: Various
    Description: TRUE INJURED EGOIST WHO ONCE RULE THE FIELD (and other abilities)
    Creator: Gemini (Combined and Optimized from User Scripts)
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local GuiService = game:GetService("GuiService")
local SoundService = game:GetService("SoundService")

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10) -- Used by Chaos Impact, ensure it exists or add check

-- // Knit Framework References
local KnitPackage = ReplicatedStorage:WaitForChild("Packages", 5):WaitForChild("Knit", 5)
if not KnitPackage then warn("Knit package not found!") return end

local KnitPresent, Knit = pcall(require, KnitPackage)
if not KnitPresent or not Knit then warn("Failed to require Knit framework.") return end

local BallService = Knit.GetService and Knit.GetService("BallService")
local AbilityService = Knit.GetService and Knit.GetService("AbilityService")
local TeamService = Knit.GetService and Knit.GetService("TeamService")
local StatesController = Knit.GetController and Knit.GetController("StatesController") -- Used by Egoist Slick & Glitch Dash

-- // Remote Events
local BallServiceRE, AbilityServiceRE
local ShootRemote_Knit, SlideRemote, DribbleRemote, BodyBlockAbilityRemote, BodyBlockUsedRemote
local ShootRemote_CI -- For Chaos Impact

if BallService and typeof(BallService) == "userdata" and BallService.ClassName == "Instance" then
    BallServiceRE = BallService:WaitForChild("RE", 10)
    if BallServiceRE then
        ShootRemote_Knit = BallServiceRE:WaitForChild("Shoot", 5)
        SlideRemote = BallServiceRE:WaitForChild("Slide", 5)
        DribbleRemote = BallServiceRE:WaitForChild("Dribble", 5)
    else
        warn("BallService.RE table not found after waiting!")
    end
else
    warn("BallService is not a valid Instance or is nil for Knit remotes.")
end

if AbilityService and typeof(AbilityService) == "userdata" and AbilityService.ClassName == "Instance" then
    AbilityServiceRE = AbilityService:WaitForChild("RE", 10)
    if AbilityServiceRE then
        BodyBlockAbilityRemote = AbilityServiceRE:WaitForChild("Ability", 5)
        BodyBlockUsedRemote = AbilityServiceRE:WaitForChild("AbilityUsed", 5)
    else
        warn("AbilityService.RE table not found after waiting!")
    end
else
     warn("AbilityService is not a valid Instance or is nil for Knit remotes.")
end

-- For Chaos Impact's ShootRemote
local function findShootRemoteStandardPath_CI()
    -- warn("CI: Attempting Standard Path for ShootRemote_CI...") -- Print removed
    local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil;
    if p then k=p:FindFirstChild("Knit",5)end;
    if k then s=k:FindFirstChild("Services",5)end;
    if s then b=s:FindFirstChild("BallService",5)end;
    if b then r=b:FindFirstChild("RE",5)end;
    local remote=r and r:FindFirstChild("Shoot",5);
    if remote and remote:IsA("RemoteEvent")then
        -- warn("CI: ShootRemote_CI FOUND via Standard Path:",remote); -- Print removed
        return remote
    else
        warn("CI: ShootRemote_CI NOT found via Standard Path!");
        return nil
    end
end
ShootRemote_CI = findShootRemoteStandardPath_CI()
if not ShootRemote_CI then warn("CI: ShootRemote_CI was not found on initial load. Chaos Impact may fail.") end


-- Check for essential remotes needed
if not SlideRemote then warn("SlideRemote (Knit) could not be located! Egoist Slick steal might fail.") end
if not BodyBlockAbilityRemote then warn("BodyBlockAbilityRemote (Knit) not found! Void Guard might fail.") end

-- // Style Configuration (General for UI, can be overridden by specific abilities)
local STYLE_TEXT_COLOR = Color3.fromRGB(0, 0, 0) -- Black for Ego Jinpachi's UI elements

-- // Global Animation Cache
local loadedAnimations = {}

-- // --- GLOBAL HELPER FUNCTIONS ---

local function playSound(soundId, parent, volume, lifetime, looped)
    parent = parent or rootPart
    volume = volume or 1.0
    lifetime = lifetime or 2.0 -- Default lifetime before auto-destroy

    if not soundId or soundId == "rbxassetid://SOUND_ID_HERE" or soundId == "rbxassetid://YOUR_ACTIVATION_SOUND_ID" or not parent or not parent.Parent then return nil end

    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume
    sound.Name = "AbilitySound_" ..tick()
    sound.Parent = parent
    if looped then sound.Looped = true end

    pcall(function() sound:Play() end)

    if lifetime > 0 and not looped then -- Only Debris non-looping sounds with explicit lifetime
        Debris:AddItem(sound, lifetime)
    end
    return sound
end

local function stopAndCleanupSound(soundInstance)
    if soundInstance and soundInstance.Parent then
        pcall(function()
            soundInstance:Stop()
            soundInstance:Destroy()
        end)
    end
end

local function loadAnimationFunc(animId) -- Renamed to avoid conflict if 'loadAnimation' is a global from game
    if not humanoid or not humanoid.Parent then
         character = player.Character or player.CharacterAdded:Wait()
         humanoid = character and character:WaitForChild("Humanoid")
         if not humanoid then warn("LoadAnimation: Humanoid not found"); return nil end
    end
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

    if loadedAnimations[animId] then
        if loadedAnimations[animId].Animator == animator then
             return loadedAnimations[animId]
        else
             loadedAnimations[animId]:Destroy() 
             loadedAnimations[animId] = nil
        end
    end

    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    anim.Parent = humanoid 
    local track = animator:LoadAnimation(anim)
    anim:Destroy() 

    if track then
        loadedAnimations[animId] = track
    else
        warn("Failed to load animation:", animId)
    end
    return track
end

local function findBall(retries, delay)
    retries = retries or 3; delay = delay or 0.1; local ballInstance = nil
    for i = 1, retries do
        local football = Workspace:FindFirstChild("Football")
        if football then
            local ballPart = (football:FindFirstChild("BallAnims") and football.BallAnims:FindFirstChild("BALL")) or football:FindFirstChild("BALL")
            if ballPart and ballPart:IsA("BasePart") then ballInstance = ballPart; break
            elseif football:IsA("Model") and football.PrimaryPart then ballInstance = football.PrimaryPart; break
            elseif football:IsA("BasePart") then ballInstance = football; break 
            end
        end
        -- Fallback from Egoist Slick's findBall
        if not ballInstance then
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Character then
                    local charBall = p.Character:FindFirstChild("BALL")
                    if charBall and charBall:IsA("BasePart") then ballInstance = charBall; break end
                end
            end
            if ballInstance then break end
        end
        if i < retries then task.wait(delay) end
    end
    return ballInstance
end

local function shakeCamera(intensity, duration)
    if not Camera or not Camera.Parent then return end
    local originalCFrame = Camera.CFrame
    local elapsed = 0
    local heartbeat = RunService.Heartbeat
    local connection = nil

    local function stopShake()
        if connection and connection.Connected then
             if Camera and Camera.Parent then Camera.CFrame = originalCFrame end
            connection:Disconnect()
            connection = nil
        end
    end

    connection = heartbeat:Connect(function(dt)
        elapsed = elapsed + dt
        if elapsed < duration then
            local shakeOffset = CFrame.new(
                (math.random()*2-1)*intensity/100,
                (math.random()*2-1)*intensity/100,
                (math.random()*2-1)*intensity/100
            ) * CFrame.Angles(
                math.rad((math.random()*2-1)*intensity*0.1),
                math.rad((math.random()*2-1)*intensity*0.1),
                math.rad((math.random()*2-1)*intensity*0.1)
            )
            if Camera and Camera.Parent then Camera.CFrame = originalCFrame * shakeOffset else stopShake() end
        else
            stopShake()
        end
    end)
    task.delay(duration + 0.1, stopShake)
end

-- Helpers from Chaos Impact (Potentially for global use or can be localized if strictly CI)
local DEFAULT_BALL_MASS_CI = 1.5 -- Specific default for CI
local homeGoalPos_CI = Vector3.new(325,15,-49)
local awayGoalPos_CI = Vector3.new(-247,15,-50)

local function getOpponentGoalPos_CI()
    local t = player.Team
    if not t then return nil end
    return t.Name == "Home" and awayGoalPos_CI or (t.Name == "Away" and homeGoalPos_CI or nil)
end

local function calculatePartMass_CI(part)
    local mass = DEFAULT_BALL_MASS_CI
    if part and part:IsA("BasePart") then
        local s, m = pcall(function() return part:GetMass() end)
        if s and typeof(m) == "number" and m > 0 then mass = m
        else s, m = pcall(function() return part.AssemblyMass end)
            if s and typeof(m) == "number" and m > 0 then mass = m end
        end
    end
    return mass
end

local function calculateModelMass_CI(model)
    local totalMass = 0
    if model and model:IsA("Model") then
        for _, p in ipairs(model:GetDescendants()) do if p:IsA("BasePart") then totalMass = totalMass + calculatePartMass_CI(p) end end
    end
    return totalMass <= 0 and 10 or totalMass
end

local function cleanupAllMovers_CI(target)
    if not target or not target.Parent then return end
    for _, mover in ipairs(target:GetChildren()) do
        if mover:IsA("BodyMover") then
            mover:Destroy()
        end
    end
end

local function applyBodyVelocity_CI(target, velocity, duration, maxForce)
    if not target or not target.Parent then return nil end
    cleanupAllMovers_CI(target)
    local bv = Instance.new("BodyVelocity"); bv.Name = "ChaosImpactMover_V31"
    bv.MaxForce = maxForce or Vector3.new(math.huge, math.huge, math.huge); bv.Velocity = velocity
    bv.Parent = target; if duration and duration > 0 then Debris:AddItem(bv, duration) end
    return bv
end

local function applyBodyPositionFreeze_CI(ball, targetPosition, duration, bodyPosP, bodyPosD, bodyPosMaxForceXZ)
    if not ball or not ball.Parent then warn("CI Freeze (V31): Ball not found for BodyPosition freeze."); return end
    cleanupAllMovers_CI(ball); RunService.Heartbeat:Wait()
    local originalAnchored = ball.Anchored
    ball.Anchored = true; RunService.Heartbeat:Wait()
    ball.CFrame = CFrame.new(targetPosition)
    ball.AssemblyLinearVelocity = Vector3.zero; ball.AssemblyAngularVelocity = Vector3.zero
    ball.Anchored = originalAnchored; RunService.Heartbeat:Wait()
    ball.AssemblyLinearVelocity = Vector3.zero; ball.AssemblyAngularVelocity = Vector3.zero; RunService.Heartbeat:Wait()
    
    local bp = Instance.new("BodyPosition"); bp.Name = "ChaosImpactBodyPositionFreeze_V31"
    local ballMass = calculatePartMass_CI(ball); if ballMass <= 0 then ballMass = DEFAULT_BALL_MASS_CI end
    local yMaxForce = Workspace.Gravity * ballMass * 1.2 + 500 
    bp.MaxForce = Vector3.new(bodyPosMaxForceXZ, yMaxForce, bodyPosMaxForceXZ)
    bp.P = bodyPosP; bp.D = bodyPosD; bp.Position = targetPosition
    bp.Parent = ball
    Debris:AddItem(bp, duration)
end

local function showAimVisualizerSphere_CI(position, radius, duration, transparency)
    if not position then return end
    local existingVis = Workspace:FindFirstChild("ChaosImpactAimVisContainer"); if existingVis then existingVis:Destroy() end
    local visContainer = Instance.new("Model", Workspace); visContainer.Name = "ChaosImpactAimVisContainer"
    local sphere = Instance.new("Part", visContainer); sphere.Name = "ChaosImpactAimVisSphere"; sphere.Shape = Enum.PartType.Ball
    sphere.Size = Vector3.new(radius*2, radius*2, radius*2); sphere.Position = position
    sphere.Color = Color3.new(0,0,0); sphere.Transparency = transparency; sphere.Anchored = true; sphere.CanCollide = false
    local billboardGui = Instance.new("BillboardGui", sphere); billboardGui.Name = "AimTextGui"; billboardGui.Adornee = sphere
    billboardGui.Size = UDim2.new(75,0,30,0); billboardGui.StudsOffset = Vector3.new(0, radius + 10, 0)
    local textLabel = Instance.new("TextLabel", billboardGui); textLabel.Name = "AimTextLabel"; textLabel.BackgroundTransparency=1
    textLabel.Size=UDim2.new(1,0,1,0); textLabel.Font=Enum.Font.SourceSansBold; textLabel.Text="AIM NEAR GOAL"; textLabel.TextColor3=Color3.new(1,1,1)
    textLabel.TextScaled=true; textLabel.TextStrokeColor3=Color3.new(0,0,0); textLabel.TextStrokeTransparency=0
    Debris:AddItem(visContainer, duration)
end

local function isAimingInRadius_CI(goalPosition, radius)
    if not goalPosition or not Camera or not Camera.Parent then return false end
    local camPos, camLook = Camera.CFrame.Position, Camera.CFrame.LookVector
    local vecToGoal = goalPosition - camPos; local pL = vecToGoal:Dot(camLook)
    if pL < 0 then return false end
    return (goalPosition - (camPos + camLook * pL)).Magnitude <= radius
end

-- Helpers from Glitch Dash (Potentially for global use or can be localized)
local function getPlayerPointingDirection_GD(currentHumanoid, currentRootPart)
    if currentHumanoid and currentHumanoid.MoveDirection.Magnitude > 0.1 then
        return currentHumanoid.MoveDirection.Unit
    end
    if currentRootPart then
        return currentRootPart.CFrame.LookVector
    end
    return Camera.CFrame.LookVector
end


-- // --- VFX ASSETS & FUNCTIONS ---
local VFX = {}

VFX.BestShootingVFX2 = function(targetPart) -- From Egoist Slick
    if not targetPart then warn("Target part invalid for BestShootingVFX2") return end
    local vfxContainer = Instance.new("Attachment")
    vfxContainer.Name = "BestShootingVFX2_BW"
    vfxContainer.Parent = targetPart
    local particles = {}
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=3;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.13,0.96875),NumberSequenceKeypoint.new(0.31,0.94375),NumberSequenceKeypoint.new(0.46,0.95),NumberSequenceKeypoint.new(0.6,0.9625),NumberSequenceKeypoint.new(0.74,0.96875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0.75)});p.Speed=NumberRange.new(300.9,401.2);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.21,19.88),NumberSequenceKeypoint.new(1,13.19)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=60;p.VelocityInheritance=0;p.Rotation=NumberRange.new(90);p.ShapePartial=1;p.Texture="rbxassetid://16637904761";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=3.275;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(0,0);p.LockedToPart=false;p.Transparency=NumberSequence.new(0);p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=0;p.Squash=NumberSequence.new(0);p.Speed=NumberRange.new(1.7);p.Size=NumberSequence.new(17.07);p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=12;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0,360);p.ShapePartial=1;p.Texture="rbxassetid://16467645316";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Front;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=4.43;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.2,0.4);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.32,0.9625),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.FacingCamera;p.Drag=7;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new(0);p.Speed=NumberRange.new(100.3,401.2);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,10.22),NumberSequenceKeypoint.new(0.28,16.64),NumberSequenceKeypoint.new(1,25.45)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=60;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0,360);p.ShapePartial=1;p.Texture="rbxassetid://12096349161";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=4.43;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid2x2;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.49,0.875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=12;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-1.2375)});p.Speed=NumberRange.new(401.2,601.8);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.22,25.08),NumberSequenceKeypoint.new(1,11.6)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=40;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://15572330616";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0,0,0));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.07,0.15);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new(0);p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-0.225)});p.Speed=NumberRange.new(212.9,532.3);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.26,7.45),NumberSequenceKeypoint.new(1,20.05)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=-0.76;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=50;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://17258046088";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.25);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid2x2;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.21,0.71875),NumberSequenceKeypoint.new(0.49,0.31875),NumberSequenceKeypoint.new(0.83,0.76875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-1.2375)});p.Speed=NumberRange.new(87.05,304.69);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.21,29.74),NumberSequenceKeypoint.new(1,16.25)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=1;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=50;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://15572330616";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.25);p.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=6;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0.45),NumberSequenceKeypoint.new(1,1.3875)});p.Speed=NumberRange.new(200.6,300.9);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.08,21.13),NumberSequenceKeypoint.new(0.33,34.53),NumberSequenceKeypoint.new(0.65,37.09),NumberSequenceKeypoint.new(1,35.37)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0.7;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=30;p.VelocityInheritance=0;p.Rotation=NumberRange.new(90);p.ShapePartial=1;p.Texture="rbxassetid://11575346457";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    for _, p in ipairs(particles) do p.Enabled = true end
    local maxLife = 0.4
    task.delay(maxLife + 0.1, function()
        if vfxContainer and vfxContainer.Parent then
            for _, p in ipairs(particles) do if p and p.Parent then p.Enabled = false end end
            Debris:AddItem(vfxContainer, 1.5)
        end
    end)
end

VFX.WaveKickRings_Placeholder = function(targetPart) warn("Placeholder VFX: WaveKickRings triggered on", targetPart) end
VFX.PowerUpWaveFire_Placeholder = function(targetPart) warn("Placeholder VFX: PowerUpWaveFire triggered on", targetPart) end
VFX.BlackFireKickBall_Placeholder = function(targetPart) warn("Placeholder VFX: BlackFireKickBall triggered on", targetPart) end
VFX.BestKickBW_Placeholder = function(targetPart) warn("Placeholder VFX: BestKickBW triggered on", targetPart) end

-- VFX from Chaos Impact (Player Aura)
local function VFX_ChaosImpact_PlayerKickAura(targetCharacter, duration)
    if not targetCharacter or not targetCharacter.Parent then return end
    local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
         warn("Player HRP not found for Chaos Impact Kick VFX.")
         return
    end
    local effectTargetPart = humanoidRootPart
    local vfxContainer = Instance.new("Attachment")
    vfxContainer.Name = "BestKickVFX_BW_ColorOnly_CI"
    vfxContainer.Parent = effectTargetPart
    local particles = {}
    do local particle=Instance.new("ParticleEmitter");local parent=vfxContainer;particle.Color=ColorSequence.new(Color3.new(1,1,1));particle.LightEmission=0.8;particle.Brightness=10;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(30,30);particle.Lifetime=NumberRange.new(0.2,0.35);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.None;particle.SpreadAngle=Vector2.new(360,360);particle.LockedToPart=true;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Orientation=Enum.ParticleOrientation.VelocityParallel;particle.Drag=10;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=360;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.226704,1.425),NumberSequenceKeypoint.new(1,1.65)});particle.Speed=NumberRange.new(400,600);particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.17266,7.764939),NumberSequenceKeypoint.new(1,0)});particle.Enabled=false;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=50;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(90,90);particle.ShapePartial=1;particle.Texture="rbxassetid://13386858482";particle.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;particle.EmissionDirection=Enum.NormalId.Top;particle.FlipbookIncompatible="Particle texture must be 1024 by 1024 to use flipbooks.";particle.Shape=Enum.ParticleEmitterShape.Box;particle.Parent=parent;table.insert(particles,particle)end
    do local particle=Instance.new("ParticleEmitter");local parent=vfxContainer;particle.Color=ColorSequence.new(Color3.new(0,0,0));particle.LightEmission=0;particle.Brightness=0;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1,1);particle.Lifetime=NumberRange.new(0.25,0.35);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;particle.SpreadAngle=Vector2.new(50,50);particle.LockedToPart=true;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;particle.Drag=0;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=50;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(0.1,0.1);particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});particle.Enabled=false;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=50;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="rbxassetid://13395479051";particle.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;particle.EmissionDirection=Enum.NormalId.Front;particle.FlipbookIncompatible="Particle texture must be 1024 by 1024 to use flipbooks.";particle.Shape=Enum.ParticleEmitterShape.Box;particle.Parent=parent;table.insert(particles,particle)end
    do local particle=Instance.new("ParticleEmitter");local parent=vfxContainer;particle.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));particle.LightEmission=0;particle.Brightness=0.1;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1,1);particle.Lifetime=NumberRange.new(0.15,0.35);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;particle.SpreadAngle=Vector2.new(5,5);particle.LockedToPart=true;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;particle.Drag=0;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=5;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(0.1,0.1);particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});particle.Enabled=false;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=50;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="rbxassetid://13395481373";particle.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;particle.EmissionDirection=Enum.NormalId.Front;particle.FlipbookIncompatible="Particle texture must be 1024 by 1024 to use flipbooks.";particle.Shape=Enum.ParticleEmitterShape.Box;particle.Parent=parent;table.insert(particles,particle)end
    do local particle=Instance.new("ParticleEmitter");local parent=vfxContainer;particle.Color=ColorSequence.new(Color3.new(1,1,1));particle.LightEmission=1;particle.Brightness=10;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1,1);particle.Lifetime=NumberRange.new(0.05,0.05);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.None;particle.SpreadAngle=Vector2.new(360,360);particle.LockedToPart=true;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.30137,0.475),NumberSequenceKeypoint.new(1,1)});particle.Orientation=Enum.ParticleOrientation.FacingCamera;particle.Drag=5;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=360;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(0,0);particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,13.051071),NumberSequenceKeypoint.new(1,101.363541)});particle.Enabled=false;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=3;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=32;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(0,0);particle.ShapePartial=0.3499999940395355;particle.Texture="rbxassetid://11503727043";particle.FlipbookMode=Enum.ParticleFlipbookMode.Loop;particle.EmissionDirection=Enum.NormalId.Top;particle.FlipbookIncompatible="Particle texture must be 1024 by 1024 to use flipbooks.";particle.Shape=Enum.ParticleEmitterShape.Box;particle.Parent=parent;table.insert(particles,particle)end
    do local particle=Instance.new("ParticleEmitter");local parent=vfxContainer;particle.Color=ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),ColorSequenceKeypoint.new(0.5,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(0,0,0))});particle.LightEmission=0.5;particle.Brightness=4;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1,1);particle.Lifetime=NumberRange.new(0.25,0.35);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;particle.SpreadAngle=Vector2.new(50,50);particle.LockedToPart=true;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;particle.Drag=0;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=50;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(0.1,0.1);particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});particle.Enabled=false;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=50;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="rbxassetid://13395479051";particle.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;particle.EmissionDirection=Enum.NormalId.Front;particle.FlipbookIncompatible="Particle texture must be 1024 by 1024 to use flipbooks.";particle.Shape=Enum.ParticleEmitterShape.Box;particle.Parent=parent;table.insert(particles,particle)end
    for _, particle in ipairs(particles) do particle.Enabled = true end
    task.delay(duration, function()
         if vfxContainer and vfxContainer.Parent then
             for _, particle in ipairs(particles) do
                 if particle and particle.Parent then particle.Enabled = false end
             end
             Debris:AddItem(vfxContainer, 1.5)
        end
    end)
end

-- Placeholder VFX functions from Chaos Impact (as original script had them)
local VFX_BALL_BLACK_FIRE_PLACEHOLDER_CI = function(ballInstance, actionType) 
    warn("Placeholder VFX_BALL_BLACK_FIRE_PLACEHOLDER_CI called for: " .. tostring(ballInstance) .. " Action: " .. tostring(actionType))
end
local VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER_CI = function(playerRootPartInstance) 
    warn("Placeholder VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER_CI called for: " .. tostring(playerRootPartInstance))
end


-- Forward declaration of Execute functions
local EgoistSlick_Execute, TraumatizedCurve_Execute, ElastoPass_Execute, VoidGuard_Execute, ChaosImpact_Execute, BlackHoleStrike_Execute, GlitchRush_Execute

-- // --- ABILITY DEFINITIONS & CONFIGURATIONS ---
local abilities = {
    EgoistSlick = {
        Name = "EgoistSlick", Key = Enum.KeyCode.Z, Cooldown = 5, ButtonName = "EgoistSlickButton", TimerText = "Egoist Slick", LayoutOrder = 1,
        Execute = function() EgoistSlick_Execute() end,
        AnimID = "rbxassetid://74760828875758", SoundID = "rbxassetid://SOUND_ID_HERE"
    },
    TraumatizedCurve = {
        Name = "TraumatizedCurve", Key = Enum.KeyCode.X, Cooldown = 12, ButtonName = "TraumatizedCurveButton", TimerText = "Traumatized Curve", LayoutOrder = 2,
        Execute = function() TraumatizedCurve_Execute() end,
        AnimID = "rbxassetid://115758343285328", SoundID = "rbxassetid://SOUND_ID_HERE"
    },
    ElastoPass = {
        Name = "ElastoPass", Key = Enum.KeyCode.C, Cooldown = 8, ButtonName = "ElastoPassButton", TimerText = "Elasto Pass", LayoutOrder = 3,
        Execute = function() ElastoPass_Execute() end,
        AnimID = "rbxassetid://18668827116", SoundID = "rbxassetid://SOUND_ID_HERE"
    },
    VoidGuard = {
        Name = "VoidGuard", Key = Enum.KeyCode.V, Cooldown = 0.5, ButtonName = "VoidGuardButton", TimerText = "Void Guard OFF", LayoutOrder = 4,
        IsToggle = true, -- Special property for toggleable abilities
        Execute = function() VoidGuard_Execute() end
        -- No specific AnimID/SoundID in original EgoistSlick table for VoidGuard itself
    },
    ChaosImpact = {
        Name = "ChaosImpact", Key = Enum.KeyCode.F, Cooldown = 15, ButtonName = "ChaosImpactButton", TimerText = "Chaos Impact", LayoutOrder = 5,
        Execute = function() ChaosImpact_Execute() end,
        -- Configurable values from Chaos Impact script
        VFXActivationDelay = 1.0, VFXDuration = 4.5,
        LevitateHeight = 15, LevitateDuration = 0.5, LevitateAirTime = 1.0,
        AimVisualizerDuration = 5, AimVisualizerTransparency = 0.7, AimVisualizerRadius = 200,
        ShotStartDelay = 0.1, ShotPostInitialFireWait = 0.4, ShotPostStage1FreezeDuration = 0.7, ShotStage2PauseFreezeDuration = 0.7,
        InitialShotPower = 15, ShotStage1Speed = 100, ShotStage1StopDistance = 100,
        ShotStage2SideSpeed = 80, ShotStage2Duration = 0.4,
        ShotStage3FinalSpeed = 400, ShotStage3Duration = 2.0,
        BodyPosPGain = 50000, BodyPosDGain = 1250, BodyPosMaxForceXZ = 40000,
        AnimIDLevitate = "rbxassetid://YOUR_LEVITATE_ANIM_ID", AnimIDShotMain = "rbxassetid://YOUR_MAIN_SHOT_ANIM_ID",
        AnimIDShotSide = "rbxassetid://YOUR_SIDE_SHOT_ANIM_ID", AnimIDShotFinal = "rbxassetid://YOUR_FINAL_SHOT_ANIM_ID",
        SoundIDActivation = "rbxassetid://YOUR_ACTIVATION_SOUND_ID", SoundIDLevitate = "rbxassetid://YOUR_LEVITATE_SOUND_ID",
        SoundIDShotInitial = "rbxassetid://YOUR_INITIAL_SHOT_SOUND_ID", SoundIDShotSide = "rbxassetid://YOUR_SIDE_SHOT_SOUND_ID",
        SoundIDShotFinal = "rbxassetid://YOUR_FINAL_SHOT_SOUND_ID", SoundIDBallFreeze = "rbxassetid://YOUR_BALL_FREEZE_SOUND_ID"
    },
    BlackHoleStrike = {
        Name = "BlackHoleStrike", Key = Enum.KeyCode.G, Cooldown = 20, ButtonName = "BlackHoleStrikeButton", TimerText = "Black Hole Strike", LayoutOrder = 6,
        Execute = function() BlackHoleStrike_Execute() end,
        AnimID = "rbxassetid://115758343285328", SoundID = "rbxassetid://SOUND_ID_HERE"
    },
    GlitchRush = {
        Name = "GlitchRush",
        -- IMPORTANT: BlackHoleStrike also uses KeyCode.G. You MUST change one of these keybinds.
        Key = Enum.KeyCode.G, Cooldown = 3, ButtonName = "GlitchRushCustomButton", TimerText = "GLITCH RUSH", LayoutOrder = 7, -- ButtonName changed to avoid conflict if "custom" is too generic
        Execute = function() GlitchRush_Execute() end,
        -- Configurable values from Glitch Dash script
        GlitchDuration = 1.5, GlitchFrequency = 0.05, GlitchDistance = 6, GlitchIterations = 30,
        Dash1Distance = 3.0, Dash1Steps = 5, Dash1StepDelay = 0.01, Dash1SpeedMultiplier = 2.0,
        WaitBetweenDashes = 1.0,
        Dash2Distance = 3.0, Dash2Steps = 5, Dash2StepDelay = 0.01, Dash2SpeedMultiplier = 2.0,
        Dash3Distance = 3.0, Dash3Steps = 5, Dash3StepDelay = 0.01, Dash3SpeedMultiplier = 2.0,
        GlitchColorPrimary = Color3.fromRGB(255,255,255), GlitchColorSecondary = Color3.fromRGB(0,0,0),
        AnimIDDash = "rbxassetid://131979551237806", AnimIDMovement = "rbxassetid://74249210159048",
        SoundIDDash = "rbxassetid://3084314259", SoundIDActivation = "rbxassetid://YOUR_ACTIVATION_SOUND_ID", SoundIDLeftRight = "rbxassetid://6896112317",
        DashSoundVolume = 5, DashSoundLifetime = 2.0, LeftRightSoundVolume = 5
    }
}

local abilityLastUseTimes = {}
local abilityActiveStates = {} -- For abilities with an "active" state, e.g., isAbilityActive_CI, or toggles like VoidGuard
for name, _ in pairs(abilities) do
    abilityLastUseTimes[name] = 0
    abilityActiveStates[name] = false -- Default active state; toggles will manage their 'IsToggled' state separately if needed.
end
if abilities.VoidGuard then abilityActiveStates.VoidGuard_IsToggled = false end -- Specific for VoidGuard toggle

-- // --- SHARED COOLDOWN LOGIC ---
local function IsReady(abilityName)
    if not abilities[abilityName] then return false end
    return tick() - (abilityLastUseTimes[abilityName] or 0) >= (abilities[abilityName].Cooldown or 999)
end

local function StartGlobalCooldown(abilityName)
    if not abilities[abilityName] then return end
    abilityLastUseTimes[abilityName] = tick()
end

-- // --- ABILITY IMPLEMENTATION FUNCTIONS ---

-- // 1. EGOIST SLICK
EgoistSlick_Execute = function()
    local abilityName = "EgoistSlick"
    if not IsReady(abilityName) then return end
    if not rootPart or not rootPart.Parent or not humanoid or not humanoid.Parent then
         warn(abilityName .. ": Cannot find player RootPart/Humanoid.")
         return
    end

    local targetPlayer = nil
    local closestDist = 15
    local minDist = 5

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Team ~= player.Team and otherPlayer.Character then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHRP then
                local dist = (rootPart.Position - otherHRP.Position).Magnitude
                if dist >= minDist and dist <= closestDist then
                    local ray = Ray.new(rootPart.Position, (otherHRP.Position - rootPart.Position).Unit * dist)
                    local hit, pos = Workspace:FindPartOnRayWithIgnoreList(ray, {character, otherPlayer.Character})
                    if not hit or hit:IsDescendantOf(otherPlayer.Character) then
                        closestDist = dist
                        targetPlayer = otherPlayer
                    end
                end
            end
        end
    end

    if not targetPlayer or not targetPlayer.Character then
        warn(abilityName .. ": No suitable opponent found.")
        return
    end

    StartGlobalCooldown(abilityName)
    local targetHRP = targetPlayer.Character.HumanoidRootPart
    local playerToTarget = (targetHRP.Position - rootPart.Position).Unit
    local rightVector = rootPart.CFrame.RightVector
    local dotProduct = playerToTarget:Dot(rightVector)
    local directionVector = targetHRP.CFrame.RightVector
    local offsetDistance = 4
    local teleportPos

    if dotProduct > 0.1 then teleportPos = targetHRP.Position - (directionVector * offsetDistance)
    elseif dotProduct < -0.1 then teleportPos = targetHRP.Position + (directionVector * offsetDistance)
    else teleportPos = targetHRP.Position + (directionVector * offsetDistance)
    end
    teleportPos = Vector3.new(teleportPos.X, targetHRP.Position.Y + 0.5, teleportPos.Z)

    if VFX and VFX.BestShootingVFX2 then VFX.BestShootingVFX2(rootPart) else warn("BestShootingVFX2 not found in VFX table for " .. abilityName) end
    rootPart.CFrame = CFrame.lookAt(teleportPos, targetHRP.Position)
    local animTrack = loadAnimationFunc(abilities[abilityName].AnimID)
    if animTrack then animTrack:Play(0.1, 1, 1.2) else warn("Failed to load " .. abilityName .. " animation") end
    playSound(abilities[abilityName].SoundID, rootPart, 2)
    task.wait(0.05)
    if SlideRemote then SlideRemote:FireServer(targetPlayer) else warn(abilityName .. ": SlideRemote is nil, cannot fire.") end
end

-- // 2. TRAUMATIZED CURVE (Placeholder)
TraumatizedCurve_Execute = function()
    local abilityName = "TraumatizedCurve"
    if not IsReady(abilityName) then return end
    warn(abilityName .. " activated (Placeholder)")
    StartGlobalCooldown(abilityName)
    -- Add actual logic here
    -- Example: playSound(abilities[abilityName].SoundID, rootPart, 2)
    -- local animTrack = loadAnimationFunc(abilities[abilityName].AnimID) etc.
end

-- // 3. ELASTO PASS (Placeholder)
ElastoPass_Execute = function()
    local abilityName = "ElastoPass"
    if not IsReady(abilityName) then return end
    warn(abilityName .. " activated (Placeholder)")
    StartGlobalCooldown(abilityName)
    -- Add actual logic here
end

-- // 4. VOID GUARD (Partial Placeholder - Toggle Logic)
VoidGuard_Execute = function()
    local abilityName = "VoidGuard"
    if not IsReady(abilityName) then return end -- Cooldown is very short, acts more like a rate limit
    
    abilityActiveStates.VoidGuard_IsToggled = not abilityActiveStates.VoidGuard_IsToggled -- Toggle the state
    StartGlobalCooldown(abilityName) -- Apply the minimal cooldown/rate limit

    if abilityActiveStates.VoidGuard_IsToggled then
        warn(abilityName .. " Turned ON (Placeholder for actual effect)")
        -- Example: BodyBlockAbilityRemote:FireServer("ActivateVoidGuard")
    else
        warn(abilityName .. " Turned OFF (Placeholder for deactivation)")
        -- Example: BodyBlockAbilityRemote:FireServer("DeactivateVoidGuard")
    end
    -- Update button text will be handled by the main UI loop
end

-- // 5. CHAOS IMPACT
ChaosImpact_Execute = function()
    local abilityName = "ChaosImpact"
    local config = abilities[abilityName]

    if abilityActiveStates[abilityName] then return end -- Already active
    if character then cleanupAllMovers_CI(rootPart) end
    local bfc = findBall(1,0); if bfc then cleanupAllMovers_CI(bfc) end
    task.wait(0.05)

    if not IsReady(abilityName) then return end
    
    -- Re-fetch character components just in case
    local currentCharacter = player.Character
    if not currentCharacter then warn(abilityName ..": Character not found."); return end
    local currentHumanoid = currentCharacter:FindFirstChildOfClass("Humanoid")
    local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart")
    local currentPlayerValues = currentCharacter:FindFirstChild("Values")

    if not (currentHumanoid and currentRootPart and currentPlayerValues) then warn(abilityName..": Character components missing."); return end
    
    local hbv = currentPlayerValues:FindFirstChild("HasBall"); 
    if not hbv or not hbv.Value then warn(abilityName..": Player does not have ball."); return end
    
    if not ShootRemote_CI then 
        ShootRemote_CI = findShootRemoteStandardPath_CI() -- Try to find it again if missing
        if not ShootRemote_CI then warn(abilityName..": ShootRemote_CI missing!"); return end 
    end
    
    local goalPosition = getOpponentGoalPos_CI(); 
    if not goalPosition then warn(abilityName..": Opponent goal not found."); return end
    
    if not isAimingInRadius_CI(goalPosition, config.AimVisualizerRadius) then 
        showAimVisualizerSphere_CI(goalPosition, config.AimVisualizerRadius, config.AimVisualizerDuration, config.AimVisualizerTransparency)
        return 
    end

    abilityActiveStates[abilityName] = true
    StartGlobalCooldown(abilityName)
    
    -- Play player kick aura VFX (from Chaos Impact)
    task.delay(config.VFXActivationDelay, function()
        if currentCharacter and currentCharacter.Parent then -- Check if character still exists
            VFX_ChaosImpact_PlayerKickAura(currentCharacter, config.VFXDuration)
        end
    end)
    playSound(config.SoundIDActivation, currentRootPart, 2)

    task.spawn(function()
        local success = false
        local cleanupGuard = Instance.new("BoolValue", currentCharacter); cleanupGuard.Name = "ChaosImpactCleanupGuard_V31_Combined"

        local function performCleanupAndReset_CI()
            if not cleanupGuard or not cleanupGuard.Parent then return end; cleanupGuard:Destroy()
            if currentRootPart and currentRootPart.Parent then cleanupAllMovers_CI(currentRootPart) end
            local ball = findBall(1,0); if ball then cleanupAllMovers_CI(ball) end
            abilityActiveStates[abilityName] = false
        end

        local pcallSuccess, pcallResult = pcall(function()
            if not (currentCharacter and currentCharacter.Parent and currentRootPart and currentRootPart.Parent) then performCleanupAndReset_CI(); return end;

            local charMass = calculateModelMass_CI(currentCharacter)
            VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER_CI(currentRootPart) -- Placeholder call
            playSound(config.SoundIDLevitate, currentRootPart, 2)
            applyBodyVelocity_CI(currentRootPart, Vector3.new(0, config.LevitateHeight / config.LevitateDuration, 0), config.LevitateDuration, Vector3.new(0, charMass*Workspace.Gravity*1.5, 0))
            
            task.wait(config.LevitateDuration); if not cleanupGuard.Parent then return end
            cleanupAllMovers_CI(currentRootPart)
            
            local currentGoalPos = getOpponentGoalPos_CI()
            if not currentGoalPos then performCleanupAndReset_CI(); return end;
            
            local distToGoalForCalc = (currentGoalPos - currentRootPart.Position).Magnitude
            if distToGoalForCalc < config.ShotStage1StopDistance then distToGoalForCalc = config.ShotStage1StopDistance + 10 end


            local totalShotDur = config.ShotStartDelay + config.ShotPostInitialFireWait +
                                 ((distToGoalForCalc - config.ShotStage1StopDistance) / config.ShotStage1Speed) +
                                 config.ShotPostStage1FreezeDuration + config.ShotStage2Duration +
                                 config.ShotStage2PauseFreezeDuration + config.ShotStage3Duration

            local airTimeBV = applyBodyVelocity_CI(currentRootPart, Vector3.zero, config.LevitateAirTime + totalShotDur + 0.2, Vector3.new(0,charMass*Workspace.Gravity,0))
            
            task.wait(config.LevitateAirTime); if not cleanupGuard.Parent then return end
            task.wait(config.ShotStartDelay); if not cleanupGuard.Parent then return end

            playSound(config.SoundIDShotInitial, currentRootPart, 2)
            local sOk, sErr = pcall(ShootRemote_CI.FireServer, ShootRemote_CI, config.InitialShotPower)
            if not sOk then warn(abilityName..": ShootRemote_CI Fail:", sErr); performCleanupAndReset_CI(); return end
            
            task.wait(config.ShotPostInitialFireWait); if not cleanupGuard.Parent then return end

            local ball = findBall(3, 0.1); 
            if not ball then warn(abilityName..": Ball not found after initial shot."); performCleanupAndReset_CI(); return end
            
            VFX_BALL_BLACK_FIRE_PLACEHOLDER_CI(ball, "InitialShot") -- Placeholder call
            playSound(config.SoundIDBallFreeze, ball, 1.5)

            local cgp = getOpponentGoalPos_CI(); 
            if not cgp then warn(abilityName..": Opponent goal not found for stage 1."); performCleanupAndReset_CI(); return end
            
            local vtg = cgp - ball.Position; local dtg = vtg.Magnitude
            local s1d = dtg - config.ShotStage1StopDistance; 
            if s1d <= 0 then warn(abilityName..": Ball already past stop distance for stage 1."); performCleanupAndReset_CI(); return end
            
            local s1dur = s1d / config.ShotStage1Speed
            applyBodyVelocity_CI(ball, vtg.Unit * config.ShotStage1Speed, s1dur + 0.1)
            task.wait(s1dur); if not cleanupGuard.Parent then return end
            
            local freezePosStage1 = ball.Position 
            applyBodyPositionFreeze_CI(ball, freezePosStage1, config.ShotPostStage1FreezeDuration + 0.05, config.BodyPosPGain, config.BodyPosDGain, config.BodyPosMaxForceXZ)
            task.wait(config.ShotPostStage1FreezeDuration); if not cleanupGuard.Parent then return end
            cleanupAllMovers_CI(ball); RunService.Heartbeat:Wait()

            ball = findBall(1,0); 
            if not ball then warn(abilityName..": Ball not found for stage 2."); performCleanupAndReset_CI(); return end
            
            playSound(config.SoundIDShotSide, ball, 2)
            local sideDir = currentRootPart.CFrame.RightVector
            applyBodyVelocity_CI(ball, sideDir * config.ShotStage2SideSpeed, config.ShotStage2Duration + 0.1)
            task.wait(config.ShotStage2Duration); if not cleanupGuard.Parent then return end
            
            local freezePosStage2 = ball.Position 
            playSound(config.SoundIDBallFreeze, ball, 1.5)
            applyBodyPositionFreeze_CI(ball, freezePosStage2, config.ShotStage2PauseFreezeDuration + 0.05, config.BodyPosPGain, config.BodyPosDGain, config.BodyPosMaxForceXZ)
            task.wait(config.ShotStage2PauseFreezeDuration); if not cleanupGuard.Parent then return end
            cleanupAllMovers_CI(ball); RunService.Heartbeat:Wait()

            ball = findBall(1,0); 
            if not ball then warn(abilityName..": Ball not found for stage 3."); performCleanupAndReset_CI(); return end
            
            cgp = getOpponentGoalPos_CI(); 
            if not cgp then warn(abilityName..": Opponent goal not found for stage 3."); performCleanupAndReset_CI(); return end
            
            vtg = cgp - ball.Position
            VFX_BALL_BLACK_FIRE_PLACEHOLDER_CI(ball, "FinalShot") -- Placeholder call
            playSound(config.SoundIDShotFinal, ball, 3)
            local finalStrikeBV = applyBodyVelocity_CI(ball, vtg.Unit * config.ShotStage3FinalSpeed, config.ShotStage3Duration + 0.2)
            if not (finalStrikeBV and finalStrikeBV.Parent) then 
                warn(abilityName..": Failed to apply final strike BodyVelocity.")
                performCleanupAndReset_CI()
                return
            end
            task.wait(config.ShotStage3Duration)
            if not cleanupGuard.Parent then return end
            
            success = true
        end)

        if not pcallSuccess then
            warn(abilityName.." Error (V31):", pcallResult)
        end
        performCleanupAndReset_CI()
    end)
end

-- // 6. BLACK HOLE STRIKE (Placeholder)
BlackHoleStrike_Execute = function()
    local abilityName = "BlackHoleStrike"
    if not IsReady(abilityName) then return end
    warn(abilityName .. " activated (Placeholder)")
    StartGlobalCooldown(abilityName)
    -- Add actual logic here
end

-- // 7. GLITCH RUSH
local glitchRushMovementAnimTrack = nil -- Specific to Glitch Rush
GlitchRush_Execute = function()
    local abilityName = "GlitchRush"
    local config = abilities[abilityName]

    if abilityActiveStates[abilityName] then return end
    if not IsReady(abilityName) then return end
    
    local currentCharacter = player.Character
    if not currentCharacter then warn(abilityName .. ": Character not found."); return end
    local currentHumanoid = currentCharacter:FindFirstChildOfClass("Humanoid")
    local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart")
    if not (currentHumanoid and currentRootPart) then warn(abilityName..": Character components missing."); return end
    
    -- VFX CODE from Glitch Dash (Inline)
    local effectDuration = 5 
    if RunService:IsClient() then
        local humanoidRootPartForVFX = currentRootPart
        local effectPart = Instance.new("Part")
        effectPart.Anchored = true; effectPart.CanCollide = false; effectPart.Transparency = 1
        effectPart.Parent = Workspace; effectPart.CFrame = humanoidRootPartForVFX.CFrame
        local vfxParticles = {}
        do local particle=Instance.new("ParticleEmitter");local parent=effectPart;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1);particle.LightInfluence=0;particle.Lifetime=NumberRange.new(0.3,0.4);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.None;particle.SpreadAngle=Vector2.new(15,15);particle.LockedToPart=false;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.598806,0),NumberSequenceKeypoint.new(0.720159,0.61875),NumberSequenceKeypoint.new(0.872679,0.925),NumberSequenceKeypoint.new(1,1)});particle.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;particle.Color=ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.5,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.501,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))});particle.Drag=0;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=15;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(0.001,0.001);particle.Brightness=3;particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,4.043619),NumberSequenceKeypoint.new(0.2,5.333644),NumberSequenceKeypoint.new(0.3,6.164438),NumberSequenceKeypoint.new(0.4,6.753995),NumberSequenceKeypoint.new(0.5,7.186415),NumberSequenceKeypoint.new(0.6,7.504354),NumberSequenceKeypoint.new(0.7,7.732507),NumberSequenceKeypoint.new(0.8,7.886009),NumberSequenceKeypoint.new(0.9,7.973793),NumberSequenceKeypoint.new(1,8),NumberSequenceKeypoint.new(1,8)});particle.Enabled=true;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(480,720);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=25;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="rbxassetid://12050306299";particle.FlipbookMode=Enum.ParticleFlipbookMode.Loop;particle.EmissionDirection=Enum.NormalId.Front;particle.Shape=Enum.ParticleEmitterShape.Box;particle.LightEmission=-4;particle.Parent=parent;table.insert(vfxParticles,particle)end
        do local particle=Instance.new("ParticleEmitter");local parent=effectPart;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1);particle.LightInfluence=0;particle.Lifetime=NumberRange.new(0.4,0.6);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.None;particle.SpreadAngle=Vector2.new(15,15);particle.LockedToPart=false;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.199602,0.53125),NumberSequenceKeypoint.new(1,1)});particle.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;particle.Color=ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.5,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.501,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))});particle.Drag=0;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=15;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(0.001,0.001);particle.Brightness=1;particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,3.538166),NumberSequenceKeypoint.new(0.2,4.666938),NumberSequenceKeypoint.new(0.3,5.393883),NumberSequenceKeypoint.new(0.4,5.909746),NumberSequenceKeypoint.new(0.5,6.288113),NumberSequenceKeypoint.new(0.6,6.56631),NumberSequenceKeypoint.new(0.7,6.765944),NumberSequenceKeypoint.new(0.8,6.900258),NumberSequenceKeypoint.new(0.9,6.977068),NumberSequenceKeypoint.new(1,7),NumberSequenceKeypoint.new(1,7)});particle.Enabled=true;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(480,720);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=20;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="http://www.roblox.com/asset/?id=121270653244867";particle.FlipbookMode=Enum.ParticleFlipbookMode.Loop;particle.EmissionDirection=Enum.NormalId.Front;particle.Shape=Enum.ParticleEmitterShape.Box;particle.LightEmission=0;particle.Parent=parent;table.insert(vfxParticles,particle)end
        do local particle=Instance.new("ParticleEmitter");local parent=effectPart;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1);particle.LightInfluence=0;particle.Lifetime=NumberRange.new(0.5,0.8);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.None;particle.SpreadAngle=Vector2.new(90,90);particle.LockedToPart=false;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Orientation=Enum.ParticleOrientation.FacingCamera;particle.Color=ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.5,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.501,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))});particle.Drag=10;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=90;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(20,50);particle.Brightness=1;particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.4,0.6),NumberSequenceKeypoint.new(1,0)});particle.Enabled=true;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=30;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="http://www.roblox.com/asset/?id=71165508990372";particle.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;particle.EmissionDirection=Enum.NormalId.Top;particle.Shape=Enum.ParticleEmitterShape.Disc;particle.LightEmission=0;particle.Parent=parent;table.insert(vfxParticles,particle)end
        do local particle=Instance.new("ParticleEmitter");local parent=effectPart;particle.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;particle.FlipbookFramerate=NumberRange.new(1);particle.LightInfluence=0;particle.Lifetime=NumberRange.new(0.4,0.5);particle.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid8x8;particle.SpreadAngle=Vector2.new(360,360);particle.LockedToPart=false;particle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Orientation=Enum.ParticleOrientation.FacingCamera;particle.Color=ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.5,Color3.new(0.2,0.2,0.2)),ColorSequenceKeypoint.new(0.501,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))});particle.Drag=0;particle.FlipbookStartRandom=false;particle.TimeScale=1;particle.VelocitySpread=360;particle.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});particle.Speed=NumberRange.new(3,8);particle.Brightness=1;particle.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,2.527262),NumberSequenceKeypoint.new(0.2,3.333527),NumberSequenceKeypoint.new(0.3,3.852774),NumberSequenceKeypoint.new(0.4,4.221247),NumberSequenceKeypoint.new(0.5,4.491509),NumberSequenceKeypoint.new(0.6,4.690222),NumberSequenceKeypoint.new(0.7,4.832817),NumberSequenceKeypoint.new(0.8,4.928756),NumberSequenceKeypoint.new(0.9,4.98362),NumberSequenceKeypoint.new(1,5),NumberSequenceKeypoint.new(1,5)});particle.Enabled=true;particle.Acceleration=Vector3.new(0,0,0);particle.RotSpeed=NumberRange.new(0,0);particle.ZOffset=0;particle.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;particle.Rate=70;particle.VelocityInheritance=0;particle.Rotation=NumberRange.new(-360,360);particle.ShapePartial=1;particle.Texture="rbxassetid://14201241100";particle.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;particle.EmissionDirection=Enum.NormalId.Top;particle.Shape=Enum.ParticleEmitterShape.Box;particle.LightEmission=0;particle.Parent=parent;table.insert(vfxParticles,particle)end
        for _,p in ipairs(vfxParticles) do p.Enabled = true end
        local maxLifetime=0; for _,p in ipairs(vfxParticles)do maxLifetime=math.max(maxLifetime,p.Lifetime.Max)end
        local vfxStartTime=tick(); local vfxConnection
        local function cleanupVFX_GD()
            if vfxConnection then vfxConnection:Disconnect();vfxConnection=nil end
            for _,p in ipairs(vfxParticles)do if p and p.Parent then p.Enabled=false end end
            task.delay(maxLifetime+0.5,function() if effectPart and effectPart.Parent then effectPart:Destroy()end end)
        end
        vfxConnection=RunService.RenderStepped:Connect(function()
            if tick()-vfxStartTime>=effectDuration then cleanupVFX_GD();return end
            if humanoidRootPartForVFX and humanoidRootPartForVFX.Parent then effectPart.CFrame=humanoidRootPartForVFX.CFrame else cleanupVFX_GD() end
        end)
        local charRemovingConn_GD; charRemovingConn_GD = player.CharacterRemoving:Connect(function() cleanupVFX_GD(); if charRemovingConn_GD then charRemovingConn_GD:Disconnect() end end)
    end
    -- End VFX Code

    abilityActiveStates[abilityName] = true
    StartGlobalCooldown(abilityName)
    playSound(config.SoundIDActivation, currentRootPart, config.LeftRightSoundVolume) -- Assuming this is the main activation sound
    
    -- Movement Animation from Glitch Dash
    if not glitchRushMovementAnimTrack then
        glitchRushMovementAnimTrack = loadAnimationFunc(config.AnimIDMovement)
    end
    if glitchRushMovementAnimTrack then 
        glitchRushMovementAnimTrack:Play()
        task.delay(4, function() -- Original duration was 4s total for 3 dashes + waits
            if glitchRushMovementAnimTrack and glitchRushMovementAnimTrack.IsPlaying then
                glitchRushMovementAnimTrack:Stop()
            end
        end)
    end

    task.spawn(function()
        local cleanupGuard_GD = Instance.new("BoolValue", currentCharacter); cleanupGuard_GD.Name = "GlitchRushCleanupGuard_Combined"
        
        local dashAnimTrack_GD = loadAnimationFunc(config.AnimIDDash) -- Preload/get dash animation

        local function performLeftRightIllusion_GD(rootP, duration, frequency, distance, iterations)
            if not rootP or not rootP.Parent then return end
            local lrSound = playSound(config.SoundIDLeftRight, rootP, config.LeftRightSoundVolume, 0, true) -- Looping
            local startTime = tick(); local rightVec = rootP.CFrame.RightVector
            local iterCount = 0; local dir = 1
            local conn; conn = RunService.Heartbeat:Connect(function()
                if not cleanupGuard_GD.Parent then if conn then conn:Disconnect() end; stopAndCleanupSound(lrSound); return end
                if (tick() - startTime > duration) or (iterCount >= iterations) then 
                    if conn then conn:Disconnect() end; return 
                end
                if (tick() - startTime) % frequency < 0.01 then
                    local sideOffset = rightVec * (dir * distance)
                    local currentPos = rootP.Position
                    local newPos = Vector3.new(currentPos.X + sideOffset.X, currentPos.Y, currentPos.Z + sideOffset.Z)
                    rootP.CFrame = CFrame.new(newPos) * (rootP.CFrame - rootP.Position)
                    dir = -dir; iterCount = iterCount + 1
                end
            end)
            task.wait(duration)
            if conn and conn.Connected then conn:Disconnect() end
            stopAndCleanupSound(lrSound)
        end

        local function performAntiCheatSafeDash_GD(rootP, hum, direction, totalDist, steps, stepDel, speedMult, isLast)
            if not rootP or not direction or not hum or not rootP.Parent or not hum.Parent then return end
            local stepDist = totalDist / steps; local origCF = rootP.CFrame; local origWS = hum.WalkSpeed
            hum.WalkSpeed = origWS * speedMult
            local bv = Instance.new("BodyVelocity"); bv.MaxForce = Vector3.new(50000,0,50000); bv.P = 1250
            bv.Velocity = direction * (stepDist/stepDel) * 1.5; bv.Parent = rootP
            
            if dashAnimTrack_GD then dashAnimTrack_GD:Play(0.1) else warn(abilityName..": Dash animation track not loaded.") end
            playSound(config.SoundIDDash, rootP, config.DashSoundVolume, config.DashSoundLifetime)
            
            for i=1, steps do
                if not cleanupGuard_GD.Parent then if bv.Parent then bv:Destroy() end; hum.WalkSpeed = origWS; return end
                local newPos = rootP.Position + (direction * stepDist)
                newPos = Vector3.new(newPos.X, rootP.Position.Y, newPos.Z)
                rootP.CFrame = CFrame.new(newPos) * CFrame.Angles(origCF:ToOrientation())
                task.wait(stepDel)
            end
            if bv.Parent then bv:Destroy() end
            hum.WalkSpeed = origWS
            if isLast and dashAnimTrack_GD then dashAnimTrack_GD:Stop() end
        end

        local pcallSuccess_GD, pcallResult_GD = pcall(function()
            if not cleanupGuard_GD.Parent then return end
            performLeftRightIllusion_GD(currentRootPart, config.GlitchDuration, config.GlitchFrequency, config.GlitchDistance, config.GlitchIterations)
            if not cleanupGuard_GD.Parent then return end

            local pointDir = getPlayerPointingDirection_GD(currentHumanoid, currentRootPart)
            performAntiCheatSafeDash_GD(currentRootPart, currentHumanoid, pointDir, config.Dash1Distance, config.Dash1Steps, config.Dash1StepDelay, config.Dash1SpeedMultiplier, false)
            if not cleanupGuard_GD.Parent then return end
            
            task.wait(config.WaitBetweenDashes)
            if not cleanupGuard_GD.Parent then return end

            pointDir = getPlayerPointingDirection_GD(currentHumanoid, currentRootPart)
            performAntiCheatSafeDash_GD(currentRootPart, currentHumanoid, pointDir, config.Dash2Distance, config.Dash2Steps, config.Dash2StepDelay, config.Dash2SpeedMultiplier, false)
            if not cleanupGuard_GD.Parent then return end

            task.wait(config.WaitBetweenDashes)
            if not cleanupGuard_GD.Parent then return end

            pointDir = getPlayerPointingDirection_GD(currentHumanoid, currentRootPart)
            performAntiCheatSafeDash_GD(currentRootPart, currentHumanoid, pointDir, config.Dash3Distance, config.Dash3Steps, config.Dash3StepDelay, config.Dash3SpeedMultiplier, true)
            
            task.wait(0.2)
        end)

        if not pcallSuccess_GD then
            warn(abilityName.." Error: " .. tostring(pcallResult_GD))
            if currentHumanoid and currentHumanoid.Parent then currentHumanoid.WalkSpeed = currentHumanoid.WalkSpeed > 0 and currentHumanoid.WalkSpeed or 16 end
            if dashAnimTrack_GD and dashAnimTrack_GD.IsPlaying then dashAnimTrack_GD:Stop() end
        end
        
        if cleanupGuard_GD and cleanupGuard_GD.Parent then cleanupGuard_GD:Destroy() end
        abilityActiveStates[abilityName] = false
    end)
end


-- // --- UI SETUP ---
local abilityButtons = {} -- Stores button instances, keyed by ability name

local function setupAllAbilityUI()
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn("InGameUI not found for UI setup.") return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn("Bottom frame not found for UI setup.") return end
    local bottomAbilitiesFrame = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilitiesFrame then warn("Abilities Frame not found for UI setup.") return end
    
    local templateButton = bottomAbilitiesFrame:FindFirstChild("1") or bottomAbilitiesFrame:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn("Template button ('1' or ImageButton) not found in Abilities Frame!") return end

    -- Clear existing buttons managed by this script
    for name, btnInstance in pairs(abilityButtons) do
        if btnInstance and btnInstance.Parent then btnInstance:Destroy() end
        abilityButtons[name] = nil
    end
    for name, data in pairs(abilities) do -- Also clear by config ButtonName if any linger
        local oldBtn = bottomAbilitiesFrame:FindFirstChild(data.ButtonName)
        if oldBtn then oldBtn:Destroy() end
    end
    task.wait(0.1)

    for name, data in pairs(abilities) do
        local button = nil
        local successClone = pcall(function() button = templateButton:Clone() end)
        if not successClone or not button then warn("Failed to clone template button for", name); continue end

        button.Name = data.ButtonName
        button.Parent = bottomAbilitiesFrame
        button.LayoutOrder = data.LayoutOrder

        local keybindLabel = button:FindFirstChild("Keybind", true)
        local timerLabel = button:FindFirstChild("Timer", true) or button:FindFirstChild("AbilityName", true) -- For timer text or ability name
        local actualTimerLabel = button:FindFirstChild("ActualTimer", true) -- For cooldown numbers

        if keybindLabel and keybindLabel:IsA("TextLabel") then keybindLabel.Text = data.Key.Name else warn("Keybind Label not found for", name) end
        if timerLabel and timerLabel:IsA("TextLabel") then timerLabel.Text = data.TimerText else warn("Timer Label not found for", name) end
        if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = "" end
        
        local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown") -- Common names
        if cdVisual then cdVisual:Destroy() end -- Remove template's cooldown visual to replace

        local abilityFrameForCD = button:FindFirstChild("Ability") or button -- Frame where CD bar is parented
        if abilityFrameForCD then
            local cooldownFrame = Instance.new("Frame")
            cooldownFrame.Name = "CooldownOverlay" -- New name to avoid conflict
            cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            cooldownFrame.BackgroundTransparency = 0.6
            cooldownFrame.BorderSizePixel = 0
            cooldownFrame.Size = UDim2.new(1, 0, 1, 0) -- Full size, bar goes up
            cooldownFrame.Position = UDim2.new(0, 0, 1, 0) -- Start from bottom
            cooldownFrame.AnchorPoint = Vector2.new(0, 1) -- Anchor at bottom-left
            cooldownFrame.ZIndex = (abilityFrameForCD:IsA("GuiObject") and abilityFrameForCD.ZIndex or 1) + 1
            cooldownFrame.Parent = abilityFrameForCD
            cooldownFrame.Visible = false -- Initially hidden

            local uiCorner = Instance.new("UICorner", cooldownFrame)
            local absSize = abilityFrameForCD:IsA("GuiObject") and abilityFrameForCD.AbsoluteSize or Vector2.new(50,50)
            local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
            uiCorner.CornerRadius = UDim.new(0, radius)

            if abilityFrameForCD:IsA("GuiObject") then
                abilityFrameForCD:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                    local newAbsSize = abilityFrameForCD.AbsoluteSize
                    local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                    uiCorner.CornerRadius = UDim.new(0, newRadius)
                end)
            end
        else
             warn("Could not find 'Ability' frame or base button to parent cooldown visual for", name)
        end
        
        button.Activated:Connect(function()
            if data.Execute then data.Execute() end
        end)
        abilityButtons[name] = button
    end
end

-- // --- COOLDOWN UPDATE LOOP ---
RunService.Heartbeat:Connect(function(dt)
    for name, button in pairs(abilityButtons) do
        local buttonExists = pcall(function() return button.Parent end)
        if not buttonExists then abilityButtons[name] = nil; continue end

        if button and button.Parent then
            local abilityData = abilities[name]
            if not abilityData then continue end

            local timeLeft = (abilityLastUseTimes[name] or 0) + (abilityData.Cooldown or 0) - tick()
            
            local abilityFrame = button:FindFirstChild("Ability") or button
            local cooldownFrame = abilityFrame and abilityFrame:FindFirstChild("CooldownOverlay")
            local timerTextLabel = button:FindFirstChild("Timer", true) or button:FindFirstChild("AbilityName", true)
            local actualTimerNumLabel = button:FindFirstChild("ActualTimer", true)


            if timeLeft > 0 then
                if cooldownFrame then
                    local progress = math.clamp(timeLeft / abilityData.Cooldown, 0, 1)
                    pcall(function() cooldownFrame.Size = UDim2.new(1, 0, progress, 0) end)
                    cooldownFrame.Visible = true
                end
                if actualTimerNumLabel and actualTimerNumLabel:IsA("TextLabel") then
                     pcall(function() actualTimerNumLabel.Text = string.format("%.1fs", timeLeft) end)
                elseif timerTextLabel and timerTextLabel:IsA("TextLabel") then -- Fallback to main timer label if ActualTimer not present
                     pcall(function() timerTextLabel.Text = string.format("%.1fs", timeLeft) end)
                end
            else
                if cooldownFrame then cooldownFrame.Visible = false end
                
                local newText = abilityData.TimerText
                if abilityData.IsToggle then -- Special handling for toggle text like VoidGuard
                    newText = abilityActiveStates[name .. "_IsToggled"] and (abilityData.TimerText .. " ON") or (abilityData.TimerText .. " OFF")
                end

                if timerTextLabel and timerTextLabel:IsA("TextLabel") and timerTextLabel.Text ~= newText then
                    pcall(function() timerTextLabel.Text = newText end)
                end
                if actualTimerNumLabel and actualTimerNumLabel:IsA("TextLabel") and actualTimerNumLabel.Text ~= "" then
                    pcall(function() actualTimerNumLabel.Text = "" end)
                end
            end
        end
    end
end)

-- // --- EGO JINPANCHI STYLE UI TEXT UPDATE (from Egoist Slick) ---
-- This updates specific UI elements related to "EGO JINPANCHI".
-- If this script is for a different style or a general pack, you might want to adjust or remove this.
task.spawn(function()
    local StyleBG = playerGui:WaitForChild("Style", 15)
    if not StyleBG then warn("Ego Jinpachi Style GUI ('Style') not found.") return end
    local BG = StyleBG:WaitForChild("BG", 10)
    if not BG then warn("Ego Jinpachi Style BG Frame not found.") return end
    
    local StyleTxt = BG:FindFirstChild("StyleTxt")
    local Slots = BG:FindFirstChild("Slots")
    local Desc = BG:FindFirstChild("Desc")
    if not (StyleTxt and Slots and Desc) then warn("Ego Jinpachi Style UI elements (StyleTxt, Slots, Desc) missing.") return end
    
    local ScrollingFrame = Slots:FindFirstChildOfClass("ScrollingFrame")
    local Slot1 = ScrollingFrame and ScrollingFrame:FindFirstChild("Slot1")
    local Slot1Text = Slot1 and (Slot1:FindFirstChild("TextLabel") or Slot1:FindFirstChild("Text") or Slot1:FindFirstChildWhichIsA("TextLabel", true))
    if not Slot1Text then warn("Ego Jinpachi Slot 1 Text Label not found.") end

    local EGO_JINPANCHI_STYLE_NAME = "EGO JINPANCHI"
    local EGO_JINPANCHI_STYLE_DESC = "TRUE INJURED EGOIST WHO ONCE RULE THE FIELD"

    while task.wait(1) do
        pcall(function()
            if StyleTxt then StyleTxt.Text = EGO_JINPANCHI_STYLE_NAME; StyleTxt.TextColor3 = STYLE_TEXT_COLOR end
            if Slot1Text then Slot1Text.Text = EGO_JINPANCHI_STYLE_NAME; Slot1Text.TextColor3 = STYLE_TEXT_COLOR end
            if Desc then Desc.Text = EGO_JINPANCHI_STYLE_DESC; Desc.TextColor3 = STYLE_TEXT_COLOR end
        end)
    end
end)


-- // --- CHARACTER RESPAWN HANDLING ---
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10) -- Re-fetch for CI

    loadedAnimations = {} -- Clear animation cache
    glitchRushMovementAnimTrack = nil -- Reset specific animation track for Glitch Rush

    for name, _ in pairs(abilities) do
        abilityLastUseTimes[name] = 0
        abilityActiveStates[name] = false
        if abilities[name].IsToggle then abilityActiveStates[name .. "_IsToggled"] = false end -- Reset toggle states
    end
    
    -- Re-setup UI in case it was destroyed or needs refresh
    -- setupAllAbilityUI() -- Consider if this is needed; if UI persists, it's not. If UI is character-bound, it is.
    -- For safety, usually good to re-run UI setup or at least ensure buttons are correctly connected.
    -- However, the original scripts didn't explicitly re-run full UI setup on CharacterAdded, mostly variable resets.
    -- Let's stick to variable resets unless UI issues are observed.
end)

-- // --- INPUT HANDLING ---
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
    local key = input.KeyCode

    for name, data in pairs(abilities) do
        if data.Key == key then
            if data.Execute then
                pcall(data.Execute) -- Wrap execution in pcall for safety
            end
            break -- Assuming one key press triggers one ability
        end
    end
end)

-- // --- INITIALIZATION ---
setupAllAbilityUI()
warn("Combined Abilities Pack Loaded Successfully!")