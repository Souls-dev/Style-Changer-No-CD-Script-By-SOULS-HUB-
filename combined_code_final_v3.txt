--[[
    Style Name: EGO JINPANCHI
    Rarity: World Class
    Description: TRUE INJURED EGOIST WHO ONCE RULE THE FIELD
    Creator: Gemini (Based on User Prompt)
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")

-- // Player & Character Variables
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- // Knit Framework References (Added more checks)
local KnitPackage = ReplicatedStorage:WaitForChild("Packages", 5):WaitForChild("Knit", 5)
if not KnitPackage then warn("Knit package not found!") return end -- Stop if Knit package missing

local KnitPresent, Knit = pcall(require, KnitPackage)
if not KnitPresent or not Knit then warn("Failed to require Knit framework.") return end -- Stop if require fails

print("Knit Required Successfully:", KnitPresent)

-- Attempt to get Services, check type rigorously
local BallService = Knit.GetService and Knit.GetService("BallService")
local AbilityService = Knit.GetService and Knit.GetService("AbilityService")
local TeamService = Knit.GetService and Knit.GetService("TeamService")
local StatesController = Knit.GetController and Knit.GetController("StatesController")

print("BallService:", BallService, "| Type:", typeof(BallService))
print("AbilityService:", AbilityService, "| Type:", typeof(AbilityService))
print("TeamService:", TeamService, "| Type:", typeof(TeamService))
print("StatesController:", StatesController, "| Type:", typeof(StatesController))


-- // Remote Events (Revised with TYPE checks and more specific waits)
local BallServiceRE -- Removed AbilityServiceRE
local ShootRemote, SlideRemote, DribbleRemote -- Removed BodyBlockAbilityRemote, BodyBlockUsedRemote

-- Wait for BallService RE table only if BallService is a valid Instance
if BallService and typeof(BallService) == "userdata" and BallService.ClassName == "Instance" then -- Check ClassName for services
    print("BallService is valid Instance, waiting for RE...")
    BallServiceRE = BallService:WaitForChild("RE", 10) -- Increased wait time
    if BallServiceRE then
        print("BallService.RE found. Waiting for specific remotes...")
        ShootRemote = BallServiceRE:WaitForChild("Shoot", 5)
        SlideRemote = BallServiceRE:WaitForChild("Slide", 5) -- Needed for Egoist Slick
        DribbleRemote = BallServiceRE:WaitForChild("Dribble", 5)
    else
        warn("BallService.RE table not found after waiting!")
    end
else
    warn("BallService is not a valid Instance or is nil.")
end

-- Removed AbilityService RE block

-- Final check for essential remotes needed for Egoist Slick
if not SlideRemote then warn("SlideRemote could not be located! Egoist Slick steal might fail.") end
-- Removed check for BodyBlockAbilityRemote


-- // Style Configuration
local STYLE_NAME = "EGO JINPANCHI"
local STYLE_RARITY = "World Class"
local STYLE_DESCRIPTION = "TRUE INJURED EGOIST WHO ONCE RULE THE FIELD"
local STYLE_TEXT_COLOR = Color3.fromRGB(0, 0, 0) -- Black

-- // Ability Settings & Cooldowns
local abilities = {
    EgoistSlick = { Key = Enum.KeyCode.Z, Cooldown = 5, ButtonName = "EgoistSlickButton", TimerText = "Egoist Slick", LayoutOrder = 1 }
    -- Removed TraumatizedCurve, ElastoPass, VoidGuard, ChaosImpact, BlackHoleStrike
}
local abilityCooldowns = {}
local lastAbilityTimes = {}
-- Simplified setup for only EgoistSlick
abilityCooldowns["EgoistSlick"] = abilities.EgoistSlick.Cooldown
lastAbilityTimes["EgoistSlick"] = 0

-- Removed Void Guard state variables

-- // Placeholder IDs
local ANIM_ID_EGOIST_SLICK = "rbxassetid://74760828875758"
-- Removed other ANIM_IDs
local SOUND_ID_EGOIST_SLICK = "rbxassetid://SOUND_ID_HERE" -- Kept placeholder as requested
-- Removed other SOUND_IDs


-- // VFX Code Blocks
local VFX = {} -- Initialize VFX Table

-- Integrated "BEST SHOOTING VFX 2" (Color Only Change) - Keep as used by EgoistSlick
VFX.BestShootingVFX2 = function(targetPart)
    if not targetPart then warn("Target part invalid for BestShootingVFX2") return end
    print("Playing BestShootingVFX2 on", targetPart) -- Debug Print

    local vfxContainer = Instance.new("Attachment")
    vfxContainer.Name = "BestShootingVFX2_BW"
    vfxContainer.Parent = targetPart

    local particles = {}
    -- Emitter 1 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=3;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.13,0.96875),NumberSequenceKeypoint.new(0.31,0.94375),NumberSequenceKeypoint.new(0.46,0.95),NumberSequenceKeypoint.new(0.6,0.9625),NumberSequenceKeypoint.new(0.74,0.96875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0.75)});p.Speed=NumberRange.new(300.9,401.2);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.21,19.88),NumberSequenceKeypoint.new(1,13.19)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=60;p.VelocityInheritance=0;p.Rotation=NumberRange.new(90);p.ShapePartial=1;p.Texture="rbxassetid://16637904761";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 2 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=3.275;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(0,0);p.LockedToPart=false;p.Transparency=NumberSequence.new(0);p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=0;p.Squash=NumberSequence.new(0);p.Speed=NumberRange.new(1.7);p.Size=NumberSequence.new(17.07);p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=12;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0,360);p.ShapePartial=1;p.Texture="rbxassetid://16467645316";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Front;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 3 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=4.43;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.2,0.4);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.32,0.9625),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.FacingCamera;p.Drag=7;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new(0);p.Speed=NumberRange.new(100.3,401.2);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,10.22),NumberSequenceKeypoint.new(0.28,16.64),NumberSequenceKeypoint.new(1,25.45)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=60;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0,360);p.ShapePartial=1;p.Texture="rbxassetid://12096349161";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 4 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=4.43;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid2x2;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.49,0.875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=12;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-1.2375)});p.Speed=NumberRange.new(401.2,601.8);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.22,25.08),NumberSequenceKeypoint.new(1,11.6)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=40;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://15572330616";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 5 (Black)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0,0,0));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.07,0.15);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new(0);p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-0.225)});p.Speed=NumberRange.new(212.9,532.3);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.26,7.45),NumberSequenceKeypoint.new(1,20.05)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=-0.76;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=50;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://17258046088";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 6 (Dark Gray)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.25);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid2x2;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.21,0.71875),NumberSequenceKeypoint.new(0.49,0.31875),NumberSequenceKeypoint.new(0.83,0.76875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-1.2375)});p.Speed=NumberRange.new(87.05,304.69);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.21,29.74),NumberSequenceKeypoint.new(1,16.25)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=1;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=50;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://15572330616";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
     -- Emitter 7 (Dark Gray)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.25);p.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=6;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0.45),NumberSequenceKeypoint.new(1,1.3875)});p.Speed=NumberRange.new(200.6,300.9);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.08,21.13),NumberSequenceKeypoint.new(0.33,34.53),NumberSequenceKeypoint.new(0.65,37.09),NumberSequenceKeypoint.new(1,35.37)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0.7;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=30;p.VelocityInheritance=0;p.Rotation=NumberRange.new(90);p.ShapePartial=1;p.Texture="rbxassetid://11575346457";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end

    for _, p in ipairs(particles) do p.Enabled = true end
    local maxLife = 0.4 -- Determine max lifetime from emitters if needed, hardcoded for now
    task.delay(maxLife, function()
        if vfxContainer and vfxContainer.Parent then vfxContainer:Destroy() end
    end)
end


-- // Utility Functions
local loadedAnimations = {}

local function IsReady(abilityName)
    local now = tick()
    local lastTime = lastAbilityTimes[abilityName] or 0
    local cooldown = abilityCooldowns[abilityName] or 0
    return now >= lastTime + cooldown
end

local function StartCooldown(abilityName)
    lastAbilityTimes[abilityName] = tick()
end

local function playSound(soundId, parentPart)
    if not soundId or soundId == "rbxassetid://SOUND_ID_HERE" then return end -- Don't play placeholder
    if not parentPart or not parentPart.Parent then return end
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Parent = parentPart
    sound:Play()
    Debris:AddItem(sound, sound.TimeLength + 0.5)
end

local function loadAnimation(animId)
    if not humanoid then warn("loadAnimation: Humanoid not found."); return nil end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end

    if loadedAnimations[animId] then
        if loadedAnimations[animId].Animator == animator then
             return loadedAnimations[animId]
        else
             loadedAnimations[animId]:Destroy() -- Destroy old track if animator changed
             loadedAnimations[animId] = nil
        end
    end

    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    -- Parent animation to humanoid temporarily for loading (common practice)
    anim.Parent = humanoid
    local track = animator:LoadAnimation(anim)
    anim:Destroy() -- Clean up the animation object after loading

    if track then
        loadedAnimations[animId] = track
    else
        warn("Failed to load animation:", animId)
    end
    return track
end

local function findBall()
    local football = Workspace:FindFirstChild("Football")
    if football then
        local ballPart = (football:FindFirstChild("BallAnims") and football.BallAnims:FindFirstChild("BALL")) or football:FindFirstChild("BALL")
        if ballPart and ballPart:IsA("BasePart") then return ballPart end
        if football:IsA("Model") and football.PrimaryPart then return football.PrimaryPart end
        if football:IsA("BasePart") then return football end
    end
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character then
            local i = p.Character:FindFirstChild("BALL")
            if i and i:IsA("BasePart") then return i end
        end
    end
    return nil
end

local function shakeCamera(intensity, duration)
     if not Camera or not Camera.Parent then print("ShakeCamera: Camera not available"); return end -- Add camera check
    local originalCFrame = Camera.CFrame
    local elapsed = 0
    local heartbeat = RunService.Heartbeat
    local connection = nil

    local function stopShake()
        if connection and connection.Connected then
             if Camera and Camera.Parent then Camera.CFrame = originalCFrame end -- Check Camera before setting CFrame
            connection:Disconnect()
            connection = nil
        end
    end

    connection = heartbeat:Connect(function(dt)
        elapsed = elapsed + dt
        if elapsed < duration then
            local shakeOffset = CFrame.new(
                (math.random()*2-1)*intensity/100,
                (math.random()*2-1)*intensity/100,
                (math.random()*2-1)*intensity/100
            ) * CFrame.Angles(
                math.rad((math.random()*2-1)*intensity*0.1),
                math.rad((math.random()*2-1)*intensity*0.1),
                math.rad((math.random()*2-1)*intensity*0.1)
            )
            if Camera and Camera.Parent then Camera.CFrame = originalCFrame * shakeOffset else stopShake() end
        else
            stopShake()
        end
    end)
    task.delay(duration + 0.1, stopShake)
end


-- // Ability Implementations

--// 1. EGOIST SLICK
local function EgoistSlick()
    if not IsReady("EgoistSlick") then print("Egoist Slick on CD") return end

    if not rootPart or not rootPart.Parent then
         character = player.Character or player.CharacterAdded:Wait()
         rootPart = character and character:WaitForChild("HumanoidRootPart")
         humanoid = character and character:WaitForChild("Humanoid")
         if not rootPart or not humanoid then warn("Egoist Slick: Cannot find player RootPart/Humanoid."); return end
    end

    local targetPlayer = nil
    local closestDist = 15
    local minDist = 5

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Team ~= player.Team and otherPlayer.Character then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHRP then
                local dist = (rootPart.Position - otherHRP.Position).Magnitude
                if dist >= minDist and dist <= closestDist then
                    local ray = Ray.new(rootPart.Position, (otherHRP.Position - rootPart.Position).Unit * dist)
                    local hit, pos = Workspace:FindPartOnRayWithIgnoreList(ray, {character, otherPlayer.Character})
                    if not hit or hit:IsDescendantOf(otherPlayer.Character) then
                        closestDist = dist
                        targetPlayer = otherPlayer
                    end
                end
            end
        end
    end

    if not targetPlayer or not targetPlayer.Character then
        warn("Egoist Slick: No suitable opponent found.")
        return
    end

    StartCooldown("EgoistSlick")
    local targetHRP = targetPlayer.Character.HumanoidRootPart

    local playerToTarget = (targetHRP.Position - rootPart.Position).Unit
    local rightVector = rootPart.CFrame.RightVector
    local dotProduct = playerToTarget:Dot(rightVector)

    local directionVector = targetHRP.CFrame.RightVector
    local offsetDistance = 4
    local teleportPos

    if dotProduct > 0.1 then teleportPos = targetHRP.Position - (directionVector * offsetDistance)
    elseif dotProduct < -0.1 then teleportPos = targetHRP.Position + (directionVector * offsetDistance)
    else teleportPos = targetHRP.Position + (directionVector * offsetDistance)
    end

    teleportPos = Vector3.new(teleportPos.X, targetHRP.Position.Y + 0.5, teleportPos.Z)

    -- Check if VFX function exists before calling
    if VFX and VFX.BestShootingVFX2 then VFX.BestShootingVFX2(rootPart) else warn("BestShootingVFX2 not found in VFX table") end

    rootPart.CFrame = CFrame.lookAt(teleportPos, targetHRP.Position)

    local animTrack = loadAnimation(ANIM_ID_EGOIST_SLICK)
    if animTrack then animTrack:Play(0.1, 1, 1.2); print("Playing Egoist Slick Animation") else warn("Failed to load Egoist Slick animation") end

    playSound(SOUND_ID_EGOIST_SLICK, rootPart)

    task.wait(0.05)
    if SlideRemote then SlideRemote:FireServer(targetPlayer) else warn("SlideRemote is nil, cannot fire.") end

    print("Egoist Slick Used")
end

-- Removed other ability functions

-- // --- UI Setup ---
local abilityButtons = {} -- Store button instances

local function setupAbilityUI()
    local playerGui = player:WaitForChild("PlayerGui")
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn("InGameUI not found.") return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn("Bottom frame not found.") return end
    local bottomAbilities = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilities then warn("Abilities Frame not found!") return end
    local templateButton = bottomAbilities:FindFirstChild("1") or bottomAbilities:FindFirstChildWhichIsA("ImageButton")
     if not templateButton then warn("Template button ('1' or ImageButton) not found in Abilities Frame!") return end


    -- Remove any existing buttons first (Only EgoistSlickButton matters now)
    local egoistSlickData = abilities.EgoistSlick
    if egoistSlickData then
        local oldBtn = bottomAbilities:FindFirstChild(egoistSlickData.ButtonName)
        if oldBtn then
            print("Destroying old button:", egoistSlickData.ButtonName)
            oldBtn:Destroy()
        end
    end
    
     task.wait(0.1) -- Short delay after destroying

    -- Create new button (Only for EgoistSlick)
    local name = "EgoistSlick"
    local data = abilities[name]
    if not data then warn("EgoistSlick data not found in abilities table for UI setup"); return end
    
    local button = nil
    pcall(function() button = templateButton:Clone() end) -- Wrap clone in pcall
    if not button then warn("Failed to clone template button for", name); return end -- Stop if clone failed

    button.Name = data.ButtonName
    button.Parent = bottomAbilities
    button.LayoutOrder = data.LayoutOrder

    local keybindLabel = button:FindFirstChild("Keybind", true)
    local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
    local actualTimerLabel = button:FindFirstChild("ActualTimer", true)

    if keybindLabel and keybindLabel:IsA("TextLabel") then keybindLabel.Text = data.Key.Name else warn("Keybind Label not found for", name) end
    if timerLabel and timerLabel:IsA("TextLabel") then timerLabel.Text = data.TimerText else warn("Timer Label not found for", name) end
    if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = "" end


    local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown")
    if cdVisual then cdVisual:Destroy() end

    local abilityFrame = button:FindFirstChild("Ability") or button
    if abilityFrame then
        local cooldownFrame = Instance.new("Frame")
        cooldownFrame.Name = "Cooldown"
        cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        cooldownFrame.BackgroundTransparency = 0.6
        cooldownFrame.BorderSizePixel = 0
        cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
        cooldownFrame.Position = UDim2.new(0, 0, 1, 0)
        cooldownFrame.AnchorPoint = Vector2.new(0, 1)
        cooldownFrame.ZIndex = (abilityFrame:IsA("GuiObject") and abilityFrame.ZIndex or 1) + 1
        cooldownFrame.Parent = abilityFrame

        local uiCorner = Instance.new("UICorner", cooldownFrame)
        local absSize = abilityFrame:IsA("GuiObject") and abilityFrame.AbsoluteSize or Vector2.new(50,50)
        local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
        uiCorner.CornerRadius = UDim.new(0, radius)

        if abilityFrame:IsA("GuiObject") then
            abilityFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                local newAbsSize = abilityFrame.AbsoluteSize
                local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                uiCorner.CornerRadius = UDim.new(0, newRadius)
            end)
        end
    else
         warn("Could not find 'Ability' frame or base button to parent cooldown visual for", name)
    end

    abilityButtons[name] = button
    print("UI Button Created:", name)

    print("UI Setup Complete")
end

-- // Cooldown Update Loop
RunService.Heartbeat:Connect(function(dt)
    -- Loop now only iterates over EgoistSlick button if setupAbilityUI was successful
    for name, button in pairs(abilityButtons) do
        local buttonExists = pcall(function() return button.Parent end)
        if not buttonExists then
             abilityButtons[name] = nil
             continue
        end

        if button and button.Parent then
            local abilityData = abilities[name]
            if not abilityData then continue end -- Skip if ability data doesn't exist (shouldn't happen here)
            
            local timeLeft = (lastAbilityTimes[name] or 0) + (abilityCooldowns[name] or 0) - tick()
            local abilityFrame = button:FindFirstChild("Ability") or button
            local cooldownFrame = abilityFrame and abilityFrame:FindFirstChild("Cooldown")
            local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)

            if timeLeft > 0 then
                if cooldownFrame then
                    local progress = math.clamp(timeLeft / abilityCooldowns[name], 0, 1)
                    pcall(function() cooldownFrame.Size = UDim2.new(1, 0, progress, 0) end) -- Wrap UI update
                    cooldownFrame.Visible = true
                end
                if timerLabel and timerLabel:IsA("TextLabel") then
                     pcall(function() timerLabel.Text = string.format("%.1fs", timeLeft) end)
                 end
            else
                if cooldownFrame then cooldownFrame.Visible = false end
                if timerLabel and timerLabel:IsA("TextLabel") then
                     local newText = abilityData.TimerText or name -- Use defined TimerText or fallback to name
                     -- Removed VoidGuard specific text update
                     if timerLabel.Text ~= newText then -- Only update if text changed
                        pcall(function() timerLabel.Text = newText end)
                     end
                 end
            end
        end
    end
end)

-- // Style UI Update
task.spawn(function()
    local StyleBG = player:WaitForChild("PlayerGui"):WaitForChild("Style", 15)
    if not StyleBG then warn("Style GUI not found.") return end
    local BG = StyleBG:WaitForChild("BG", 10)
    if not BG then warn("Style BG Frame not found.") return end
    local StyleTxt = BG:FindFirstChild("StyleTxt")
    local Slots = BG:FindFirstChild("Slots")
    local Desc = BG:FindFirstChild("Desc")
    if not (StyleTxt and Slots and Desc) then warn("Style UI elements missing.") return end
    local ScrollingFrame = Slots:FindFirstChildOfClass("ScrollingFrame")
    local Slot1 = ScrollingFrame and ScrollingFrame:FindFirstChild("Slot1")
    local Slot1Text = Slot1 and (Slot1:FindFirstChild("TextLabel") or Slot1:FindFirstChild("Text") or Slot1:FindFirstChildWhichIsA("TextLabel", true))
    if not Slot1Text then warn("Slot 1 Text Label not found.") end

    while task.wait(1) do
        pcall(function()
            if StyleTxt then StyleTxt.Text = STYLE_NAME; StyleTxt.TextColor3 = STYLE_TEXT_COLOR end
            if Slot1Text then Slot1Text.Text = STYLE_NAME; Slot1Text.TextColor3 = STYLE_TEXT_COLOR end
            if Desc then Desc.Text = STYLE_DESCRIPTION; Desc.TextColor3 = STYLE_TEXT_COLOR end
        end)
    end
end)


-- // Character Respawn Handling
player.CharacterAdded:Connect(function(newCharacter)
    print("Character Added Event Fired")
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    loadedAnimations = {}
    -- Removed isVoidGuardActive reset
    -- Reset cooldown only for EgoistSlick
    lastAbilityTimes["EgoistSlick"] = 0
    
    print("Ego Jinpachi Style: Character respawned, variables reset.")
    -- Re-setup UI on respawn might be needed if UI gets destroyed
    -- task.wait(0.5) -- Add a small delay before setting up UI again
    -- setupAbilityUI()
end)

-- // Initial UI Setup
setupAbilityUI()

-- // Connect Ability Activations
local egoistSlickButton = abilityButtons.EgoistSlick
if egoistSlickButton then
    egoistSlickButton.Activated:Connect(EgoistSlick)
    print("Connected EgoistSlick Button Activated")
else
    warn("EgoistSlick button not found in table for Activated connection")
end
-- Removed connections for other abilities


-- // Input Handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

    local key = input.KeyCode

    -- Only check for EgoistSlick key
    local egoistSlickData = abilities.EgoistSlick
    if egoistSlickData and key == egoistSlickData.Key then EgoistSlick() end
    -- Removed checks for other keys

end)

print(STYLE_NAME .. " Style (Egoist Slick Only) Loaded Successfully!")
-- Removed "Let me know when you're ready for Ability 2!"

--[[
    Style Name: EGO JINPANCHI (Concept)
    Ability: VOID GUARD (Range Activation + VFX + Strong Global Lighting) - Standalone Test V63_GlobalLighting
    Creator: Gemini (Modified by Manus)
    Version: Removed local light dimming, increased global darkening effect
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerStats = player:WaitForChild("PlayerStats", 15)

-- // Remote Event Acquisition (Direct Path)
local AbilityRemote = nil
local AbilityUsedRemote = nil
local function findAbilityRemotes() print("Attempting Standard Path to AbilityRemotes...") local p,k,s,a,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil;if p then k=p:FindFirstChild("Knit",5)end;if k then s=k:FindFirstChild("Services",5)end;if s then a=s:FindFirstChild("AbilityService",5)end;if a then r=a:FindFirstChild("RE",5)end;if r then local r1=r:FindFirstChild("Ability",5);local r2=r:FindFirstChild("AbilityUsed",5);if r1 and r1:IsA("RemoteEvent")then print("AbilityRemote FOUND:",r1);AbilityRemote=r1 else warn("Ability Remote not found!")end;if r2 and r2:IsA("RemoteEvent")then print("AbilityUsedRemote FOUND:",r2);AbilityUsedRemote=r2 else warn("AbilityUsed Remote not found!")end;return(AbilityRemote)else warn("AbilityService RE path not found!");return false end end
local foundRemotes = findAbilityRemotes()

-- // Ability Settings
local ABILITY_NAME = "VoidGuard_Range_VFX_GlobalLighting" -- Unique internal name
local ABILITY_KEY = Enum.KeyCode.V
local COOLDOWN_TOGGLE = 0.5
local BUTTON_NAME = "VoidGuardButton"
local TIMER_TEXT_OFF = "Void Guard OFF"
local TIMER_TEXT_ON = "Void Guard ON"
local LAYOUT_ORDER = 4
local ACTIVATION_RANGE = 50
local REMOTE_EVENT_NAME = "PerfectPass"
local REMOTE_EVENT_ARGS = { "ArmSwipe" }
local GLOBAL_LIGHTING_DARKEN_FACTOR = 0.5 -- <<< How much to darken global lighting (0.0 to 1.0, 0.5 = 50% darker), ADJUSTABLE

-- // State Tracking
local isVoidGuardActive = false
local lastToggleTime = 0
local originalGlobalLightingSettings = nil -- Stores {Ambient, OutdoorAmbient, Brightness}

-- // VFX State
local activeVFXParticles = {}

-- // Helper Functions
local function IsToggleReady() local last = lastToggleTime or 0; if typeof(last)~="number" then last=0 end; return tick()-last>=COOLDOWN_TOGGLE end
local function StartToggleCooldown() lastToggleTime=tick() end
local function checkReoStyle() if not playerStats then playerStats=player:WaitForChild("PlayerStats",1)end; local cs=playerStats and playerStats:FindFirstChild("Style"); return cs and cs.Value=="Reo" end

-- // Lighting Management Functions (Global Only)
local function darkenGlobalLighting()
    if originalGlobalLightingSettings == nil then -- Only darken if not already darkened
        print("Darkening global lighting...")
        originalGlobalLightingSettings = {
            Ambient = Lighting.Ambient,
            OutdoorAmbient = Lighting.OutdoorAmbient,
            Brightness = Lighting.Brightness
        }
        local factor = 1.0 - GLOBAL_LIGHTING_DARKEN_FACTOR
        Lighting.Ambient = originalGlobalLightingSettings.Ambient * factor
        Lighting.OutdoorAmbient = originalGlobalLightingSettings.OutdoorAmbient * factor
        Lighting.Brightness = originalGlobalLightingSettings.Brightness * factor
    else
        print("Global lighting already darkened by this script.")
    end
end

local function restoreGlobalLighting()
    if originalGlobalLightingSettings ~= nil then -- Only restore if darkened by this script
        print("Restoring global lighting...")
        Lighting.Ambient = originalGlobalLightingSettings.Ambient
        Lighting.OutdoorAmbient = originalGlobalLightingSettings.OutdoorAmbient
        Lighting.Brightness = originalGlobalLightingSettings.Brightness
        originalGlobalLightingSettings = nil -- Reset state
    else
        print("Global lighting was not darkened by this script or already restored.")
    end
end

-- // VFX Management Functions (Brightness/Size adjusted)
local function destroyVFXParticles()
    print("Destroying existing VFX particles...")
    for _, particle in ipairs(activeVFXParticles) do
        if particle and particle.Parent then
            particle:Destroy()
        end
    end
    activeVFXParticles = {}
end

local function createVFXParticles(parentPart)
    destroyVFXParticles() -- Clear any old ones first
    if not parentPart then
        warn("Cannot create VFX, parentPart is nil")
        return {}
    end
    print("Creating VFX particles...")
    local newParticles = {}

    -- First effect particles (user code, modified brightness/size)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.400000, 0.500000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(20.000000, 20.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(0.199108, 0.265432), NumberSequenceKeypoint.new(0.399703, 0.000000), NumberSequenceKeypoint.new(0.602526, 0.000000), NumberSequenceKeypoint.new(0.842709, 0.438144), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 20
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(60.000000, 60.000000)
        particle.Brightness = 8.199999928474426 -- Increased from 1.64 * 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 36.943304), NumberSequenceKeypoint.new(0.501036, 76.581825), NumberSequenceKeypoint.new(0.701036, 87.380341), NumberSequenceKeypoint.new(1.000000, 93.520672)}) -- Increased size by 30
        particle.Enabled = false -- Start disabled
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(500.000000, 500.000000)
        particle.ZOffset = 0.30321580171585083
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 9
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://9324968005"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0.550000011920929
        particle.Parent = parentPart
        table.insert(newParticles, particle)
    end)

    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.700000, 0.700000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(-2.000000, 2.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.180412), NumberSequenceKeypoint.new(0.096441, 0.711340), NumberSequenceKeypoint.new(0.258324, 0.922680), NumberSequenceKeypoint.new(0.654420, 0.979381), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1.000000, Color3.new(0, 0, 0))})
        particle.Drag = 0.5
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = -2
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.500000, 0.064516), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.050000, 0.100000)
        particle.Brightness = 5.975000262260437 -- Increased from 1.195 * 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 32.875833), NumberSequenceKeypoint.new(0.209036, 51.108021), NumberSequenceKeypoint.new(0.457036, 56.402044), NumberSequenceKeypoint.new(0.735036, 54.817921), NumberSequenceKeypoint.new(1.000000, 50.769608)}) -- Increased size by 30
        particle.Enabled = false -- Start disabled
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0.10000000149011612
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 80
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://9164980520"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0.5
        particle.Parent = parentPart
        table.insert(newParticles, particle)
    end)

    -- Second effect particles (user code, modified brightness/size)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Surface
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.500000, 0.500000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(20.000000, 20.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(0.298000, 0.900000), NumberSequenceKeypoint.new(0.701000, 0.900000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(0.000000, 0.000000, 0.000000))})
        particle.Drag = 4
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 20
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.047110, 0.047110)
        particle.Brightness = 5.0 -- Increased from 1 * 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 45.626830), NumberSequenceKeypoint.new(1.000000, 45.626830)}) -- Increased size by 30
        particle.Enabled = false -- Start disabled
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(400.000000, 400.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 40
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://9256706570"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 1
        particle.Parent = parentPart
        table.insert(newParticles, particle)
    end)

    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(1.000000, 1.000000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(360.000000, 360.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(1.000000, 0.431250)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1.000000, Color3.new(0, 0, 0))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.002173, 0.002173)
        particle.Brightness = 5.0 -- Increased from 1 * 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 30.000000), NumberSequenceKeypoint.new(0.590816, 41.409604), NumberSequenceKeypoint.new(1.000000, 51.189270)}) -- Increased size by 30
        particle.Enabled = false -- Start disabled
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(-400.000000, -400.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 23
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://7168841973"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Right
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0.3499999940395355
        particle.Parent = parentPart
        table.insert(newParticles, particle)
    end)

    print("Finished creating", #newParticles, "VFX particles.")
    return newParticles
end

-- // Ability Function: VOID GUARD TOGGLE
local function VoidGuardToggle()
    if not IsToggleReady() then print(ABILITY_NAME.." Toggle on CD"); return end

    if isVoidGuardActive then
        -- Currently ON -> Turn OFF
        isVoidGuardActive = false
        print(ABILITY_NAME .. " Toggled OFF")
        -- Disable VFX
        print("Disabling VFX...")
        for _, particle in ipairs(activeVFXParticles) do
            if particle and particle.Parent then
                particle.Enabled = false
            end
        end
        -- Restore Lighting (Global Only)
        restoreGlobalLighting()
        StartToggleCooldown()
    else
        -- Currently OFF -> Try to Turn ON
        if checkReoStyle() then
            isVoidGuardActive = true
            print(ABILITY_NAME .. " Toggled ON (Style: Reo)")
            -- Enable VFX
            print("Enabling VFX...")
            if #activeVFXParticles == 0 then -- Safety check: Recreate if missing
                 warn("VFX particles missing, attempting to recreate...")
                 rootPart = character and character:FindFirstChild("HumanoidRootPart")
                 if rootPart then
                     activeVFXParticles = createVFXParticles(rootPart)
                 else
                     warn("Cannot recreate VFX, HumanoidRootPart not found.")
                 end
            end
            for _, particle in ipairs(activeVFXParticles) do
                if particle and particle.Parent then
                    particle.Enabled = true
                end
            end
            -- Apply Lighting Effects (Global Only)
            darkenGlobalLighting()
            StartToggleCooldown()
        else
            -- Style is not Reo, show notification and DO NOT toggle ON
            pcall(StarterGui.SetCore, StarterGui, "SendNotification", { Title = "FOR HEADER- SWITCH TO REO", Text = "SRY THIS ABILITY IS ONLY FOR REO", Duration = 5 })
            print(ABILITY_NAME .. " Activation Blocked (Style Not Reo)")
            StartToggleCooldown() -- Still apply toggle cooldown
        end
    end
end

-- // Range Activation Logic (Runs in Heartbeat when active) - SFX Removed
local function CheckAndTriggerRangeAbility()
    if not isVoidGuardActive then return end
    if not AbilityRemote then return end

    character = player.Character; if not character then return end
    rootPart = character:FindFirstChild("HumanoidRootPart"); if not rootPart then return end

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Team ~= player.Team and otherPlayer.Character then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHRP then
                local distance = (rootPart.Position - otherHRP.Position).Magnitude
                if distance <= ACTIVATION_RANGE then
                    -- Player is in range, fire the remote event
                    -- print("Void Guard: Opponent", otherPlayer.Name, "in range ("..tostring(math.floor(distance)).." studs). Firing", REMOTE_EVENT_NAME)
                    local argsToSend = table.clone(REMOTE_EVENT_ARGS)
                    table.insert(argsToSend, otherPlayer.Character)
                    local success, err = pcall(AbilityRemote.FireServer, AbilityRemote, REMOTE_EVENT_NAME, argsToSend)
                    if not success then warn("Error firing AbilityRemote:", err) end
                end
            end
        end
    end
end
RunService.Heartbeat:Connect(CheckAndTriggerRangeAbility)


-- // --- UI Setup --- (UNCHANGED FROM ORIGINAL)
local voidGuardButton = nil
local function setupSingleButtonUI()
    local playerGui=player:WaitForChild("PlayerGui");local inGameUI=playerGui:WaitForChild("InGameUI",15);if not inGameUI then warn("No InGameUI");return end;local bottom=inGameUI:WaitForChild("Bottom",10);if not bottom then warn("No Bottom");return end;local bottomAbilities=bottom:WaitForChild("Abilities",10);if not bottomAbilities then warn("No Abilities Frame");return end;local templateButton=bottomAbilities:WaitForChild("1", 5)or bottomAbilities:FindFirstChildWhichIsA("ImageButton");if not templateButton then warn("No Template Button");return end
    local oldBtn=bottomAbilities:FindFirstChild(BUTTON_NAME);if oldBtn then oldBtn:Destroy();task.wait(0.1)end;local b=nil;local s=pcall(function()b=templateButton:Clone()end);if not s or not b then warn("Clone fail");return end;b.Name=BUTTON_NAME;b.Parent=bottomAbilities;b.LayoutOrder=LAYOUT_ORDER;local kL=b:WaitForChild("Keybind",2)or b:FindFirstChildWhichIsA("TextLabel",true);local tL=b:WaitForChild("Timer",2)or b:FindFirstChild("AbilityName",true)or b:FindFirstChildWhichIsA("TextLabel",true);local aTL=b:FindFirstChild("ActualTimer",true);if kL and kL:IsA("TextLabel")then pcall(function()kL.Text=ABILITY_KEY.Name end)else warn("KeybindLbl Missing")end;if tL and tL:IsA("TextLabel")then pcall(function()tL.Text=TIMER_TEXT_OFF end)else warn("TimerLbl Missing")end;if aTL and aTL:IsA("TextLabel")then pcall(function()aTL.Text=""end)end;local cV=b:FindFirstChild("Cooldown")or b:FindFirstChild("cooldown");if cV then cV:Destroy()end;local aF=b:FindFirstChild("Ability")or b;if aF and aF:IsA("GuiObject")then local cF=Instance.new("Frame");cF.Name="Cooldown";cF.BackgroundColor3=Color3.fromRGB(0,0,0);cF.BackgroundTransparency=0.6;cF.BorderSizePixel=0;cF.Size=UDim2.new(1,0,1,0);cF.Position=UDim2.new(0,0,1,0);cF.AnchorPoint=Vector2.new(0,1);cF.ZIndex=(aF.ZIndex or 1)+1;cF.Parent=aF;local uC=Instance.new("UICorner",cF);local aS=aF.AbsoluteSize;local r=math.max(1,math.min(aS.X,aS.Y)*0.15);uC.CornerRadius=UDim.new(0,r);aF:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()pcall(function()if not uC or not uC.Parent then return end;local nS=aF.AbsoluteSize;local nR=math.max(1,math.min(nS.X,nS.Y)*0.15);uC.CornerRadius=UDim.new(0,nR)end)end)else warn("Ability Frame missing")end;voidGuardButton=b;print("UI Button Created:",ABILITY_NAME);voidGuardButton.Activated:Connect(VoidGuardToggle);print("Connected Activated")
end

-- // --- Cooldown/State Update --- (UNCHANGED FROM ORIGINAL)
RunService.Heartbeat:Connect(function(dt)
    if voidGuardButton and voidGuardButton.Parent then
        local tl=(lastToggleTime or 0)+COOLDOWN_TOGGLE-tick()
        local abilityFrame=voidGuardButton:FindFirstChild("Ability")or voidGuardButton
        local cooldownFrame=abilityFrame and abilityFrame:FindFirstChild("Cooldown")
        local timerLabel=voidGuardButton:FindFirstChild("Timer")or voidGuardButton:FindFirstChild("AbilityName",true)

        local desiredText = isVoidGuardActive and TIMER_TEXT_ON or TIMER_TEXT_OFF
        if timerLabel and timerLabel:IsA("TextLabel") then
             local success, currentText = pcall(function() return timerLabel.Text end)
             if success and currentText ~= desiredText then
                 pcall(function() if timerLabel and timerLabel.Parent then timerLabel.Text = desiredText end end)
             end
        end

        if tl > 0 then
            if cooldownFrame then local p=math.clamp(tl/COOLDOWN_TOGGLE,0,1);pcall(function()if cooldownFrame and cooldownFrame.Parent then cooldownFrame.Size=UDim2.new(1,0,p,0); cooldownFrame.Visible=true end end) end
        else
            if cooldownFrame then pcall(function() if cooldownFrame and cooldownFrame.Parent then cooldownFrame.Visible=false end end) end
        end
    end
end)

-- // --- Input Handling --- (UNCHANGED FROM ORIGINAL)
UserInputService.InputBegan:Connect(function(i,gp)if gp then return end;if i.UserInputType==Enum.UserInputType.Keyboard and i.KeyCode==ABILITY_KEY then pcall(VoidGuardToggle)end end)

-- // --- Respawn Handling ---
player.CharacterAdded:Connect(function(nc)
    print("Character Added")
    character=nc
    humanoid=character:WaitForChild("Humanoid")
    rootPart=character:WaitForChild("HumanoidRootPart")
    playerValues=character:WaitForChild("Values",10)
    playerStats=player:WaitForChild("PlayerStats", 15)
    isVoidGuardActive=false -- Reset state
    lastToggleTime=0
    restoreGlobalLighting() -- Ensure lighting is restored on respawn
    -- Destroy old VFX and create new ones parented to the new rootPart
    activeVFXParticles = createVFXParticles(rootPart)
    print("Void Guard Strong Global Lighting: Respawned.")
end)

-- // --- Initial Setup ---
if AbilityRemote then
    -- Create initial VFX particles
    activeVFXParticles = createVFXParticles(rootPart)
    setupSingleButtonUI()
    print(ABILITY_NAME.." Script Loaded!")
else
    warn(ABILITY_NAME.." Script FAILED TO LOAD due to missing AbilityRemote.")
end

-- // --- Cleanup ---
Players.PlayerRemoving:Connect(function(lp)
    if lp==player then
        print("Player removing, cleaning up VFX and Lighting...")
        destroyVFXParticles()
        restoreGlobalLighting() -- Ensure lighting is restored when player leaves
        -- Clean up Heartbeat connections if needed
    end
end)

-- Chaos Impact V31 (Final Strike Fix) - Based on V30, addressing final shot failure.
-- Addresses: User-defined adjustability, v27 freeze stability, wider aim, placeholders, and final strike ball drop.

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local GuiService = game:GetService("GuiService")
local TweenService = game:GetService("TweenService")

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10)

-- // Remote Event Acquisition
local ShootRemote = nil
local function findShootRemoteStandardPath()
    print("CI: Attempting Standard Path for ShootRemote...")
    local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil;
    if p then k=p:FindFirstChild("Knit",5)end;
    if k then s=k:FindFirstChild("Services",5)end;
    if s then b=s:FindFirstChild("BallService",5)end;
    if b then r=b:FindFirstChild("RE",5)end;
    local remote=r and r:FindFirstChild("Shoot",5);
    if remote and remote:IsA("RemoteEvent")then
        print("CI: ShootRemote FOUND via Standard Path:",remote);
        return remote
    else
        warn("CI: ShootRemote NOT found via Standard Path!");
        return nil
    end
end
ShootRemote = findShootRemoteStandardPath()

-- // --- CONFIGURABLE VALUES (V31) --- //
local ABILITY_KEY_CI = Enum.KeyCode.F
local COOLDOWN_CI = 5 -- Cooldown in seconds

-- VFX Parameters (NEW - For thebestkickvfx)
local VFX_ACTIVATION_DELAY = 1.0 -- Delay before Kick VFX plays after ability activation (User Request: ~1s)
local VFX_DURATION = 4.5 -- How long the Kick VFX lasts (User Request: 4-5s)

-- Levitation
local LEVITATE_HEIGHT = 15
local LEVITATE_DURATION = 0.5
local LEVITATE_AIR_TIME = 1.0 -- How long player stays at peak height *before* shot sequence starts

-- Aiming
local AIM_VISUALIZER_DURATION = 5
local AIM_VISUALIZER_TRANSPARENCY = 0.7
local AIM_VISUALIZER_RADIUS = 200 -- Increased for wider aim leniency (was 75)
local DEFAULT_BALL_MASS = 1.5

-- Shot Sequence Delays/Pauses
local SHOT_START_DELAY = 0.1 -- Delay after LEVITATE_AIR_TIME before first shot
local SHOT_POST_INITIAL_FIRE_WAIT = 0.4 -- Wait time after initial FireServer before ball control
local SHOT_POST_STAGE1_FREEZE_DURATION = 0.7 -- Duration for the first freeze (after initial stop)
local SHOT_STAGE2_PAUSE_FREEZE_DURATION = 0.7 -- Duration for the second freeze (after sideways movement)

-- Shot Sequence Stages
local INITIAL_SHOT_POWER = 15 -- Power for the initial ShootRemote:FireServer()
local SHOT_STAGE1_SPEED = 100 -- Speed of the ball towards (Goal - StopDistance)
local SHOT_STAGE1_STOP_DISTANCE = 100 -- Distance from goal where the ball makes its first stop
local SHOT_STAGE2_SIDE_SPEED = 80 -- Speed of the sideways strike
local SHOT_STAGE2_DURATION = 0.4 -- Duration of the sideways movement
local SHOT_STAGE3_FINAL_SPEED = 400 -- Speed of the final strike towards goal
local SHOT_STAGE3_DURATION = 2.0 -- Max duration for the final strike BodyVelocity

-- BodyPosition Freeze Parameters (V27 Style - for stability)
local BODYPOS_P_GAIN = 50000 -- Proportional gain (stiffness) for BodyPosition
local BODYPOS_D_GAIN = 1250  -- Derivative gain (damping) for BodyPosition
local BODYPOS_MAXFORCE_XZ = 40000 -- MaxForce on X and Z axes for BodyPosition (Y is calculated dynamically)

-- Placeholder IDs (User to replace these with actual asset IDs)
local ANIMATION_ID_LEVITATE_PLACEHOLDER = "rbxassetid://YOUR_LEVITATE_ANIM_ID"
local ANIMATION_ID_SHOT_MAIN_PLACEHOLDER = "rbxassetid://YOUR_MAIN_SHOT_ANIM_ID"
local ANIMATION_ID_SHOT_SIDE_PLACEHOLDER = "rbxassetid://YOUR_SIDE_SHOT_ANIM_ID"
local ANIMATION_ID_SHOT_FINAL_PLACEHOLDER = "rbxassetid://YOUR_FINAL_SHOT_ANIM_ID"

local SOUND_ID_ACTIVATION_PLACEHOLDER = "rbxassetid://YOUR_ACTIVATION_SOUND_ID"
local SOUND_ID_LEVITATE_PLACEHOLDER = "rbxassetid://YOUR_LEVITATE_SOUND_ID"
local SOUND_ID_SHOT_INITIAL_PLACEHOLDER = "rbxassetid://YOUR_INITIAL_SHOT_SOUND_ID"
local SOUND_ID_SHOT_SIDE_PLACEHOLDER = "rbxassetid://YOUR_SIDE_SHOT_SOUND_ID"
local SOUND_ID_SHOT_FINAL_PLACEHOLDER = "rbxassetid://YOUR_FINAL_SHOT_SOUND_ID"
local SOUND_ID_BALL_FREEZE_PLACEHOLDER = "rbxassetid://YOUR_BALL_FREEZE_SOUND_ID"

-- Placeholder Functions for VFX (Original V31 Placeholders - Kept for reference)
local VFX_BALL_BLACK_FIRE_PLACEHOLDER = function(ballInstance, actionType) 
    print("VFX_BALL_BLACK_FIRE_PLACEHOLDER called for: " .. tostring(ballInstance) .. " Action: " .. tostring(actionType))
end

local VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER = function(playerRootPartInstance) 
    print("VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER called for: " .. tostring(playerRootPartInstance))
end

-- // --- END CONFIGURABLE VALUES --- //

local ABILITY_NAME_CI = "ChaosImpact"
local BUTTON_NAME_CI = "ChaosImpactButton"
local TIMER_TEXT_CI = "Chaos Impact"
local LAYOUT_ORDER_CI = 5
local lastChaosImpactTime = 0
local chaosImpactButton = nil
local isAbilityActive_CI = false

local function IsReady_CI() return tick() - lastChaosImpactTime >= COOLDOWN_CI end
local function StartCooldown_CI()
    lastChaosImpactTime = tick()
    if chaosImpactButton then
        local cooldownFrame = chaosImpactButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local tweenInfo = TweenInfo.new(COOLDOWN_CI, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(uiGradient, tweenInfo, {Offset = Vector2.new(0, 1)})
                uiGradient.Offset = Vector2.new(0, 0); tween:Play()
            end
        end
    end
end

local homeGoalPos=Vector3.new(325,15,-49);
local awayGoalPos=Vector3.new(-247,15,-50);

local function getOpponentGoalPos()
    local t = player.Team
    if not t then return nil end
    return t.Name == "Home" and awayGoalPos or (t.Name == "Away" and homeGoalPos or nil)
end

local function findBall(retries, delay)
    retries = retries or 3; delay = delay or 0.1; local ball = nil
    for i = 1, retries do
        local f = Workspace:FindFirstChild("Football")
        if f then
            local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
            if b and b:IsA("BasePart") then ball = b; break
            elseif f:IsA("Model") and f.PrimaryPart then ball = f.PrimaryPart; break
            elseif f:IsA("BasePart") then ball = f; break end
        end
        if i < retries then task.wait(delay) end
    end
    return ball
end

local function calculatePartMass(part)
    local mass = DEFAULT_BALL_MASS
    if part and part:IsA("BasePart") then
        local s, m = pcall(function() return part:GetMass() end)
        if s and typeof(m) == "number" and m > 0 then mass = m
        else s, m = pcall(function() return part.AssemblyMass end)
            if s and typeof(m) == "number" and m > 0 then mass = m end
        end
    end
    return mass
end

local function calculateModelMass(model)
    local totalMass = 0
    if model and model:IsA("Model") then
        for _, p in ipairs(model:GetDescendants()) do if p:IsA("BasePart") then totalMass = totalMass + calculatePartMass(p) end end
    end
    return totalMass <= 0 and 10 or totalMass
end

local function cleanupAllMovers(target)
    if not target or not target.Parent then return end
    for _, mover in ipairs(target:GetChildren()) do
        if mover:IsA("BodyMover") then
            print("CI Cleanup (All): Destroying mover:", mover:GetFullName())
            mover:Destroy()
        end
    end
end

local function applyBodyVelocity(target, velocity, duration, maxForce)
    if not target or not target.Parent then return nil end
    cleanupAllMovers(target)
    local bv = Instance.new("BodyVelocity"); bv.Name = "ChaosImpactMover_V31"
    bv.MaxForce = maxForce or Vector3.new(math.huge, math.huge, math.huge); bv.Velocity = velocity
    bv.Parent = target; if duration and duration > 0 then Debris:AddItem(bv, duration) end
    return bv
end

local function applyBodyPositionFreeze(ball, targetPosition, duration)
    if not ball or not ball.Parent then warn("CI Freeze (V31): Ball not found for BodyPosition freeze."); return end
    print("CI Freeze (V31): Attempting BodyPosition freeze. Duration: " .. duration .. " at " .. tostring(targetPosition))
    cleanupAllMovers(ball); RunService.Heartbeat:Wait()
    local originalAnchored = ball.Anchored
    ball.Anchored = true; RunService.Heartbeat:Wait()
    ball.CFrame = CFrame.new(targetPosition)
    ball.AssemblyLinearVelocity = Vector3.zero; ball.AssemblyAngularVelocity = Vector3.zero
    ball.Anchored = originalAnchored; RunService.Heartbeat:Wait()
    ball.AssemblyLinearVelocity = Vector3.zero; ball.AssemblyAngularVelocity = Vector3.zero; RunService.Heartbeat:Wait()
    local bp = Instance.new("BodyPosition"); bp.Name = "ChaosImpactBodyPositionFreeze_V31"
    local ballMass = calculatePartMass(ball); if ballMass <= 0 then ballMass = DEFAULT_BALL_MASS end
    local yMaxForce = Workspace.Gravity * ballMass * 1.2 + 500 
    bp.MaxForce = Vector3.new(BODYPOS_MAXFORCE_XZ, yMaxForce, BODYPOS_MAXFORCE_XZ)
    bp.P = BODYPOS_P_GAIN; bp.D = BODYPOS_D_GAIN; bp.Position = targetPosition
    bp.Parent = ball
    print("CI Freeze (V31): Applied BodyPosition. P:"..bp.P..", D:"..bp.D..", MaxForce:"..tostring(bp.MaxForce))
    Debris:AddItem(bp, duration)
end

local function showAimVisualizerSphere(position)
    if not position then return end
    local existingVis = Workspace:FindFirstChild("ChaosImpactAimVisContainer"); if existingVis then existingVis:Destroy() end
    local visContainer = Instance.new("Model", Workspace); visContainer.Name = "ChaosImpactAimVisContainer"
    local sphere = Instance.new("Part", visContainer); sphere.Name = "ChaosImpactAimVisSphere"; sphere.Shape = Enum.PartType.Ball
    sphere.Size = Vector3.new(AIM_VISUALIZER_RADIUS*2, AIM_VISUALIZER_RADIUS*2, AIM_VISUALIZER_RADIUS*2); sphere.Position = position
    sphere.Color = Color3.new(0,0,0); sphere.Transparency = AIM_VISUALIZER_TRANSPARENCY; sphere.Anchored = true; sphere.CanCollide = false
    local billboardGui = Instance.new("BillboardGui", sphere); billboardGui.Name = "AimTextGui"; billboardGui.Adornee = sphere
    billboardGui.Size = UDim2.new(75,0,30,0); billboardGui.StudsOffset = Vector3.new(0, AIM_VISUALIZER_RADIUS + 10, 0)
    local textLabel = Instance.new("TextLabel", billboardGui); textLabel.Name = "AimTextLabel"; textLabel.BackgroundTransparency=1
    textLabel.Size=UDim2.new(1,0,1,0); textLabel.Font=Enum.Font.SourceSansBold; textLabel.Text="AIM NEAR GOAL"; textLabel.TextColor3=Color3.new(1,1,1)
    textLabel.TextScaled=true; textLabel.TextStrokeColor3=Color3.new(0,0,0); textLabel.TextStrokeTransparency=0
    Debris:AddItem(visContainer, AIM_VISUALIZER_DURATION)
end

local function isAimingInRadius(goalPosition)
    if not goalPosition or not Camera or not Camera.Parent then return false end
    local camPos, camLook = Camera.CFrame.Position, Camera.CFrame.LookVector
    local vecToGoal = goalPosition - camPos; local pL = vecToGoal:Dot(camLook)
    if pL < 0 then return false end
    return (goalPosition - (camPos + camLook * pL)).Magnitude <= AIM_VISUALIZER_RADIUS
end

local function playBestKickVFX(character, duration)
    if not character or not character.Parent then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
         warn("Player HRP not found for BEST KICK VFX.")
         return
    end

    print(ABILITY_NAME_CI .. ": Playing Best Kick VFX for duration:", duration)

    -- Attach to player HRP
    local effectTargetPart = humanoidRootPart

    local vfxContainer = Instance.new("Attachment")
    vfxContainer.Name = "BestKickVFX_BW_ColorOnly"
    vfxContainer.Parent = effectTargetPart

    local particles = {}

    -- Emitter 1 (Original Red Streaks -> White Streaks)
    do
        local particle = Instance.new("ParticleEmitter")
        local parent = vfxContainer
        -- *** Color Change Only ***
        particle.Color = ColorSequence.new(Color3.new(1, 1, 1)) -- White
        particle.LightEmission = 0.8 -- Adjusted for white
        particle.Brightness = 10 -- Adjusted for white

        -- --- Original Properties ---
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(30.000000, 30.000000)
        particle.Lifetime = NumberRange.new(0.200000, 0.350000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(360.000000, 360.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityParallel
        particle.Drag = 10
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.226704, 1.425000), NumberSequenceKeypoint.new(1.000000, 1.650000)})
        particle.Speed = NumberRange.new(400.000000, 600.000000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.172660, 7.764939), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(90.000000, 90.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://13386858482"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Parent = parent
        table.insert(particles, particle)
    end

    -- Emitter 2 (Original Red/Dark Swirl -> Black Swirl)
    do
        local particle = Instance.new("ParticleEmitter")
        local parent = vfxContainer
        -- *** Color Change Only ***
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0)) -- Black
        particle.LightEmission = 0 -- No emission for black
        particle.Brightness = 0 -- No brightness for black

        -- --- Original Properties ---
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.Lifetime = NumberRange.new(0.250000, 0.350000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
        particle.SpreadAngle = Vector2.new(50.000000, 50.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 50
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.100000, 0.100000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 18.659960), NumberSequenceKeypoint.new(0.168660, 43.199478), NumberSequenceKeypoint.new(1.000000, 51.387165)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://13395479051"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Parent = parent
        table.insert(particles, particle)
    end

    -- Emitter 3 (Original Red Swirl 2 -> Black Wisps)
    do
        local particle = Instance.new("ParticleEmitter")
        local parent = vfxContainer
         -- *** Color Change Only ***
        particle.Color = ColorSequence.new(Color3.new(0.1, 0.1, 0.1)) -- Dark Gray
        particle.LightEmission = 0
        particle.Brightness = 0.1

         -- --- Original Properties ---
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.Lifetime = NumberRange.new(0.150000, 0.350000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
        particle.SpreadAngle = Vector2.new(5.000000, 5.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 5
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.100000, 0.100000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 18.659960), NumberSequenceKeypoint.new(0.168660, 43.199478), NumberSequenceKeypoint.new(1.000000, 51.387165)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://13395481373"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Parent = parent
        table.insert(particles, particle)
    end

    -- Emitter 4 (Flash -> White Flash)
    do
        local particle = Instance.new("ParticleEmitter")
        local parent = vfxContainer
         -- *** Color Change Only ***
        particle.Color = ColorSequence.new(Color3.new(1, 1, 1)) -- White
        particle.LightEmission = 1
        particle.Brightness = 10

         -- --- Original Properties ---
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.Lifetime = NumberRange.new(0.050000, 0.050000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(360.000000, 360.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(0.301370, 0.475000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Drag = 5
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.000000, 0.000000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 13.051071), NumberSequenceKeypoint.new(1.000000, 101.363541)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 3
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 32
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 0.000000)
        particle.ShapePartial = 0.3499999940395355
        particle.Texture = "rbxassetid://11503727043"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Parent = parent
        table.insert(particles, particle)
    end

    -- Emitter 5 (Original Red Swirl 3 -> Alternating B&W)
    do
        local particle = Instance.new("ParticleEmitter")
        local parent = vfxContainer
         -- *** Color Change Only ***
        particle.Color = ColorSequence.new({ -- Alternating
            ColorSequenceKeypoint.new(0.0, Color3.new(0, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.new(1, 1, 1)),
            ColorSequenceKeypoint.new(1.0, Color3.new(0, 0, 0))
        })
        particle.LightEmission = 0.5 -- Moderate emission
        particle.Brightness = 4 -- Moderate brightness

         -- --- Original Properties ---
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.Lifetime = NumberRange.new(0.250000, 0.350000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
        particle.SpreadAngle = Vector2.new(50.000000, 50.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 50
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.100000, 0.100000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 18.659960), NumberSequenceKeypoint.new(0.168660, 43.199478), NumberSequenceKeypoint.new(1.000000, 51.387165)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://13395479051"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Parent = parent
        table.insert(particles, particle)
    end

    -- Enable particles
    for _, particle in ipairs(particles) do
        particle.Enabled = true
    end

    -- Cleanup function (Adjusted to use provided duration)
    local function cleanupVFX()
         if vfxContainer and vfxContainer.Parent then
             for _, particle in ipairs(particles) do
                 if particle and particle.Parent then
                    particle.Enabled = false
                 end
             end
             Debris:AddItem(vfxContainer, 1.5) -- Add extra time for particles to fade
        end
    end

    -- Trigger cleanup based on the *provided* duration parameter
    task.delay(duration, cleanupVFX)
end

local function ChaosImpact()
    if isAbilityActive_CI then print("CI: Ability already active."); return end
    if character then cleanupAllMovers(rootPart) end
    local bfc = findBall(1,0); if bfc then cleanupAllMovers(bfc) end
    task.wait(0.05)
    if not IsReady_CI() then print("CI: Ability on cooldown."); return end
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid"); rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10)
    if not (humanoid and rootPart and playerValues) then print("CI: Character components missing."); return end
    local hbv = playerValues:FindFirstChild("HasBall"); if not hbv or not hbv.Value then print("CI: Player does not have ball."); return end
    if not ShootRemote then ShootRemote = findShootRemoteStandardPath(); if not ShootRemote then print("CI: ShootRemote missing!"); return end end
    local goalPosition = getOpponentGoalPos(); if not goalPosition then print("CI: Opponent goal not found."); return end
    if not isAimingInRadius(goalPosition) then print("CI: Aim check failed. Showing visualizer."); showAimVisualizerSphere(goalPosition); return end

    isAbilityActive_CI = true; StartCooldown_CI()
    print(ABILITY_NAME_CI .. " Activated (V31 - Final Strike Fix)")

    task.spawn(function()
        local currentCharacter, currentRootPart = character, rootPart
        local success = false
        local cleanupGuard = Instance.new("BoolValue", currentCharacter); cleanupGuard.Name = "ChaosImpactCleanupGuard_V31"

        local function performCleanupAndReset()
            if not cleanupGuard or not cleanupGuard.Parent then return end; cleanupGuard:Destroy()
            if currentRootPart and currentRootPart.Parent then cleanupAllMovers(currentRootPart) end
            local ball = findBall(1,0); if ball then cleanupAllMovers(ball) end
            isAbilityActive_CI = false
            print("CI: Ability finished and cleaned up.")
        end

        local pcallSuccess, pcallResult = pcall(function()
            local charMass = calculateModelMass(currentCharacter)
            VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER(currentRootPart)
            applyBodyVelocity(currentRootPart, Vector3.new(0, LEVITATE_HEIGHT / LEVITATE_DURATION, 0), LEVITATE_DURATION, Vector3.new(0, charMass*Workspace.Gravity*1.5, 0))
            task.wait(LEVITATE_DURATION); if not cleanupGuard.Parent then return end
            cleanupAllMovers(currentRootPart)
            local totalShotDur =
                SHOT_START_DELAY
                + SHOT_POST_INITIAL_FIRE_WAIT
                + ((getOpponentGoalPos() - currentRootPart.Position).Magnitude - SHOT_STAGE1_STOP_DISTANCE)
                    / SHOT_STAGE1_SPEED
                + SHOT_POST_STAGE1_FREEZE_DURATION
                + SHOT_STAGE2_DURATION
                + SHOT_STAGE2_PAUSE_FREEZE_DURATION
                + SHOT_STAGE3_DURATION

            local airTimeBV = applyBodyVelocity(currentRootPart, Vector3.zero, LEVITATE_AIR_TIME + totalShotDur + 0.2, Vector3.new(0,charMass*Workspace.Gravity,0))
            task.wait(LEVITATE_AIR_TIME); if not cleanupGuard.Parent then return end
            task.wait(SHOT_START_DELAY); if not cleanupGuard.Parent then return end

            local sOk, sErr = pcall(ShootRemote.FireServer, ShootRemote, INITIAL_SHOT_POWER)
            if not sOk then warn("CI: ShootRemote Fail:", sErr); performCleanupAndReset(); return end
            task.wait(SHOT_POST_INITIAL_FIRE_WAIT); if not cleanupGuard.Parent then return end

            local ball = findBall(3, 0.1); if not ball then print("CI: Ball not found after initial shot."); performCleanupAndReset(); return end
            VFX_BALL_BLACK_FIRE_PLACEHOLDER(ball, "InitialShot")
            local cgp = getOpponentGoalPos(); if not cgp then print("CI: Opponent goal not found for stage 1."); performCleanupAndReset(); return end
            local vtg = cgp - ball.Position; local dtg = vtg.Magnitude
            local s1d = dtg - SHOT_STAGE1_STOP_DISTANCE; 
            if s1d <= 0 then print("CI: Ball already past stop distance for stage 1."); performCleanupAndReset(); return end
            local s1dur = s1d / SHOT_STAGE1_SPEED
            applyBodyVelocity(ball, vtg.Unit * SHOT_STAGE1_SPEED, s1dur + 0.1)
            task.wait(s1dur); if not cleanupGuard.Parent then return end
            local freezePosStage1 = ball.Position 
            applyBodyPositionFreeze(ball, freezePosStage1, SHOT_POST_STAGE1_FREEZE_DURATION + 0.05)
            task.wait(SHOT_POST_STAGE1_FREEZE_DURATION); if not cleanupGuard.Parent then return end
            cleanupAllMovers(ball); RunService.Heartbeat:Wait()

            ball = findBall(1,0); if not ball then print("CI: Ball not found for stage 2."); performCleanupAndReset(); return end
            local sideDir = currentRootPart.CFrame.RightVector
            applyBodyVelocity(ball, sideDir * SHOT_STAGE2_SIDE_SPEED, SHOT_STAGE2_DURATION + 0.1)
            task.wait(SHOT_STAGE2_DURATION); if not cleanupGuard.Parent then return end
            local freezePosStage2 = ball.Position 
            applyBodyPositionFreeze(ball, freezePosStage2, SHOT_STAGE2_PAUSE_FREEZE_DURATION + 0.05)
            task.wait(SHOT_STAGE2_PAUSE_FREEZE_DURATION); if not cleanupGuard.Parent then return end
            cleanupAllMovers(ball); RunService.Heartbeat:Wait()

            ball = findBall(1,0); if not ball then print("CI: Ball not found for stage 3."); performCleanupAndReset(); return end
            cgp = getOpponentGoalPos(); if not cgp then print("CI: Opponent goal not found for stage 3."); performCleanupAndReset(); return end
            vtg = cgp - ball.Position
            VFX_BALL_BLACK_FIRE_PLACEHOLDER(ball, "FinalShot")
            local finalStrikeBV = applyBodyVelocity(ball, vtg.Unit * SHOT_STAGE3_FINAL_SPEED, SHOT_STAGE3_DURATION + 0.2)
            if not (finalStrikeBV and finalStrikeBV.Parent) then 
                print("CI: Failed to apply final strike BodyVelocity.")
                performCleanupAndReset()
                return
            end
            print("CI: Final strike BodyVelocity applied. Waiting for duration: " .. SHOT_STAGE3_DURATION)
            task.wait(SHOT_STAGE3_DURATION) -- KEY FIX: Wait for the strike to happen
            if not cleanupGuard.Parent then return end
            
            success = true
            print("CI: Final strike sequence completed successfully before cleanup.")
        end)

        if not pcallSuccess then
            warn("CI Error (V31 - Final Strike Fix):", pcallResult)
        else
            if success then
                print("CI: Ability sequence reported success.")
            else
                print("CI: Ability sequence did not report success (likely an early exit or error within pcall).")
            end
        end
        performCleanupAndReset()
    end)
end

local function setupAbilityButton_CI()
    local abilitiesFrame = playerGui:WaitForChild("InGameUI", 10):WaitForChild("Bottom", 10):WaitForChild("Abilities", 10)
    if not abilitiesFrame then warn("CI: Abilities Frame not found!"); return nil end
    local templateButton = abilitiesFrame:FindFirstChild("1")
    if not templateButton then warn("CI: Template button '1' not found!"); return nil end
    local existingButton = abilitiesFrame:FindFirstChild(BUTTON_NAME_CI)
    if existingButton then existingButton:Destroy(); task.wait(0.1) end
    chaosImpactButton = templateButton:Clone()
    chaosImpactButton.Name = BUTTON_NAME_CI
    chaosImpactButton.Parent = abilitiesFrame
    chaosImpactButton.LayoutOrder = LAYOUT_ORDER_CI
    chaosImpactButton.Keybind.Text = ABILITY_KEY_CI.Name
    chaosImpactButton.Timer.Text = TIMER_TEXT_CI
    chaosImpactButton.ActualTimer.Text = ""
    local cdFrame = chaosImpactButton:FindFirstChild("Cooldown")
    if cdFrame then local grad = cdFrame:FindFirstChildOfClass("UIGradient"); if grad then grad.Offset = Vector2.new(0, 1) end end
    chaosImpactButton.Activated:Connect(ChaosImpact)
    print("CI: Button setup complete.")
    return chaosImpactButton
end

-- // --- INITIALIZATION (Original V31) --- //
setupAbilityButton_CI()
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY_CI then
        if chaosImpactButton and chaosImpactButton.Parent and chaosImpactButton.Visible then ChaosImpact() end
    end
end)

print(ABILITY_NAME_CI .. " V31 (Correct VFX Fix) Loaded.")


if not ShootRemote then warn("CI: ShootRemote was not found on initial load. Will try again on ability use.") end
setupAbilityUI_CI()
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY_CI then ChaosImpact() end
end)
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10)
    isAbilityActive_CI = false
    print("CI: Character respawned, variables updated.")
end)

print("Chaos Impact V31 (Final Strike Fix) Loaded.")

--[[
    Ability: ELASTO PASS - Standalone Test V67 (aPass Logic + SFX/Anim Fix)
    Creator: Manus (Based on User Requirements & Ace Style Reference)
    Version: V67 - Integrated aPass logic, fixed SFX/Anim playback.
]]

-- // Services
local Players = nil; local pcall_Players = pcall(function() Players = game:GetService("Players") end); if not pcall_Players then warn("Failed to get Players service") end
local ReplicatedStorage = nil; local pcall_RS = pcall(function() ReplicatedStorage = game:GetService("ReplicatedStorage") end); if not pcall_RS then warn("Failed to get ReplicatedStorage service") end
local UserInputService = nil; local pcall_UIS = pcall(function() UserInputService = game:GetService("UserInputService") end); if not pcall_UIS then warn("Failed to get UserInputService service") end
local RunService = nil; local pcall_RunS = pcall(function() RunService = game:GetService("RunService") end); if not pcall_RunS then warn("Failed to get RunService service") end
local Debris = nil; local pcall_Debris = pcall(function() Debris = game:GetService("Debris") end); if not pcall_Debris then warn("Failed to get Debris service") end
local Workspace = nil; local pcall_WS = pcall(function() Workspace = game:GetService("Workspace") end); if not pcall_WS then warn("Failed to get Workspace service") end
local Camera = nil; local pcall_Cam = pcall(function() Camera = Workspace and Workspace.CurrentCamera end); if not pcall_Cam or not Camera then warn("Failed to get Camera") end
local CoreGui = nil; local pcall_CG = pcall(function() CoreGui = game:GetService("CoreGui") end); if not pcall_CG then warn("Failed to get CoreGui service") end
local SoundService = nil; local pcall_SS = pcall(function() SoundService = game:GetService("SoundService") end); if not pcall_SS then warn("Failed to get SoundService service") end

-- Check if essential services loaded
if not Players or not ReplicatedStorage or not UserInputService or not RunService or not Debris or not Workspace or not CoreGui or not SoundService then
    warn("CRITICAL: One or more essential services failed to load. Script cannot continue.")
    return
end

-- // Player & Character Variables
local player = Players.LocalPlayer
if not player then warn("CRITICAL: LocalPlayer not found!"); return end

local playerGui = player:WaitForChild("PlayerGui", 10)
if not playerGui then warn("CRITICAL: PlayerGui not found!"); return end

local character = player.Character or player.CharacterAdded:Wait()
if not character then warn("CRITICAL: Character not found!"); return end

local humanoid = character:WaitForChild("Humanoid", 10)
if not humanoid then warn("CRITICAL: Humanoid not found!"); return end

local rootPart = character:WaitForChild("HumanoidRootPart", 10)
if not rootPart then warn("CRITICAL: HumanoidRootPart not found!"); return end

local playerValues = character:WaitForChild("Values", 10)
-- Values can be nil, will check when needed

-- // Remote Event Acquisition (Direct Path - Confirmed Working)
local shootEvent = nil
local function findShootRemoteStandardPath()
    print("Attempting Standard Path...")
    local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil
    if p then k=p:FindFirstChild("Knit",5) end
    if k then s=k:FindFirstChild("Services",5) end
    if s then b=s:FindFirstChild("BallService",5) end
    if b then r=b:FindFirstChild("RE",5) end
    local remote=r and r:FindFirstChild("Shoot",5)
    if remote and remote:IsA("RemoteEvent")then
        print("ShootRemote FOUND via Standard Path:",remote)
        return remote
    else
        warn("ShootRemote NOT found via Standard Path!")
        return nil
    end
end

local successShoot, resultShoot = pcall(function()
    shootEvent = findShootRemoteStandardPath()
end)
if not successShoot then warn("Error finding ShootRemote:", resultShoot) end
if not shootEvent then warn("!!! CRITICAL: ShootRemote could not be located. Ability may fail. !!!") end

-- // Ability Settings
local ABILITY_NAME = "Elasto Pass"
local ABILITY_KEY = Enum.KeyCode.C
local BUTTON_NAME = "ElastoPassButton"
local TIMER_TEXT = "Elasto Pass"
local LAYOUT_ORDER = 3
local APASS_VELOCITY = 250 -- Velocity from aPass.txt
local APASS_UPWARD_BIAS = 0.25 -- Upward bias from aPass.txt
local PASS_MAX_DURATION = 3.0 -- Max time velocity is applied (slightly increased)
local COOLDOWN = 1
local INITIAL_SHOOT_POWER = 30
local BALL_LIFT_FORCE = 100000
local BALL_LIFT_HEIGHT = 30
local BALL_FREEZE_DURATION = 0.5
local BALL_VFX_DURATION = 4 -- Duration for the VFX attached to the ball
local BUTTON_CLICK_VFX_DURATION = 4 -- Duration for the VFX played when button is clicked
local HIGHLIGHT_PULSE_SPEED = 1.5
local HIGHLIGHT_BASE_SIZE = UDim2.new(8, 0, 10, 0) -- Increased default base size
local HIGHLIGHT_SIZE_SCALE = 1.0 -- Multiplier for base size (e.g., 1.2 for 20% larger)
local HIGHLIGHT_TRANSPARENCY_VALUE = 0.7 -- Base transparency (0 = visible, 1 = invisible)
local HIGHLIGHT_PULSE_MIN_TRANSPARENCY = 0.6 -- Adjusted pulse range (relative to base transparency)
local HIGHLIGHT_PULSE_MAX_TRANSPARENCY = 0.85

-- // Sound/Animation IDs
local SOUND_ID_ELASTO_PASS = "rbxassetid://9125573611"
local SOUND_ID_ELASTO_IMPACT = "rbxassetid://9114487369"
local ANIM_ID_ELASTO_PASS = "rbxassetid://137923447090846"

-- // State & Connection Variables
local lastElastoPassTime = 0
local passVelocityConnection = nil
local currentTargetTeammate = nil
local targetHighlight = nil
local targetingConnection = nil
local highlightPulseConnection = nil
local isAbilityActive = false
local reinitializationTimer = nil
local abilityExecutionCount = 0
local currentPassAnimTrack = nil

-- // Sound Effects Container
local sfxContainer = nil
local successSFXContainer, resultSFXContainer = pcall(function()
    sfxContainer = Instance.new("Folder")
    sfxContainer.Name = "ElastoPassSFX_Container"
    sfxContainer.Parent = SoundService
end)
if not successSFXContainer then warn("Failed to create SFX container:", resultSFXContainer) end

-- // Helper Functions
local function IsReady()
    if isAbilityActive then print("Elasto Pass: Ability is currently active, cannot use again"); return false end
    local last=lastElastoPassTime or 0; if typeof(last)~="number" then last=0 end
    return tick()-last>=COOLDOWN
end

local function StartCooldown()
    lastElastoPassTime=tick(); isAbilityActive = true; abilityExecutionCount = abilityExecutionCount + 1
    print("Elasto Pass: Execution #" .. abilityExecutionCount)
end

-- // Simple SFX Player (Reliable)
local function playAbilitySound(soundId, volume, parentPart)
    if not soundId or soundId == "rbxassetid://YOUR_SOUND_ID_HERE" then print("SFX Skipped (Placeholder)"); return end
    if not sfxContainer and not parentPart then warn("Cannot play sound: No SFX container or parent part."); return end

    local success, result = pcall(function()
        local sound = Instance.new("Sound")
        sound.SoundId = soundId
        sound.Volume = volume or 1
        sound.Parent = parentPart or sfxContainer -- Parent to part if provided, else container
        sound:Play()
        print("Playing SFX:", soundId, "Volume:", sound.Volume, "Parent:", sound.Parent.Name)
        Debris:AddItem(sound, sound.TimeLength + 0.2) -- Auto cleanup
    end)
    if not success then
        warn("Failed to play sound", soundId, ":", result)
    end
end

-- // Simple Animation Player (Reliable)
local function playAbilityAnimation(animId)
    if not animId or animId == "rbxassetid://YOUR_ANIM_ID_HERE" then print("Animation Skipped (Placeholder)"); return nil end
    local currentCharacter = player.Character; if not currentCharacter then warn("playAbilityAnimation: Character not found"); return nil end
    local currentHumanoid = currentCharacter:FindFirstChild("Humanoid"); if not currentHumanoid then warn("playAbilityAnimation: Humanoid not found"); return nil end
    local animator = currentHumanoid:FindFirstChildOfClass("Animator"); if not animator then pcall(function() animator = Instance.new("Animator", currentHumanoid) end); if not animator then warn("playAbilityAnimation: Failed to create Animator"); return nil end end

    -- Stop previous animation if it's still playing
    if currentPassAnimTrack and currentPassAnimTrack.IsPlaying then
        pcall(function() currentPassAnimTrack:Stop() end)
        currentPassAnimTrack = nil
    end

    local animInstance = Instance.new("Animation"); animInstance.AnimationId = animId; animInstance.Parent = currentHumanoid
    local success, animTrack = pcall(function() return animator:LoadAnimation(animInstance) end)
    pcall(function() if animInstance and animInstance.Parent then animInstance:Destroy() end end) -- Clean up the temporary instance

    if success and animTrack then
        currentPassAnimTrack = animTrack -- Store the track
        pcall(function() animTrack:Play() end)
        print("Playing Animation:", animId)
        return animTrack
    else
        warn("Animation load/play failed:", animId, "| Error:", tostring(animTrack))
        return nil
    end
end

local function cleanupBallPhysics(ballInstance)
    if not ballInstance or not ballInstance.Parent or not ballInstance:IsA("BasePart") then return end
    pcall(function() for _, child in ipairs(ballInstance:GetChildren()) do if child:IsA("BodyMover") or child:IsA("BodyGyro") then pcall(function() child:Destroy() end) end end end)
end

local function findBallInWorkspace()
    local f = Workspace:FindFirstChild("Football")
    if f then
        local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
        if b and b:IsA("BasePart") then return b elseif f:IsA("Model") and f.PrimaryPart then return f.PrimaryPart elseif f:IsA("BasePart") then return f end
    end
    local charBall = player.Character and player.Character:FindFirstChild("BALL"); if charBall and charBall.Parent and charBall:IsA("BasePart") then return charBall end
    return nil
end

local function playerHasBall()
    local currentCharacter = player.Character; if not currentCharacter then return false end
    local v = currentCharacter:FindFirstChild("Values"); if not v then return false end
    local h = v:FindFirstChild("HasBall"); return h and h.Value == true
end

local function isPlayerInTeam(cP,tF)
    if not cP or not tF then return false end
    local success, result = pcall(function() for _,o in ipairs(tF:GetChildren()) do if o:IsA("ObjectValue")then if o.Value==cP or o.Name==cP.Name then return true end end end; return false end)
    if not success then warn("isPlayerInTeam error:", result); return false end; return result
end

local function getPlayerTeam(cP)
    if not cP then return nil end; local tf=ReplicatedStorage:FindFirstChild("Teams"); if not tf then return nil end
    local at=tf:FindFirstChild("AwayTeam"); local ht=tf:FindFirstChild("HomeTeam"); if not(at and ht)then return nil end
    if isPlayerInTeam(cP,at)then return at elseif isPlayerInTeam(cP,ht)then return ht else return nil end
end

-- // VFX Function: Button Click (User Provided)
local function playButtonClickVFX(duration)
    local currentCharacter = player.Character; if not currentCharacter then warn("Button Click VFX: Character missing"); return end
    local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart"); if not currentRootPart then warn("Button Click VFX: HRP missing"); return end
    if not RunService:IsClient() then return end
    print("Creating Button Click VFX for", duration, "seconds")

    local effectPart = nil
    local successPart, resultPart = pcall(function()
        local part = Instance.new("Part")
        part.Name = "ElastoPassButtonClickVFX"
        part.Anchored = true
        part.CanCollide = false
        part.Transparency = 1
        part.Parent = workspace
        local forward = currentRootPart.CFrame.LookVector
        local effectCFrame = CFrame.new(currentRootPart.Position + (forward * 5), currentRootPart.Position + (forward * 5) + forward)
        part.CFrame = effectCFrame
        return part
    end)
    if not successPart or not resultPart then warn("Failed to create Button Click VFX part:", resultPart); return end
    effectPart = resultPart

    local particles = {}
    local maxLifetime = 0

    local successVFX, errorVFX = pcall(function()
        do -- Emitter 1
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.2, 0.45); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-5, 5); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.199108, 0.265432), NumberSequenceKeypoint.new(0.399703, 0), NumberSequenceKeypoint.new(0.602526, 0), NumberSequenceKeypoint.new(0.799406, 0.246914), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -5; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(100, 150); particle.Brightness = 25; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 40.547779)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(700, 700); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-360, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://9324968005"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 2
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.3, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-40, 40); particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.196326, 0.2375), NumberSequenceKeypoint.new(0.406429, 0), NumberSequenceKeypoint.new(0.600459, 0), NumberSequenceKeypoint.new(0.797933, 0.2625), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityParallel; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 3; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -40; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.825), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(80, 120); particle.Brightness = 10; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2.75), NumberSequenceKeypoint.new(0.252568, 6.95611), NumberSequenceKeypoint.new(0.500568, 8.893476), NumberSequenceKeypoint.new(0.702568, 7.69388), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, -10, 0); particle.RotSpeed = NumberRange.new(0, 0); particle.ZOffset = 1; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 100; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-90, -90); particle.ShapePartial = 1; particle.Texture = "rbxassetid://7216848401"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 1; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 3
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.3, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-30, 30); particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Orientation = Enum.ParticleOrientation.VelocityParallel; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 10; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -30; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(0.36409, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(150, 250); particle.Brightness = 10; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.149826, 0.5625), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, -10, 0); particle.RotSpeed = NumberRange.new(0, 0); particle.ZOffset = 2; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 24; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-90, -90); particle.ShapePartial = 1; particle.Texture = "rbxassetid://8271975883"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0.65; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 4
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.45, 0.45); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-5, 5); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.052632, 0.082579), NumberSequenceKeypoint.new(0.105263, 0.164595), NumberSequenceKeypoint.new(0.157895, 0.245485), NumberSequenceKeypoint.new(0.210526, 0.324699), NumberSequenceKeypoint.new(0.263158, 0.401695), NumberSequenceKeypoint.new(0.315789, 0.475947), NumberSequenceKeypoint.new(0.368421, 0.546948), NumberSequenceKeypoint.new(0.421053, 0.614213), NumberSequenceKeypoint.new(0.473684, 0.677282), NumberSequenceKeypoint.new(0.526316, 0.735724), NumberSequenceKeypoint.new(0.578947, 0.789141), NumberSequenceKeypoint.new(0.631579, 0.837166), NumberSequenceKeypoint.new(0.684211, 0.879474), NumberSequenceKeypoint.new(0.736842, 0.915773), NumberSequenceKeypoint.new(0.789474, 0.945817), NumberSequenceKeypoint.new(0.842105, 0.9694), NumberSequenceKeypoint.new(0.894737, 0.986361), NumberSequenceKeypoint.new(0.947368, 0.996584), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -5; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(40, 60); particle.Brightness = 25; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.052632, 3.743257), NumberSequenceKeypoint.new(0.105263, 7.092871), NumberSequenceKeypoint.new(0.157895, 10.07071), NumberSequenceKeypoint.new(0.210526, 12.698644), NumberSequenceKeypoint.new(0.263158, 14.998542), NumberSequenceKeypoint.new(0.315789, 16.992273), NumberSequenceKeypoint.new(0.368421, 18.701706), NumberSequenceKeypoint.new(0.421053, 20.14871), NumberSequenceKeypoint.new(0.473684, 21.355154), NumberSequenceKeypoint.new(0.526316, 22.342907), NumberSequenceKeypoint.new(0.578947, 23.133839), NumberSequenceKeypoint.new(0.631579, 23.749817), NumberSequenceKeypoint.new(0.684211, 24.212713), NumberSequenceKeypoint.new(0.736842, 24.544394), NumberSequenceKeypoint.new(0.789474, 24.766729), NumberSequenceKeypoint.new(0.842105, 24.901588), NumberSequenceKeypoint.new(0.894737, 24.97084), NumberSequenceKeypoint.new(0.947368, 24.996355), NumberSequenceKeypoint.new(1, 25)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(700, 700); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-360, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://8214519968"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 1; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 5
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(32, 32); particle.LightInfluence = 0.45; particle.Lifetime = NumberRange.new(0.4, 0.4); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4; particle.SpreadAngle = Vector2.new(-15, 15); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.505166, 0), NumberSequenceKeypoint.new(0.656716, 0.07732), NumberSequenceKeypoint.new(0.816303, 0.247423), NumberSequenceKeypoint.new(0.918484, 0.5), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.FacingCamera; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -15; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.1125), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(80, 100); particle.Brightness = 5.075; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.080568, 5.782013), NumberSequenceKeypoint.new(0.140568, 8.931145), NumberSequenceKeypoint.new(0.208568, 11.667276), NumberSequenceKeypoint.new(0.272568, 12.957904), NumberSequenceKeypoint.new(0.356568, 14.093657), NumberSequenceKeypoint.new(0.490568, 14.764783), NumberSequenceKeypoint.new(0.648568, 13.780464), NumberSequenceKeypoint.new(0.736568, 11.565746), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(0, 0); particle.ZOffset = -1; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 250; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(0, 360); particle.ShapePartial = 2; particle.Texture = "rbxassetid://11846336638"; particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Disc; particle.LightEmission = 0.55; particle.Parent = effectPart; table.insert(particles, particle)
        end
    end)

    if not successVFX then
        warn("Error creating Button Click VFX particles:", errorVFX)
        if effectPart and effectPart.Parent then pcall(function() effectPart:Destroy() end) end
        return
    end

    -- Enable particles
    for _, particle in ipairs(particles) do
        pcall(function() if particle and particle.Parent then particle.Enabled = true end end)
    end

    -- Schedule cleanup based on duration parameter
    task.delay(duration, function()
        pcall(function()
            if effectPart and effectPart.Parent then
                for _, particle in ipairs(particles) do
                    pcall(function() if particle and particle.Parent then particle.Enabled = false end end)
                end
                -- Allow particles to finish before removing effectPart
                task.delay(maxLifetime + 0.1, function()
                    pcall(function() if effectPart and effectPart.Parent then Debris:AddItem(effectPart, 0.1) end end)
                end)
            end
        end)
    end)

    return effectPart
end

-- // VFX Function: Ball VFX (User Provided)
local function playElastoPassBallVFX(ballPart, duration)
    if not ballPart or not ballPart:IsA("BasePart") or not ballPart.Parent then warn("Ball VFX: Invalid ball part"); return end
    print("Creating Ball VFX for", duration, "seconds")

    local effectPart = nil
    local successPart, resultPart = pcall(function()
        local part = Instance.new("Part"); part.Name = "ElastoPassBallVFX"; part.Anchored = false; part.CanCollide = false; part.Transparency = 1; part.Size = Vector3.new(0.1, 0.1, 0.1)
        local weld = Instance.new("WeldConstraint"); weld.Name = "BallVFXWeld"; weld.Part0 = part; weld.Part1 = ballPart; weld.Parent = part
        part.CFrame = ballPart.CFrame; part.Parent = ballPart
        return part
    end)
    if not successPart or not resultPart then warn("Failed to create Ball VFX part:", resultPart); return end
    effectPart = resultPart

    local particles = {}
    local maxLifetime = 0

    local successVFX, errorVFX = pcall(function()
        do -- Emitter 1 (Black Ring)
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.15, 0.2); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(360, 360); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Orientation = Enum.ParticleOrientation.FacingCamera; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = 360; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(0.501534, -1.354839), NumberSequenceKeypoint.new(1, 3)}); particle.Speed = NumberRange.new(0, 0); particle.Brightness = 10; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.5, 20), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(-45, 45); particle.ZOffset = 3; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 25; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-180, 180); particle.ShapePartial = 1; particle.Texture = "http://www.roblox.com/asset/?id=4963436775"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Top; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0.1; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 2 (White Ring)
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.15, 0.2); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(360, 360); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Orientation = Enum.ParticleOrientation.FacingCamera; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = 360; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(0.501534, -1.354839), NumberSequenceKeypoint.new(1, 3)}); particle.Speed = NumberRange.new(0, 0); particle.Brightness = 10; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.5, 40), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(-45, 45); particle.ZOffset = 2; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 25; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-180, 180); particle.ShapePartial = 1; particle.Texture = "http://www.roblox.com/asset/?id=4963436775"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Top; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 3 (Black Smoke)
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.5, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(360, 360); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.089552, 0.54375), NumberSequenceKeypoint.new(0.198622, 0.75625), NumberSequenceKeypoint.new(0.360505, 0.88125), NumberSequenceKeypoint.new(0.698048, 0.98125), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.FacingCamera; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))}); particle.Drag = 2; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = 360; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.501534, 0.064516), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(2, 5); particle.Brightness = 15; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 60)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 20, 0); particle.RotSpeed = NumberRange.new(-90, 90); particle.ZOffset = 0; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 150; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(0, 360); particle.ShapePartial = 1; particle.Texture = "http://www.roblox.com/asset/?id=243098098"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Top; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 4 (White Flash)
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.25, 0.25); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(0, 0); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.FacingCamera; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = 0; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(0, 0); particle.Brightness = 5; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 60)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(0, 0); particle.ZOffset = -1; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(0, 0); particle.ShapePartial = 1; particle.Texture = "rbxassetid://989615068"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Top; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 1; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 5 (Black Spin)
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.1, 0.1); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(360, 360); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Orientation = Enum.ParticleOrientation.FacingCamera; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))}); particle.Drag = 15; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = 360; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(200, 250); particle.Brightness = 4.135; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 30), NumberSequenceKeypoint.new(1, 30)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(10000, 10000); particle.ZOffset = 1; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(0, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://280271984"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Top; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 1; particle.Parent = effectPart; table.insert(particles, particle)
        end
    end)

    if not successVFX then
        warn("Error creating Ball VFX particles:", errorVFX)
        if effectPart and effectPart.Parent then pcall(function() effectPart:Destroy() end) end
        return
    end

    -- Enable particles
    for _, particle in ipairs(particles) do
        pcall(function() if particle and particle.Parent then particle.Enabled = true end end)
    end

    -- Schedule cleanup based on duration parameter
    task.delay(duration, function()
        pcall(function()
            if effectPart and effectPart.Parent then
                for _, particle in ipairs(particles) do
                    pcall(function() if particle and particle.Parent then particle.Enabled = false end end)
                end
                -- Allow particles to finish before removing effectPart
                task.delay(maxLifetime + 0.1, function()
                    pcall(function() if effectPart and effectPart.Parent then Debris:AddItem(effectPart, 0.1) end end)
                end)
            end
        end)
    end)

    return effectPart
end

-- // Teammate Targeting Logic
local function getValidTeammates()
    local t={}; pcall(function() for _,p in ipairs(Players:GetPlayers()) do if p~=player and p.Team==player.Team and p.Character and p.Character:FindFirstChild("HumanoidRootPart")then table.insert(t,p) end end end); return t
end

local function startHighlightPulseEffect(highlight)
    if not highlight or not highlight.Parent then return end
    if highlightPulseConnection and highlightPulseConnection.Connected then pcall(function() highlightPulseConnection:Disconnect() end); highlightPulseConnection = nil end
    local startTime = tick(); local frame = highlight:FindFirstChildOfClass("Frame"); if not frame then return end
    highlightPulseConnection = RunService.Heartbeat:Connect(function()
        if not highlight or not highlight.Parent or not frame or not frame.Parent then if highlightPulseConnection then pcall(function() highlightPulseConnection:Disconnect() end) end; return end
        local elapsed = (tick() - startTime) * HIGHLIGHT_PULSE_SPEED; local pulse = (math.sin(elapsed * math.pi) + 1) / 2
        -- Pulse between min and max transparency, relative to base
        local minTrans = HIGHLIGHT_TRANSPARENCY_VALUE + (1 - HIGHLIGHT_TRANSPARENCY_VALUE) * (1 - HIGHLIGHT_PULSE_MAX_TRANSPARENCY)
        local maxTrans = HIGHLIGHT_TRANSPARENCY_VALUE + (1 - HIGHLIGHT_TRANSPARENCY_VALUE) * (1 - HIGHLIGHT_PULSE_MIN_TRANSPARENCY)
        pcall(function() frame.BackgroundTransparency = minTrans + (pulse * (maxTrans - minTrans)) end)
    end)
    return highlightPulseConnection
end

local function createTeammateHighlight(teammatePlayer)
    if not teammatePlayer or not teammatePlayer.Character then return nil end
    if targetHighlight and targetHighlight.Parent then pcall(function() targetHighlight:Destroy() end); targetHighlight = nil end
    local highlight = nil
    local success, result = pcall(function()
        local gui = Instance.new("BillboardGui"); gui.Name = "ElastoPassTargetHighlight_Oval"; gui.AlwaysOnTop = true;
        -- Apply size scale
        gui.Size = UDim2.new(HIGHLIGHT_BASE_SIZE.X.Scale * HIGHLIGHT_SIZE_SCALE, HIGHLIGHT_BASE_SIZE.X.Offset * HIGHLIGHT_SIZE_SCALE,
                             HIGHLIGHT_BASE_SIZE.Y.Scale * HIGHLIGHT_SIZE_SCALE, HIGHLIGHT_BASE_SIZE.Y.Offset * HIGHLIGHT_SIZE_SCALE)
        gui.StudsOffset = Vector3.new(0, 0, 0); gui.Adornee = teammatePlayer.Character:FindFirstChild("HumanoidRootPart")
        local frame = Instance.new("Frame"); frame.Size = UDim2.new(1, 0, 1, 0);
        -- Apply base transparency
        frame.BackgroundTransparency = HIGHLIGHT_TRANSPARENCY_VALUE;
        frame.BorderSizePixel = 0
        local gradient = Instance.new("UIGradient"); gradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); gradient.Rotation = 90; gradient.Parent = frame
        local corner = Instance.new("UICorner"); corner.CornerRadius = UDim.new(0.5, 0); corner.Parent = frame
        frame.Parent = gui; gui.Parent = playerGui
        return gui
    end)
    if not success or not result then warn("Failed to create teammate highlight:", result); return nil end
    highlight = result; startHighlightPulseEffect(highlight); return highlight
end

local function updateTargetTeammate()
    if not Camera or not Camera.Parent then return end
    local validTeammates = getValidTeammates(); local bestTarget = nil; local closestDistToMouse = math.huge
    local mousePos = Vector2.new(0, 0); pcall(function() mousePos = UserInputService:GetMouseLocation() end)
    for _, teammatePlayer in ipairs(validTeammates) do
        if not teammatePlayer or not teammatePlayer.Character then continue end
        local teammateChar = teammatePlayer.Character; local teammateHRP = teammateChar and teammateChar:FindFirstChild("HumanoidRootPart")
        if teammateHRP then
            local screenPos, onScreen = Vector2.new(0, 0), false; pcall(function() local worldPos = Camera:WorldToViewportPoint(teammateHRP.Position); screenPos = Vector2.new(worldPos.X, worldPos.Y); onScreen = worldPos.Z > 0 end)
            if onScreen then
                local distToMouse = (screenPos - mousePos).Magnitude
                if distToMouse < closestDistToMouse then
                    local isVisible = false; pcall(function() local ray = Ray.new(Camera.CFrame.Position, (teammateHRP.Position - Camera.CFrame.Position).Unit * (teammateHRP.Position - Camera.CFrame.Position).Magnitude); local hit, _ = Workspace:FindPartOnRayWithIgnoreList(ray, {character, teammateChar, Workspace:FindFirstChild("Football")}); isVisible = not hit or hit:IsDescendantOf(teammateChar) end)
                    if isVisible then closestDistToMouse = distToMouse; bestTarget = teammatePlayer end
                end
            end
        end
    end
    if currentTargetTeammate ~= bestTarget then
        local previousTarget = currentTargetTeammate
        currentTargetTeammate = bestTarget
        if currentTargetTeammate then
            targetHighlight = createTeammateHighlight(currentTargetTeammate)
            if previousTarget ~= currentTargetTeammate then -- Only play sound on new target acquisition
                playAbilitySound(SOUND_ID_ELASTO_IMPACT, 0.2) -- Use new SFX player
            end
        else
            if targetHighlight and targetHighlight.Parent then pcall(function() targetHighlight:Destroy() end); targetHighlight = nil end
        end
    end
end

local function initializeTargetingSystem()
    if targetingConnection and targetingConnection.Connected then pcall(function() targetingConnection:Disconnect() end); targetingConnection = nil end
    if targetHighlight and targetHighlight.Parent then pcall(function() targetHighlight:Destroy() end); targetHighlight = nil end
    currentTargetTeammate = nil;
    local success, result = pcall(function() targetingConnection = RunService.Heartbeat:Connect(updateTargetTeammate) end)
    if not success then warn("Failed to initialize targeting system:", result) end
    return targetingConnection
end
pcall(initializeTargetingSystem)

-- // Multi-use Reinitialize Function
local function reinitializeAbility()
    print("Elasto Pass: Re-initializing script functions to enable multi-use...")
    if reinitializationTimer then pcall(function() reinitializationTimer:Disconnect() end); reinitializationTimer = nil end
    isAbilityActive = false
    if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end); passVelocityConnection = nil end
    if highlightPulseConnection and highlightPulseConnection.Connected then pcall(function() highlightPulseConnection:Disconnect() end); highlightPulseConnection = nil end
    pcall(initializeTargetingSystem) -- Re-initialize targeting to clear old target and start loop
    print("Elasto Pass: Re-initialization complete, ability is ready for next use.")
end

-- // Ability Function: ELASTO PASS (V67 - aPass Logic)
local function ElastoPass()
    -- Pre-checks
    if not IsReady() then print(ABILITY_NAME .. " on CD"); return end
    if not playerHasBall() then warn("Elasto Pass: No ball"); return end
    if not shootEvent then warn("Elasto Pass: ShootRemote missing!"); return end

    -- Get fresh character references
    local currentCharacter = player.Character; if not currentCharacter then warn("Elasto Pass: Character missing"); return end
    local currentHumanoid = currentCharacter:FindFirstChild("Humanoid"); if not currentHumanoid then warn("Elasto Pass: Humanoid missing"); return end
    local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart"); if not currentRootPart then warn("Elasto Pass: HumanoidRootPart missing"); return end

    -- Get target AT THE MOMENT OF ACTIVATION
    local targetPlayerAtActivation = currentTargetTeammate
    if not targetPlayerAtActivation then warn("Elasto Pass: No teammate currently highlighted/targeted."); return end
    local targetChar = targetPlayerAtActivation.Character; if not targetChar then warn("Elasto Pass: Target char missing."); return end
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart"); if not targetHRP then warn("Elasto Pass: Target HRP missing."); return end

    StartCooldown()

    -- Effects & Animation (Reliable Playback)
    playAbilityAnimation(ANIM_ID_ELASTO_PASS)
    playAbilitySound(SOUND_ID_ELASTO_PASS, 2.5, currentRootPart)
    pcall(function() playButtonClickVFX(BUTTON_CLICK_VFX_DURATION) end)

    -- Detach Ball
    local successDetach, resultDetach = pcall(function() shootEvent:FireServer(INITIAL_SHOOT_POWER); print("Fired ShootRemote (Power " .. INITIAL_SHOOT_POWER .. ") to detach ball") end)
    if not successDetach then warn("Failed to fire ShootRemote:", resultDetach) end

    -- Post-Detach Logic (Lift, VFX, Pass using aPass logic)
    task.spawn(function()
        local ballInWorkspace, startTime = nil, tick(); local findTimeout = 1.5;
        local successFind, resultFind = pcall(function() repeat task.wait(0.03); ballInWorkspace = findBallInWorkspace() until (ballInWorkspace and ballInWorkspace:IsA("BasePart")) or tick() - startTime > findTimeout end)
        if not successFind then warn("Error finding ball:", resultFind) end
        if not ballInWorkspace then warn("Elasto Pass: Ball not found post-shot."); return end

        -- Ball Effects (Now using user-provided VFX)
        pcall(function() playElastoPassBallVFX(ballInWorkspace, BALL_VFX_DURATION) end)
        playAbilitySound(SOUND_ID_ELASTO_IMPACT, 1.8, ballInWorkspace)

        -- Physics Setup
        pcall(function() cleanupBallPhysics(ballInWorkspace); if ballInWorkspace:IsA("BasePart") then ballInWorkspace.Anchored = false end end)

        -- Apply Lift
        local bp = nil
        local successLift, resultLift = pcall(function()
            local targetLiftPos = ballInWorkspace.Position + Vector3.new(0, BALL_LIFT_HEIGHT, 0)
            bp = Instance.new("BodyPosition"); bp.Name = "ElastoLiftBP"; bp.MaxForce = Vector3.new(1e7, 1e7, 1e7); bp.P = BALL_LIFT_FORCE; bp.D = 2500; bp.Position = targetLiftPos; bp.Parent = ballInWorkspace
        end)
        if not successLift then warn("Error applying lift:", resultLift) end

        task.wait(BALL_FREEZE_DURATION)

        -- Check if objects still exist before passing
        -- IMPORTANT: Use the target captured AT ACTIVATION, not the current mouse target
        local targetHRP_Pass = nil; pcall(function() targetHRP_Pass = targetPlayerAtActivation.Character and targetPlayerAtActivation.Character:FindFirstChild("HumanoidRootPart") end)
        if not ballInWorkspace or not ballInWorkspace.Parent or not (bp and bp.Parent) or not targetHRP_Pass or not targetHRP_Pass.Parent then
            warn("Elasto Pass: Ball, BP, or Target lost during freeze.")
            if bp and bp.Parent then pcall(function() bp:Destroy() end) end
            if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end
            return
        end

        -- Remove Lift & Start Pass (Using aPass Logic)
        pcall(function() if bp and bp.Parent then bp:Destroy() end end)
        if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end

        print("Elasto Pass: Starting pass towards", targetPlayerAtActivation.Name, "using aPass logic")
        local passStartTime = tick()
        local successPassConn, resultPassConn = pcall(function()
            passVelocityConnection = RunService.Heartbeat:Connect(function(dt)
                -- IMPORTANT: Continue using the target captured AT ACTIVATION
                local targetHRP_Loop = nil; pcall(function() targetHRP_Loop = targetPlayerAtActivation.Character and targetPlayerAtActivation.Character:FindFirstChild("HumanoidRootPart") end)
                if not ballInWorkspace or not ballInWorkspace.Parent or not targetHRP_Loop or not targetHRP_Loop.Parent then
                    if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end; return
                end

                local currentTargetPos = targetHRP_Loop.Position
                local ballPos = ballInWorkspace.Position
                local direction = (currentTargetPos - ballPos).Unit
                local distance = (currentTargetPos - ballPos).Magnitude

                -- Stop condition: Close enough to target
                if distance < 5 then
                    print("Elasto Pass (aPass): Reached target proximity.")
                    if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end
                    pcall(function() if ballInWorkspace:IsA("BasePart") then ballInWorkspace.AssemblyLinearVelocity = Vector3.new(0,0,0) end end) -- Stop the ball
                    return
                end

                -- Timeout condition
                if tick() - passStartTime > PASS_MAX_DURATION then
                    print("Elasto Pass (aPass): Pass timed out.")
                    if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end
                    return
                end

                -- Apply velocity (aPass logic)
                local velocity = (direction + Vector3.new(0, APASS_UPWARD_BIAS, 0)) * APASS_VELOCITY
                pcall(function() if ballInWorkspace:IsA("BasePart") then ballInWorkspace.AssemblyLinearVelocity = velocity end end)
            end)
        end)
        if not successPassConn then warn("Failed to connect aPass velocity loop:", resultPassConn) end

        -- Pass Velocity Timeout (redundant but safe)
        task.delay(PASS_MAX_DURATION + 0.5, function() if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end end)
    end)

    -- Schedule Reinitialization for Multi-Use
    pcall(function() if reinitializationTimer then reinitializationTimer:Disconnect(); reinitializationTimer = nil end; reinitializationTimer = task.delay(COOLDOWN + 0.5, reinitializeAbility) end)
end

-- // --- UI Setup --- (UNCHANGED)
local elastoPassButton = nil
local function setupSingleButtonUI()
    local success, result = pcall(function()
        local playerGui = player:WaitForChild("PlayerGui"); local inGameUI = playerGui:WaitForChild("InGameUI", 15); if not inGameUI then warn("No InGameUI"); return false end
        local bottom = inGameUI:WaitForChild("Bottom", 10); if not bottom then warn("No Bottom"); return false end
        local bottomAbilities = bottom:WaitForChild("Abilities", 10); if not bottomAbilities then warn("No Abilities Frame"); return false end
        local templateButton = bottomAbilities:WaitForChild("1", 5) or bottomAbilities:FindFirstChildWhichIsA("ImageButton"); if not templateButton then warn("No Template Button"); return false end
        local oldBtn = bottomAbilities:FindFirstChild(BUTTON_NAME); if oldBtn then oldBtn:Destroy(); task.wait(0.1) end
        local b = nil; local s = pcall(function() b = templateButton:Clone() end); if not s or not b then warn("Clone fail"); return false end
        b.Name = BUTTON_NAME; b.Parent = bottomAbilities; b.LayoutOrder = LAYOUT_ORDER
        local kL = b:WaitForChild("Keybind", 2) or b:FindFirstChildWhichIsA("TextLabel", true); local tL = b:WaitForChild("Timer", 2) or b:FindFirstChild("AbilityName", true) or b:FindFirstChildWhichIsA("TextLabel", true); local aTL = b:FindFirstChild("ActualTimer", true)
        if kL and kL:IsA("TextLabel") then pcall(function() kL.Text = ABILITY_KEY.Name end) else warn("KeybindLbl Missing") end
        if tL and tL:IsA("TextLabel") then pcall(function() tL.Text = TIMER_TEXT end) else warn("TimerLbl Missing") end
        if aTL and aTL:IsA("TextLabel") then pcall(function() aTL.Text = "" end) end
        local cV = b:FindFirstChild("Cooldown") or b:FindFirstChild("cooldown"); if cV then cV:Destroy() end
        local aF = b:FindFirstChild("Ability") or b
        if aF and aF:IsA("GuiObject") then
            local cF = Instance.new("Frame"); cF.Name = "Cooldown"; cF.BackgroundColor3 = Color3.fromRGB(0, 0, 0); cF.BackgroundTransparency = 0.6; cF.BorderSizePixel = 0; cF.Size = UDim2.new(1, 0, 1, 0); cF.Position = UDim2.new(0, 0, 1, 0); cF.AnchorPoint = Vector2.new(0, 1); cF.ZIndex = (aF.ZIndex or 1) + 1; cF.Parent = aF
            local uC = Instance.new("UICorner", cF); local aS = aF.AbsoluteSize; local r = math.max(1, math.min(aS.X, aS.Y) * 0.15); uC.CornerRadius = UDim.new(0, r)
            aF:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() pcall(function() if not uC or not uC.Parent then return end; local nS = aF.AbsoluteSize; local nR = math.max(1, math.min(nS.X, nS.Y) * 0.15); uC.CornerRadius = UDim.new(0, nR) end) end)
        else warn("Ability Frame missing") end
        return b
    end)
    if success and result then elastoPassButton = result; print("UI Button Created:", ABILITY_NAME); pcall(function() elastoPassButton.Activated:Connect(function() pcall(ElastoPass) end) end); print("Connected Activated")
    else warn("Failed to setup UI:", tostring(result)) end
end

-- // --- Cooldown Update --- (UNCHANGED)
RunService.Heartbeat:Connect(function(dt)
    pcall(function()
        if elastoPassButton and elastoPassButton.Parent then
            local tl = (lastElastoPassTime or 0) + COOLDOWN - tick()
            local aF = elastoPassButton:FindFirstChild("Ability") or elastoPassButton; local cF = aF and aF:FindFirstChild("Cooldown"); local tL = elastoPassButton:FindFirstChild("Timer") or elastoPassButton:FindFirstChild("AbilityName", true)
            if tL and tL:IsA("TextLabel") then
                if tl > 0 then
                    if cF then local p = math.clamp(tl / COOLDOWN, 0, 1); pcall(function() if cF and cF.Parent then cF.Size = UDim2.new(1, 0, p, 0); cF.Visible = true end end) end
                    pcall(function() tL.Text = string.format("%.1fs", tl) end)
                else
                    if cF then pcall(function() if cF and cF.Parent then cF.Visible = false end end) end
                    local currentText = ""; pcall(function() currentText = tL.Text end)
                    if currentText ~= TIMER_TEXT then pcall(function() if tL and tL.Parent then tL.Text = TIMER_TEXT end end) end
                end
            end
        end
    end)
end)

-- // --- Input Handling --- (UNCHANGED)
UserInputService.InputBegan:Connect(function(i, gp)
    pcall(function() if gp then return end; if i.UserInputType == Enum.UserInputType.Keyboard and i.KeyCode == ABILITY_KEY then pcall(ElastoPass) end end)
end)

-- // --- Respawn Handling ---
player.CharacterAdded:Connect(function(nc)
    pcall(function()
        print("Character Added (Elasto Pass)"); character = nc; humanoid = character:WaitForChild("Humanoid"); rootPart = character:WaitForChild("HumanoidRootPart"); playerValues = character:WaitForChild("Values", 10)
        lastElastoPassTime = 0; isAbilityActive = false
        if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end
        if highlightPulseConnection and highlightPulseConnection.Connected then pcall(function() highlightPulseConnection:Disconnect() end) end
        if reinitializationTimer then pcall(function() reinitializationTimer:Disconnect() end) end
        if currentPassAnimTrack then pcall(function() currentPassAnimTrack:Stop() end); currentPassAnimTrack = nil end -- Stop animation on respawn
        currentTargetTeammate = nil; if targetHighlight and targetHighlight.Parent then pcall(function() targetHighlight:Destroy() end); targetHighlight = nil end
        initializeTargetingSystem(); print("Elasto Pass Test: Respawned.")
    end)
end)

-- // --- Initial Setup ---
if shootEvent then pcall(setupSingleButtonUI); print(ABILITY_NAME .. " Test Script Loaded! (V67 - aPass Logic)")
else warn(ABILITY_NAME .. " Test Script FAILED TO LOAD due to missing ShootRemote.") end

-- // --- Cleanup ---
Players.PlayerRemoving:Connect(function(lp)
    if lp == player then
        if targetingConnection and targetingConnection.Connected then pcall(function() targetingConnection:Disconnect() end) end
        if passVelocityConnection and passVelocityConnection.Connected then pcall(function() passVelocityConnection:Disconnect() end) end
        if highlightPulseConnection and highlightPulseConnection.Connected then pcall(function() highlightPulseConnection:Disconnect() end) end
        if reinitializationTimer then pcall(function() reinitializationTimer:Disconnect() end) end
        if targetHighlight and targetHighlight.Parent then pcall(function() targetHighlight:Destroy() end) end
        if currentPassAnimTrack then pcall(function() currentPassAnimTrack:Stop(); currentPassAnimTrack:Destroy() end); currentPassAnimTrack = nil end
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local SoundService = game:GetService("SoundService")

-- // Player & Character Variables
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- // Animation Variables
local movementAnimation = Instance.new("Animation")
movementAnimation.AnimationId = "rbxassetid://74249210159048"
local movementAnimTrack = nil

-- // Knit Framework (Used in the game)
local Knit = require(ReplicatedStorage.Packages.Knit)
local StatesController = Knit.GetController("StatesController")

-- // --- CONFIGURABLE VALUES --- //
-- Key binding for PC
local ABILITY_KEY_GR = Enum.KeyCode.G  -- Default key for Glitch Rush

-- Cooldown
local COOLDOWN_GR = 3  -- Cooldown in seconds

-- Glitch Effect (Left-Right Illusion)
local GLITCH_DURATION = 1.5  -- Duration of glitch effect in seconds (adjustable: 1-2 seconds)
local GLITCH_FREQUENCY = 0.05  -- How quickly to move left-right (lower = faster)
local GLITCH_DISTANCE = 6  -- How far to move left/right during glitch effect
local GLITCH_ITERATIONS = 30  -- Number of left-right movements

-- First Dash
local DASH1_DISTANCE = 3.0  -- Distance of first forward dash in studs
local DASH1_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH1_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH1_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during first dash

-- Wait Time Between Dashes
local WAIT_BETWEEN_DASHES = 1.0  -- Wait time between dashes (in seconds)

-- Second Dash
local DASH2_DISTANCE = 3.0  -- Distance of second forward dash in studs
local DASH2_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH2_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH2_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during second dash

-- Third Dash
local DASH3_DISTANCE = 3.0  -- Distance of third forward dash in studs
local DASH3_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH3_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH3_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during third dash

-- Visual Effects
local GLITCH_COLOR_PRIMARY = Color3.fromRGB(255, 255, 255)  -- White
local GLITCH_COLOR_SECONDARY = Color3.fromRGB(0, 0, 0)  -- Black

-- // --- ANIMATION IDs --- //
local DASH_ANIMATION_ID = "rbxassetid://131979551237806"  -- Dash animation ID

-- // --- SOUND IDs --- //
local SOUND_ID_DASH = "rbxassetid://3084314259"  -- Updated dash sound effect ID
local SOUND_ID_ACTIVATION = "rbxassetid://YOUR_ACTIVATION_SOUND_ID"  -- Activation sound ID (placeholder)
local SOUND_ID_LEFT_RIGHT = "rbxassetid://6896112317"  -- Left-right movement sound ID

-- Sound Properties
local DASH_SOUND_VOLUME = 5
local DASH_SOUND_LIFETIME = 2.0  -- How long before the sound is automatically destroyed
local LEFT_RIGHT_SOUND_VOLUME = 5  -- Volume for left-right movement sound

-- // --- END CONFIGURABLE VALUES --- //

-- // Button and UI Variables
local ABILITY_NAME_GR = "GlitchRush"
local BUTTON_NAME_GR = "custom"  -- As specified by user
local TIMER_TEXT_GR = "GLITCH RUSH"  -- As specified by user
local lastGlitchRushTime = 0
local glitchRushButton = nil
local isAbilityActive_GR = false

-- // Animation Variables
local dashAnimation = nil
local dashAnimTrack = nil

-- // Helper Functions
local function IsReady_GR() 
    return tick() - lastGlitchRushTime >= COOLDOWN_GR 
end

local function StartCooldown_GR()
    lastGlitchRushTime = tick()
    if glitchRushButton then
        local cooldownFrame = glitchRushButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local tweenInfo = TweenInfo.new(COOLDOWN_GR, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(uiGradient, tweenInfo, {Offset = Vector2.new(0, 1)})
                uiGradient.Offset = Vector2.new(0, 0)
                tween:Play()
            end
        end
    end
end

-- // Create and Play Sound Effect
local function CreateAndPlaySound(soundId, parent, volume, lifetime)
    -- Default values if not provided
    parent = parent or rootPart
    volume = volume or 1.0
    lifetime = lifetime or 2.0
    
    -- Validate parent
    if not parent or not parent:IsA("Instance") then
        warn("Sound Effect: Invalid parent for sound")
        return nil
    end
    
    -- Create sound instance
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume
    sound.Name = "AbilitySound_" .. tick()
    sound.Parent = parent
    
    -- Play the sound
    pcall(function()
        sound:Play()
        print("Sound Effect: Playing sound " .. soundId)
    end)
    
    -- Schedule cleanup if lifetime is provided
    if lifetime > 0 then
        Debris:AddItem(sound, lifetime)
    end
    
    return sound
end

-- // Create Looping Sound Effect
local function CreateLoopingSound(soundId, parent, volume)
    local sound = CreateAndPlaySound(soundId, parent, volume, 0) -- 0 lifetime means no auto-cleanup
    
    if sound then
        sound.Looped = true
    end
    
    return sound
end

-- // Stop and Clean Up Sound
local function StopAndCleanupSound(sound)
    if sound and sound.Parent then
        pcall(function()
            sound:Stop()
            sound:Destroy()
            print("Sound Effect: Stopped and cleaned up sound")
        end)
    end
end

-- // Preload Dash Animation
local function PreloadDashAnimation()
    -- Create animation object
    dashAnimation = Instance.new("Animation")
    dashAnimation.AnimationId = DASH_ANIMATION_ID
    
    -- Load animation on humanoid
    if humanoid then
        dashAnimTrack = humanoid:LoadAnimation(dashAnimation)
        
        -- Configure animation properties
        dashAnimTrack.Priority = Enum.AnimationPriority.Action
        dashAnimTrack.Looped = false
        
        -- Note: FadeTime is not a property of AnimationTrack
        -- Instead, we'll pass the fade time when playing the animation
        
        print("Glitch Rush: Dash animation preloaded successfully")
    else
        warn("Glitch Rush: Failed to preload dash animation - humanoid not found")
    end
end

-- // Get Player's Current Pointing Direction
local function GetPlayerPointingDirection(humanoid)
    -- First try to get direction from humanoid's MoveDirection
    if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
        return humanoid.MoveDirection.Unit
    end
    
    -- If not moving, use the direction the character is facing
    if rootPart then
        return rootPart.CFrame.LookVector
    end
    
    -- Fallback to camera direction if all else fails
    return Camera.CFrame.LookVector
end

-- // Perform smooth left-right movement for illusion effect
local function PerformLeftRightIllusion(rootPart, duration, frequency, distance, iterations)
    if not rootPart then return end
    
    -- Create and play the left-right movement sound (looping)
    local leftRightSound = CreateLoopingSound(SOUND_ID_LEFT_RIGHT, rootPart, LEFT_RIGHT_SOUND_VOLUME)
    
    local startTime = tick()
    local rightVector = rootPart.CFrame.RightVector -- Initial right vector for consistency
    
    -- Create a counter for iterations
    local iterationCount = 0
    local direction = 1  -- Start by moving right
    
    -- Create a connection to the heartbeat event for smooth movement
    local connection
    connection = RunService.Heartbeat:Connect(function()
        -- Check if we've exceeded the duration or iterations
        if (tick() - startTime > duration) or (iterationCount >= iterations) then
            if connection then
                connection:Disconnect()
                connection = nil
            end
            return
        end
        
        -- Only move at the frequency rate
        if (tick() - startTime) % frequency < 0.01 then
            -- Calculate movement offset - alternating left and right
            local sideOffset = rightVector * (direction * distance)
            
            -- Get current position and preserve Y value
            local currentPos = rootPart.Position
            local newPos = currentPos + sideOffset
            newPos = Vector3.new(newPos.X, currentPos.Y, newPos.Z)  -- Maintain Y position
            
            -- Move to the new position while maintaining current orientation
            local currentOrientation = rootPart.CFrame - rootPart.Position
            rootPart.CFrame = CFrame.new(newPos) * currentOrientation
            
            -- Flip direction for next movement
            direction = -direction
            iterationCount = iterationCount + 1
        end
    end)
    
    -- Wait for the illusion effect to complete
    task.wait(duration)
    
    -- Ensure connection is cleaned up
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    -- Stop and clean up the left-right movement sound
    StopAndCleanupSound(leftRightSound)
    
    -- No need to reset position - allow player to end up where they moved to
    return leftRightSound -- Return the sound reference in case we need to stop it early
end

-- // Perform anti-cheat safe forward dash
local function PerformAntiCheatSafeDash(rootPart, humanoid, direction, totalDistance, steps, stepDelay, speedMultiplier, isLastDash)
    if not rootPart or not direction or not humanoid then return end
    
    local stepDistance = totalDistance / steps
    local originalCFrame = rootPart.CFrame
    local originalWalkSpeed = humanoid.WalkSpeed
    
    -- Create a temporary speed boost effect
    humanoid.WalkSpeed = originalWalkSpeed * speedMultiplier
    
    -- Create a BodyVelocity for smoother movement
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(50000, 0, 50000)  -- Only apply force horizontally
    bodyVelocity.P = 1250  -- Adjust this for responsiveness
    bodyVelocity.Velocity = direction * (stepDistance / stepDelay) * 1.5  -- Slightly boost velocity for effect
    bodyVelocity.Parent = rootPart
    
    -- Play dash animation with fade time parameter
    if dashAnimTrack then
        dashAnimTrack:Play(0.1) -- 0.1 second fade time
        print("Glitch Rush: Playing dash animation")
    else
        -- Try to load animation if not already loaded
        PreloadDashAnimation()
        if dashAnimTrack then
            dashAnimTrack:Play(0.1) -- 0.1 second fade time
            print("Glitch Rush: Playing dash animation (after reload)")
        else
            warn("Glitch Rush: Failed to play dash animation - track not available")
        end
    end
    
    -- Play dash sound effect
    CreateAndPlaySound(SOUND_ID_DASH, rootPart, DASH_SOUND_VOLUME, DASH_SOUND_LIFETIME)
    
    -- Perform the forward dash in small steps to avoid anti-cheat detection
    for i = 1, steps do
        -- Calculate the new position
        local newPos = rootPart.Position + (direction * stepDistance)
        newPos = Vector3.new(newPos.X, rootPart.Position.Y, newPos.Z)  -- Maintain Y position
        
        -- Move to the new position while maintaining orientation
        rootPart.CFrame = CFrame.new(newPos) * CFrame.Angles(
            originalCFrame:ToOrientation()
        )
        
        -- Small wait between steps
        task.wait(stepDelay)
    end
    
    -- Clean up the BodyVelocity
    if bodyVelocity and bodyVelocity.Parent then
        bodyVelocity:Destroy()
    end
    
    -- Restore original walk speed
    humanoid.WalkSpeed = originalWalkSpeed
    
    -- Explicitly stop the animation if this is the last dash
    if isLastDash and dashAnimTrack then
        dashAnimTrack:Stop()
        print("Glitch Rush: Explicitly stopping dash animation after final dash")
    end
    -- Otherwise animation will stop automatically since it's not looped
end

-- // Main Glitch Rush Function
local function GlitchRush()
    if isAbilityActive_GR then 
        print("Glitch Rush: Ability already active.")
        return 
    end
    
    if not IsReady_GR() then 
        print("Glitch Rush: Ability on cooldown.")
        return 
    end
    
    -- Update character references
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    if not (humanoid and rootPart) then 
        print("Glitch Rush: Character components missing.")
        return 
    end
    
    -- VFX CODE START
    local effectDuration = 5 -- Duration in seconds before the effect disappears

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    if not RunService:IsClient() then return end

    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    local effectPart = Instance.new("Part")
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Parent = workspace

    -- Initial position - directly on the player
    local effectCFrame = humanoidRootPart.CFrame
    effectPart.CFrame = effectCFrame

    local function createFolderPath(parent, path)
        if not path or path == "" then return parent end
        
        local current = parent
        for _, name in ipairs(string.split(path, ".")) do
            local existing = current:FindFirstChild(name)
            if not existing then
                local new = Instance.new("Folder")
                new.Name = name
                new.Parent = current
                current = new
            else
                current = existing
            end
        end
        return current
    end

    local particles = {}

    do
        local particle = Instance.new("ParticleEmitter")
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.300000, 0.400000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(15.000000, 15.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.598806, 0.000000), NumberSequenceKeypoint.new(0.720159, 0.618750), NumberSequenceKeypoint.new(0.872679, 0.925000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 15
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.001000, 0.001000)
        particle.Brightness = 3
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 4.043619), NumberSequenceKeypoint.new(0.200000, 5.333644), NumberSequenceKeypoint.new(0.300000, 6.164438), NumberSequenceKeypoint.new(0.400000, 6.753995), NumberSequenceKeypoint.new(0.500000, 7.186415), NumberSequenceKeypoint.new(0.600000, 7.504354), NumberSequenceKeypoint.new(0.700000, 7.732507), NumberSequenceKeypoint.new(0.800000, 7.886009), NumberSequenceKeypoint.new(0.900000, 7.973793), NumberSequenceKeypoint.new(1.000000, 8.000000), NumberSequenceKeypoint.new(1.000000, 8.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(480.000000, 720.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 25
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://12050306299"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = -4

        particle.Parent = parent
        table.insert(particles, particle)
    end

    do
        local particle = Instance.new("ParticleEmitter")
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.400000, 0.600000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(15.000000, 15.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(0.199602, 0.531250), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 15
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.001000, 0.001000)
        particle.Brightness = 1
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 3.538166), NumberSequenceKeypoint.new(0.200000, 4.666938), NumberSequenceKeypoint.new(0.300000, 5.393883), NumberSequenceKeypoint.new(0.400000, 5.909746), NumberSequenceKeypoint.new(0.500000, 6.288113), NumberSequenceKeypoint.new(0.600000, 6.566310), NumberSequenceKeypoint.new(0.700000, 6.765944), NumberSequenceKeypoint.new(0.800000, 6.900258), NumberSequenceKeypoint.new(0.900000, 6.977068), NumberSequenceKeypoint.new(1.000000, 7.000000), NumberSequenceKeypoint.new(1.000000, 7.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(480.000000, 720.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 20
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "http://www.roblox.com/asset/?id=121270653244867"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0

        particle.Parent = parent
        table.insert(particles, particle)
    end

    do
        local particle = Instance.new("ParticleEmitter")
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.500000, 0.800000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(90.000000, 90.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.Drag = 10
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 90
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(20.000000, 50.000000)
        particle.Brightness = 1
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.400000, 0.600000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 30
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "http://www.roblox.com/asset/?id=71165508990372"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Disc
        particle.LightEmission = 0

        particle.Parent = parent
        table.insert(particles, particle)
    end

    do
        local particle = Instance.new("ParticleEmitter")
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.400000, 0.500000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
        particle.SpreadAngle = Vector2.new(360.000000, 360.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(3.000000, 8.000000)
        particle.Brightness = 1
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 2.527262), NumberSequenceKeypoint.new(0.200000, 3.333527), NumberSequenceKeypoint.new(0.300000, 3.852774), NumberSequenceKeypoint.new(0.400000, 4.221247), NumberSequenceKeypoint.new(0.500000, 4.491509), NumberSequenceKeypoint.new(0.600000, 4.690222), NumberSequenceKeypoint.new(0.700000, 4.832817), NumberSequenceKeypoint.new(0.800000, 4.928756), NumberSequenceKeypoint.new(0.900000, 4.983620), NumberSequenceKeypoint.new(1.000000, 5.000000), NumberSequenceKeypoint.new(1.000000, 5.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 70
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://14201241100"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0

        particle.Parent = parent
        table.insert(particles, particle)
    end

    for _, particle in ipairs(particles) do
        particle.Enabled = true
    end

    -- Store the maximum lifetime for cleanup
    local maxLifetime = 0
    for _, particle in ipairs(particles) do
        maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
    end

    -- Client-side update loop to make the effect follow the player
    local startTime = tick()
    local connection

    -- Function to properly clean up everything
    local function cleanupEffect()
        -- Disconnect the update connection if it exists
        if connection then
            connection:Disconnect()
            connection = nil
        end
        
        -- Disable all particles
        for _, particle in ipairs(particles) do
            if particle and particle.Parent then
                particle.Enabled = false
            end
        end
        
        -- Destroy the effect part after a short delay to let particles fade
        task.delay(maxLifetime + 0.5, function()
            if effectPart and effectPart.Parent then
                effectPart:Destroy()
            end
        end)
    end

    -- Set up the connection
    connection = RunService.RenderStepped:Connect(function()
        -- Check if the timer has expired
        if tick() - startTime >= effectDuration then
            cleanupEffect()
            return
        end
        
        -- Update position to follow the player exactly
        if humanoidRootPart and humanoidRootPart.Parent then
            effectPart.CFrame = humanoidRootPart.CFrame
        else
            -- If the humanoidRootPart is gone, clean up
            cleanupEffect()
        end
    end)

    -- Safety cleanup in case the script is terminated
    game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
        cleanupEffect()
    end)
    -- VFX CODE END
    
    -- Play the movement animation when button is clicked
    if not movementAnimTrack then
        movementAnimTrack = humanoid:LoadAnimation(movementAnimation)
    end
    
    if movementAnimTrack then
        movementAnimTrack:Play()
        
        -- Stop the animation after 2 seconds
        task.delay(4, function()
            if movementAnimTrack and movementAnimTrack.IsPlaying then
                movementAnimTrack:Stop()
            end
        end)
    end
    
    isAbilityActive_GR = true
    StartCooldown_GR()
    print(ABILITY_NAME_GR .. " Activated")
    
    -- Play activation sound if provided
    if SOUND_ID_ACTIVATION ~= "rbxassetid://YOUR_ACTIVATION_SOUND_ID" then
        CreateAndPlaySound(SOUND_ID_ACTIVATION, rootPart, 1.0, 2.0)
    end
    
    -- Start the ability execution in a separate thread
    task.spawn(function()
        local currentCharacter, currentRootPart, currentHumanoid = character, rootPart, humanoid
        local cleanupGuard = Instance.new("BoolValue", currentCharacter)
        cleanupGuard.Name = "GlitchRushCleanupGuard"
        
        local function performCleanupAndReset()
            if not cleanupGuard or not cleanupGuard.Parent then return end
            cleanupGuard:Destroy()
            isAbilityActive_GR = false
            print("Glitch Rush: Ability finished and cleaned up.")
        end
        
        local pcallSuccess, pcallResult = pcall(function()
            -- Perform the left-right illusion effect
            PerformLeftRightIllusion(
                currentRootPart, 
                GLITCH_DURATION, 
                GLITCH_FREQUENCY, 
                GLITCH_DISTANCE, 
                GLITCH_ITERATIONS
            )
            
            -- Get the current pointing direction for first dash
            local pointingDirection = GetPlayerPointingDirection(currentHumanoid)
            
            -- Perform first anti-cheat safe dash (not the last dash)
            PerformAntiCheatSafeDash(
                currentRootPart,
                currentHumanoid,
                pointingDirection,
                DASH1_DISTANCE,
                DASH1_STEPS,
                DASH1_STEP_DELAY,
                DASH1_SPEED_MULTIPLIER,
                false -- not the last dash
            )
            
            -- Wait between first and second dashes
            print("Glitch Rush: Waiting between first and second dashes...")
            task.wait(WAIT_BETWEEN_DASHES)
            
            -- Get the current pointing direction again for second dash
            -- This allows the player to change direction during the wait
            pointingDirection = GetPlayerPointingDirection(currentHumanoid)
            
            -- Perform second anti-cheat safe dash (not the last dash)
            PerformAntiCheatSafeDash(
                currentRootPart,
                currentHumanoid,
                pointingDirection,
                DASH2_DISTANCE,
                DASH2_STEPS,
                DASH2_STEP_DELAY,
                DASH2_SPEED_MULTIPLIER,
                false -- not the last dash
            )
            
            -- Wait between second and third dashes
            print("Glitch Rush: Waiting between second and third dashes...")
            task.wait(WAIT_BETWEEN_DASHES)
            
            -- Get the current pointing direction again for third dash
            -- This allows the player to change direction during the wait
            pointingDirection = GetPlayerPointingDirection(currentHumanoid)
            
            -- Perform third anti-cheat safe dash (this is the last dash)
            PerformAntiCheatSafeDash(
                currentRootPart,
                currentHumanoid,
                pointingDirection,
                DASH3_DISTANCE,
                DASH3_STEPS,
                DASH3_STEP_DELAY,
                DASH3_SPEED_MULTIPLIER,
                true -- this is the last dash, stop animation after
            )
            
            -- Short wait to ensure movement completes
            task.wait(0.2)
        end)
        
        if not pcallSuccess then
            warn("Glitch Rush Error: " .. tostring(pcallResult))
            -- Ensure walkspeed is restored even if there's an error
            if currentHumanoid and currentHumanoid.Parent then
                currentHumanoid.WalkSpeed = currentHumanoid.WalkSpeed > 0 and currentHumanoid.WalkSpeed or 16
            end
            
            -- Ensure animation is stopped if there's an error
            if dashAnimTrack then
                dashAnimTrack:Stop()
            end
        end
        
        performCleanupAndReset()
    end)
end

-- // Clone Button Using Exact Path
local function CloneButtonUsingExactPath()
    -- Use the exact path provided by the user
    local sourceButton = player.PlayerGui.InGameUI.Bottom.Abilities["1"]
    
    if not sourceButton then
        warn("Source button not found at specified path. Keybind will still work.")
        return nil
    end
    
    print("Cloning button from exact path: " .. sourceButton:GetFullName())
    
    -- Clone the button
    local clonedButton = sourceButton:Clone()
    clonedButton.Name = BUTTON_NAME_GR  -- "custom" as specified by user
    
    -- Update the Timer text to "GLITCH RUSH" as specified by user
    local timerText = clonedButton:FindFirstChild("Timer")
    if timerText and timerText:IsA("TextLabel") then
        timerText.Text = TIMER_TEXT_GR
    end
    
    -- Reset cooldown if there's a cooldown frame
    local cooldownFrame = clonedButton:FindFirstChild("Cooldown")
    if cooldownFrame then
        local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
        if uiGradient then
            uiGradient.Offset = Vector2.new(0, 1) -- Reset cooldown
        end
    end
    
    -- Update colors to black and white theme
    for _, child in pairs(clonedButton:GetDescendants()) do
        if child:IsA("Frame") or child:IsA("ImageButton") or child:IsA("TextButton") then
            -- Skip cooldown frames
            if child.Name ~= "Cooldown" then
                child.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            end
        end
        
        if child:IsA("UIGradient") and child.Parent.Name ~= "Cooldown" then
            child.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
            })
        end
        
        if child:IsA("UIStroke") then
            child.Color = Color3.fromRGB(255, 255, 255)
        end
    end
    
    -- Connect the button click
    local clickDetector = clonedButton:FindFirstChildOfClass("TextButton") or clonedButton
    if clickDetector and clickDetector:IsA("GuiButton") then
        clickDetector.MouseButton1Click:Connect(GlitchRush)
    end
    
    -- Add to the same parent as the source button
    clonedButton.Parent = sourceButton.Parent
    
    return clonedButton
end

-- // PC Keybind Setup
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == ABILITY_KEY_GR then
        GlitchRush()
    end
end)

-- // Handle character changes
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    -- Reload animation for new character
    PreloadDashAnimation()
    print("Glitch Rush: Character changed, animations reloaded")
end)

-- // Initialize
local function Initialize()
    print("Initializing Glitch Rush ability...")
    
    -- Preload dash animation
    PreloadDashAnimation()
    
    glitchRushButton = CloneButtonUsingExactPath()
    if glitchRushButton then
        print("Glitch Rush button created successfully!")
    else
        warn("Failed to create Glitch Rush button, but keybind will still work")
    end
    print("Glitch Rush initialized!")
end

Initialize()
-- V11
--[[
    Style Name: EGO JINPANCHI (Concept)
    Ability: TRAUMATIZED SHOOT - Standalone Test V26 (Lift/Freeze + Goal Target + Speed 650) -> V11 Mod
    Creator: Gemini (Restoring Confirmed Working Version, Modified by Manus)
    Version: V11 - Added robust post-shot ball physics cleanup to fix goal glitch.
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10)

-- // Remote Event Acquisition (Direct Path First)
local ShootRemote = nil
local function findShootRemoteStandardPath() print("Attempting Standard Path...") local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil;if p then k=p:FindFirstChild("Knit",5)end;if k then s=k:FindFirstChild("Services",5)end;if s then b=s:FindFirstChild("BallService",5)end;if b then r=b:FindFirstChild("RE",5)end;local remote=r and r:FindFirstChild("Shoot",5);if remote and remote:IsA("RemoteEvent")then print("ShootRemote FOUND via Standard Path:",remote);return remote else warn("ShootRemote NOT found via Standard Path!");return nil end end
ShootRemote = findShootRemoteStandardPath()
if not ShootRemote then warn("!!! CRITICAL: ShootRemote could not be located. Ability may fail. !!!") end

-- // Ability Settings
local ABILITY_NAME = "TraumatizedShoot"
local ABILITY_KEY = Enum.KeyCode.X -- Using X for this test script
local COOLDOWN = 1
local BUTTON_NAME = "TraumatizedShootButton"
local TIMER_TEXT = "Traumatized Shoot"
local LAYOUT_ORDER = 2

-- // Modifiable Parameters (V11)
local ANIMATION_ID = "rbxassetid://83474010887370" -- Animation to play on activation
local KICK_VFX_DURATION = 2.5 -- How long the kick VFX lasts (seconds)
local BALL_SPEED = 300 -- Speed of the ball after the freeze (Confirmed V4)
local BALL_LIFT_FORCE = 100000 -- Controls the force/speed of the ball lift (BodyPosition P value) (Adjusted V4)
local SOUND_ID_TRAUMA_SHOOT = "rbxassetid://18893204466" -- SFX ID (Updated V4)
local BALL_CIRCLE_VFX_DURATION = 4.5 -- How long the black circle VFX on the ball lasts (seconds) (Added V5)
local NEWEST_BALL_VFX_DURATION = 5.0 -- Duration for the newest V10 ball VFX (White/Black from user)
local BALL_VELOCITY_CLEANUP_TIME = 0.75 -- Time after shot before BodyVelocity is removed (Adjusted V7 for physics bug)
local POST_SHOT_PHYSICS_CLEANUP_DELAY = BALL_VELOCITY_CLEANUP_TIME + 0.1 -- V11: Delay before forceful physics cleanup

-- // Cooldown Tracking
local lastTraumaShootTime = 0

-- // Helper Functions
local function IsReady() return tick()-lastTraumaShootTime>=COOLDOWN end;local function StartCooldown() lastTraumaShootTime=tick() end;
-- V7.1: SFX Fix Attempt 3: Parent *then* set ID/Play.
local function playSound(id, p)
    if not id or id == "rbxassetid://SOUND_ID_HERE" or not p or not p.Parent then
        print("SFX Skipped (Placeholder or invalid Parent)")
        return
    end
    local s = Instance.new("Sound")
    s.Name = "TraumaShootSFX_Temp"
    s.Volume = 2
    s.Parent = p -- Parent first to ensure it exists in the world
    s.SoundId = id -- Set ID after parenting
    s:Play() -- Play immediately
    print("Playing SFX Attempt (V7.1):", id, "Parented to:", p:GetFullName())

    -- Schedule cleanup using Debris
    task.delay(0.1, function()
        if s and s.Parent then
            local duration = s.TimeLength
            if duration <= 0 then duration = 3 end -- Fallback duration
            print("SFX Cleanup Scheduled. Duration:", duration)
            Debris:AddItem(s, duration + 0.5)
        end
    end)
end
local function shakeCamera(i,d)if not Camera or not Camera.Parent then return end;local o=Camera.CFrame;local e=0;local h=RunService.Heartbeat;local c;local function s()if c and c.Connected then if Camera and Camera.Parent then Camera.CFrame=o end c:Disconnect();c=nil end end;c=h:Connect(function(t)e=e+t;if e<d then local f=CFrame.new((math.random()*2-1)*i/100,(math.random()*2-1)*i/100,(math.random()*2-1)*i/100)*CFrame.Angles(math.rad((math.random()*2-1)*i*0.1),math.rad((math.random()*2-1)*i*0.1),math.rad((math.random()*2-1)*i*0.1));if Camera and Camera.Parent then Camera.CFrame=o*f else s()end else s()end end);task.delay(d+0.1,s)end;local homeGoalPos=Vector3.new(325,15,-49);local awayGoalPos=Vector3.new(-247,15,-50);local function getOpponentGoalPos()local t=player.Team;if t then if t.Name=="Home"then return awayGoalPos elseif t.Name=="Away"then return homeGoalPos end end;warn("NoOppGoal");return nil end;
local function findBall()local f=Workspace:FindFirstChild("Football");if f then local b=(f:FindFirstChild("BallAnims")and f.BallAnims:FindFirstChild("BALL"))or f:FindFirstChild("BALL");if b and b:IsA("BasePart")then return b elseif f:IsA("Model")and f.PrimaryPart then return f.PrimaryPart elseif f:IsA("BasePart")then return f end end; warn("findBall: Could not find Football in Workspace"); return nil end
local function playerHasBall() character=player.Character;if not character then return false end;local v=character:FindFirstChild("Values");local h=v and v:FindFirstChild("HasBall");return h and h.Value==true end

-- // V11: Robust Ball Physics Cleanup Function
local function cleanupBallPhysics(ballInstance)
    if not ballInstance or not ballInstance.Parent or not ballInstance:IsA("BasePart") then
        print("CleanupBallPhysics: Ball instance invalid or missing.")
        return
    end
    print("CleanupBallPhysics: Running cleanup on", ballInstance:GetFullName())
    -- Remove all BodyMovers
    for _, child in ipairs(ballInstance:GetChildren()) do
        if child:IsA("BodyMover") or child:IsA("BodyGyro") then
            print("CleanupBallPhysics: Destroying", child.Name)
            pcall(child.Destroy, child)
        end
    end
    -- Reset Velocities
    if ballInstance:IsA("BasePart") then
        pcall(function()
            ballInstance.Velocity = Vector3.zero
            ballInstance.RotVelocity = Vector3.zero
            print("CleanupBallPhysics: Velocities reset.")
        end)
    end
end

-- // VFX Function (V1 - Based on 'the best kick vfx.txt') - UNCHANGED
local function playKickVFX(targetPart, duration)
    if not targetPart or not targetPart.Parent then warn("Kick VFX Target Part invalid."); return end
    local RunService = game:GetService("RunService"); local Debris = game:GetService("Debris")
    if not RunService:IsClient() then return end
    local vfxContainer = Instance.new("Attachment"); vfxContainer.Name = "BestKickVFX_Temp"; vfxContainer.Parent = targetPart
    local particles = {}
    -- Emitter 1 (White Streaks)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0.8;p.Brightness=10;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.Lifetime=NumberRange.new(0.2,0.35);p.SpreadAngle=Vector2.new(360,360);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=10;p.Speed=NumberRange.new(400,600);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.17266,7.764939),NumberSequenceKeypoint.new(1,0)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(90,90);p.Texture="rbxassetid://13386858482";p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 2 (Black Swirl)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0,0,0));p.LightEmission=0;p.Brightness=0;p.Lifetime=NumberRange.new(0.25,0.35);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(50,50);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Speed=NumberRange.new(0.1,0.1);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(-360,360);p.Texture="rbxassetid://13395479051";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 3 (Dark Gray Wisps)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0.1;p.Lifetime=NumberRange.new(0.15,0.35);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(5,5);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Speed=NumberRange.new(0.1,0.1);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(-360,360);p.Texture="rbxassetid://13395481373";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 4 (White Flash)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=1;p.Brightness=10;p.Lifetime=NumberRange.new(0.05,0.05);p.SpreadAngle=Vector2.new(360,360);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.30137,0.475),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.FacingCamera;p.Drag=5;p.Speed=NumberRange.new(0,0);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,13.051071),NumberSequenceKeypoint.new(1,101.363541)});p.Enabled=false;p.ZOffset=3;p.Rate=32;p.Texture="rbxassetid://11503727043";p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 5 (Alternating B&W Swirl)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new({ColorSequenceKeypoint.new(0.0,Color3.new(0,0,0)),ColorSequenceKeypoint.new(0.5,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1.0,Color3.new(0,0,0))});p.LightEmission=0.5;p.Brightness=4;p.Lifetime=NumberRange.new(0.25,0.35);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(50,50);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Speed=NumberRange.new(0.1,0.1);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(-360,360);p.Texture="rbxassetid://13395479051";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    for _,p in ipairs(particles) do p.Enabled=true;p:Emit(p.Rate*0.1) end
    local function cleanup() if vfxContainer and vfxContainer.Parent then Debris:AddItem(vfxContainer,0.1) end end
    task.delay(duration,cleanup); print("Kick VFX Playing for",duration,"seconds")
end

-- // VFX Function (V5 - Black Circle on Ball) - UNCHANGED
local function playBallCircleVFX(targetBall, duration)
    if not targetBall or not targetBall.Parent or not targetBall:IsA("BasePart") then warn("Ball Circle VFX Target invalid."); return end
    local Debris = game:GetService("Debris"); if not RunService:IsClient() then return end
    local attachment = Instance.new("Attachment"); attachment.Name = "BallCircleVFXAttachment"; attachment.Parent = targetBall
    local emitter = Instance.new("ParticleEmitter"); emitter.Color = ColorSequence.new(Color3.fromRGB(0,0,0)); emitter.LightEmission = 0; emitter.LightInfluence = 0
    emitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8),NumberSequenceKeypoint.new(0.1,0.2),NumberSequenceKeypoint.new(0.8,0.2),NumberSequenceKeypoint.new(1,1)})
    emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,targetBall.Size.X*0.8),NumberSequenceKeypoint.new(1,targetBall.Size.X*1.1)})
    emitter.Texture = "rbxassetid://286198181"; emitter.Lifetime = NumberRange.new(duration); emitter.Rate = 0; emitter.Speed = NumberRange.new(0)
    emitter.Rotation = NumberRange.new(0); emitter.RotSpeed = NumberRange.new(0); emitter.SpreadAngle = Vector2.new(0,0); emitter.LockedToPart = true; emitter.Parent = attachment
    emitter:Emit(1); print("Ball Circle VFX Playing for",duration,"seconds")
    Debris:AddItem(attachment,duration+0.5)
end

-- // VFX Function (V10 - Newest Ball VFX - White/Black from User) - UNCHANGED
local function playNewestBallVFX_V10(targetBall, duration)
    if not targetBall or not targetBall.Parent or not targetBall:IsA("BasePart") then warn("Newest Ball VFX (V10) Target invalid."); return end
    local Debris = game:GetService("Debris"); if not RunService:IsClient() then return end
    print("Newest Ball VFX (V10 - White/Black): Applying directly to ball: ", targetBall)
    local vfxContainer = Instance.new("Attachment") -- Use an attachment for better organization
    vfxContainer.Name = "NewestBallVFX_V10_Container"
    vfxContainer.Parent = targetBall
    local particles = {}
    local maxLifetime = 0

    -- Emitter 1 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.5, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4; particle.SpreadAngle = Vector2.new(0, 0)
        particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 0; particle.Speed = NumberRange.new(0.000589, 0.000589); particle.Brightness = 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,5.77432),NumberSequenceKeypoint.new(0.2,8.171552),NumberSequenceKeypoint.new(0.3,9.606454),NumberSequenceKeypoint.new(0.4,10.565664),NumberSequenceKeypoint.new(0.5,11.232748),NumberSequenceKeypoint.new(0.6,11.698775),NumberSequenceKeypoint.new(0.7,12.016293),NumberSequenceKeypoint.new(0.8,12.218694),NumberSequenceKeypoint.new(0.9,12.328683),NumberSequenceKeypoint.new(1,12.36249),NumberSequenceKeypoint.new(1,12.36249)})
        particle.Enabled = false; particle.Rate = 50; particle.Rotation = NumberRange.new(-180, 180)
        particle.Texture = "rbxassetid://16945167413"; particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Bottom; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end
    -- Emitter 2 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(2.0, 3.0); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.SpreadAngle = Vector2.new(60, 60); particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.697802, 0), NumberSequenceKeypoint.new(1, 1)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 5; particle.Speed = NumberRange.new(30, 60); particle.Brightness = 1
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,1.7099),NumberSequenceKeypoint.new(0.2,2.166639),NumberSequenceKeypoint.new(0.3,2.427823),NumberSequenceKeypoint.new(0.4,2.592945),NumberSequenceKeypoint.new(0.5,2.700423),NumberSequenceKeypoint.new(0.6,2.769974),NumberSequenceKeypoint.new(0.7,2.813374),NumberSequenceKeypoint.new(0.8,2.838381),NumberSequenceKeypoint.new(0.9,2.850478),NumberSequenceKeypoint.new(1,2.85376),NumberSequenceKeypoint.new(1,2.85376)})
        particle.Enabled = false; particle.Acceleration = Vector3.new(0, -2.548, 0); particle.RotSpeed = NumberRange.new(-50, 50)
        particle.ZOffset = -0.25; particle.Rate = 50; particle.Texture = "rbxassetid://16947460137"
        particle.EmissionDirection = Enum.NormalId.Top; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end
    -- Emitter 3 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.5, 1.0); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4; particle.SpreadAngle = Vector2.new(15, 15)
        particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 0; particle.Speed = NumberRange.new(0.060655, 0.060655); particle.Brightness = 2
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,8.49594),NumberSequenceKeypoint.new(0.2,11.846502),NumberSequenceKeypoint.new(0.3,14.338069),NumberSequenceKeypoint.new(0.4,16.37779),NumberSequenceKeypoint.new(0.5,18.122572),NumberSequenceKeypoint.new(0.6,19.651741),NumberSequenceKeypoint.new(0.7,21.010811),NumberSequenceKeypoint.new(0.8,22.226871),NumberSequenceKeypoint.new(0.9,23.313662),NumberSequenceKeypoint.new(1,24.262056)})
        particle.Enabled = false; particle.ZOffset = -0.5; particle.Rate = 30; particle.Rotation = NumberRange.new(-180, 180)
        particle.Texture = "rbxassetid://11845281419"; particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end
    -- Emitter 4 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.3, 0.3); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.SpreadAngle = Vector2.new(15, 15); particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
        particle.Orientation = Enum.ParticleOrientation.FacingCameraWorldUp
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 0; particle.Speed = NumberRange.new(0.054063, 0.054063); particle.Brightness = 3
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.369222),NumberSequenceKeypoint.new(0.112008,28.703405),NumberSequenceKeypoint.new(0.212008,26.77071),NumberSequenceKeypoint.new(0.284008,19.307825),NumberSequenceKeypoint.new(0.374008,10.027058),NumberSequenceKeypoint.new(0.5,4.2237),NumberSequenceKeypoint.new(0.6,2.741823),NumberSequenceKeypoint.new(0.7,1.619671),NumberSequenceKeypoint.new(0.8,0.799958),NumberSequenceKeypoint.new(0.9,0.253642),NumberSequenceKeypoint.new(1,0)})
        particle.Enabled = false; particle.RotSpeed = NumberRange.new(300, 300); particle.ZOffset = 2; particle.Rate = 50
        particle.Rotation = NumberRange.new(20, 20); particle.Texture = "rbxassetid://16705963962"
        particle.EmissionDirection = Enum.NormalId.Front; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0.1
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end
    -- Emitter 5 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.6, 0.6); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4; particle.SpreadAngle = Vector2.new(360, 360)
        particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.697802, 0), NumberSequenceKeypoint.new(1, 1)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 0; particle.Speed = NumberRange.new(0.010192, 0.010192); particle.Brightness = 3
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,6.424152),NumberSequenceKeypoint.new(0.2,8.957657),NumberSequenceKeypoint.new(0.3,10.84164),NumberSequenceKeypoint.new(0.4,12.383964),NumberSequenceKeypoint.new(0.5,13.703268),NumberSequenceKeypoint.new(0.6,14.859538),NumberSequenceKeypoint.new(0.7,15.887191),NumberSequenceKeypoint.new(0.8,16.806709),NumberSequenceKeypoint.new(0.9,17.628477),NumberSequenceKeypoint.new(1,18.345602)})
        particle.Enabled = false; particle.ZOffset = -0.1; particle.Rate = 50; particle.Rotation = NumberRange.new(-180, 180)
        particle.Texture = "rbxassetid://16945488960"; particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end

    -- Enable all particles
    for _, particle in ipairs(particles) do
        particle.Enabled = true
        particle:Emit(particle.Rate * 0.1) -- Emit a small burst
    end

    -- Cleanup based on provided duration
    task.delay(duration, function()
        print("Cleaning up Newest Ball VFX (V10)")
        if vfxContainer and vfxContainer.Parent then
            for _, p in ipairs(vfxContainer:GetChildren()) do
                if p:IsA("ParticleEmitter") then p.Enabled = false end
            end
            Debris:AddItem(vfxContainer, maxLifetime + 1) -- Destroy attachment after particles fade
        end
    end)
    print("Newest Ball VFX (V10) Playing for", duration, "seconds")
end

-- // Ability Function: TRAUMATIZED SHOOT (V11 Mod - Physics Fix)
local function TraumatizedShoot()
    if not IsReady() then print(ABILITY_NAME .. " on CD") return end
    character=player.Character or player.CharacterAdded:Wait(); humanoid=character:WaitForChild("Humanoid"); rootPart=character:WaitForChild("HumanoidRootPart"); playerValues=character:WaitForChild("Values",10); if not (humanoid and rootPart and playerValues) then warn("TS: Player components missing.");return end;
    local hasBallValue = playerValues:FindFirstChild("HasBall");
    if not hasBallValue or not hasBallValue.Value then warn("TS: No ball.");return end

    if not ShootRemote then warn("TS: ShootRemote missing!"); return end

    StartCooldown()

    -- Play Animation (V1) - UNCHANGED
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then animator = Instance.new("Animator", humanoid) end
    local anim = Instance.new("Animation"); anim.AnimationId = ANIMATION_ID
    local track = animator:LoadAnimation(anim)
    if track then track:Play(); print("Playing Animation:", ANIMATION_ID); Debris:AddItem(anim, track.Length + 0.1)
    else warn("Failed to load animation track for", ANIMATION_ID); if anim then anim:Destroy() end end

    -- Play SFX (V7.1 - Parent First Attempt) - UNCHANGED
    playSound(SOUND_ID_TRAUMA_SHOOT, rootPart)

    -- Play Kick VFX (V1) - UNCHANGED
    playKickVFX(rootPart, KICK_VFX_DURATION)

    -- Camera Shake (V2) - UNCHANGED
    shakeCamera(50, 0.5)

    -- 1. Detach ball
    ShootRemote:FireServer(1); print("Fired ShootRemote (Power 1) to detach ball")

    -- 2. Lift/Freeze Ball & Play Ball VFX (V10 - Newest Ball VFX)
    task.spawn(function()
        local ballInWorkspace = nil; local findStart = tick(); local findTimeout = 2.0
        print("TS: Starting post-shot ball search...")
        repeat
            task.wait(0.05); ballInWorkspace = findBall()
            local initialBallOnPlayer = character and character:FindFirstChild("BALL")
            if not ballInWorkspace and initialBallOnPlayer and initialBallOnPlayer.Parent == Workspace then ballInWorkspace = initialBallOnPlayer end
        until ballInWorkspace or (tick() - findStart > findTimeout)

        if not ballInWorkspace then warn("TS: Ball not found in Workspace timeout."); return end
        if not ballInWorkspace:IsA("BasePart") then warn("TS: Found ball is not BasePart!"); return end

        -- Play Ball Circle VFX (V5) - UNCHANGED
        playBallCircleVFX(ballInWorkspace, BALL_CIRCLE_VFX_DURATION)
        -- Play Newest Ball VFX (V10 - White/Black from User) - UNCHANGED
        playNewestBallVFX_V10(ballInWorkspace, NEWEST_BALL_VFX_DURATION)

        print("TS: Applying lift/freeze:", ballInWorkspace:GetFullName())
        -- V11: Clean existing movers *before* applying new ones
        cleanupBallPhysics(ballInWorkspace)

        ballInWorkspace.Anchored = false

        local liftHeight = 30; local freezeDuration = 0.5;
        local targetLiftPos = ballInWorkspace.Position + Vector3.new(0, liftHeight, 0);
        local bp = Instance.new("BodyPosition"); bp.MaxForce = Vector3.new(1e7, 1e7, 1e7); bp.P = BALL_LIFT_FORCE; bp.D = 2500; bp.Position = targetLiftPos; bp.Parent = ballInWorkspace
        print("Lift/Freeze BodyPosition applied with Force (P):", BALL_LIFT_FORCE)

        task.wait(freezeDuration)

        local goalPosition = getOpponentGoalPos()
        if not goalPosition then warn("TS: Couldn't get goal position."); if bp and bp.Parent then pcall(bp.Destroy,bp) end return end
        if not ballInWorkspace or not ballInWorkspace.Parent or not bp or not bp.Parent then warn("TS: Ball or BP lost during freeze."); if bp and bp.Parent then pcall(bp.Destroy,bp) end return end

        local currentBallPos = ballInWorkspace.Position; pcall(bp.Destroy,bp); print("Removed BodyPosition")
        local shootDirection = (goalPosition - currentBallPos).Unit; local shootSpeed = BALL_SPEED
        local bv = Instance.new("BodyVelocity"); bv.MaxForce = Vector3.new(math.huge,math.huge,math.huge); bv.Velocity = shootDirection * shootSpeed; bv.Parent = ballInWorkspace
        print("Applied BodyVelocity towards goal with speed:", shootSpeed)

        -- V11: Schedule robust physics cleanup after the shot velocity has had time to act
        local ballRef = ballInWorkspace -- Keep a reference to the ball
        task.delay(POST_SHOT_PHYSICS_CLEANUP_DELAY, function()
            print("V11: Attempting delayed physics cleanup.")
            cleanupBallPhysics(ballRef) -- Use the reference
        end)

        -- Original Debris cleanup for the *specific* BodyVelocity applied for the shot (still useful as a primary cleanup)
        Debris:AddItem(bv, BALL_VELOCITY_CLEANUP_TIME)
        print("BodyVelocity Debris cleanup scheduled in:", BALL_VELOCITY_CLEANUP_TIME, "seconds")
    end)
    print("Traumatized Shoot Activated (V11 Mod)")
end

-- // --- UI Setup for ONLY Traumatized Shoot --- (No Changes Here)
local traumaShootButton = nil
local function setupSingleButtonUI()
    local playerGui=player:WaitForChild("PlayerGui");local inGameUI=playerGui:WaitForChild("InGameUI",15);if not inGameUI then warn("No InGameUI");return end;local bottom=inGameUI:WaitForChild("Bottom",10);if not bottom then warn("No Bottom");return end;local bottomAbilities=bottom:WaitForChild("Abilities",10);if not bottomAbilities then warn("No Abilities Frame");return end;local templateButton=bottomAbilities:WaitForChild("1", 5)or bottomAbilities:FindFirstChildWhichIsA("ImageButton");if not templateButton then warn("No Template Button");return end
    local oldBtn=bottomAbilities:FindFirstChild(BUTTON_NAME);if oldBtn then oldBtn:Destroy();task.wait(0.1)end;local b=nil;local s=pcall(function()b=templateButton:Clone()end);if not s or not b then warn("Clone fail");return end;b.Name=BUTTON_NAME;b.Parent=bottomAbilities;b.LayoutOrder=LAYOUT_ORDER;local kL=b:WaitForChild("Keybind",2)or b:FindFirstChildWhichIsA("TextLabel",true);local tL=b:WaitForChild("Timer",2)or b:FindFirstChild("AbilityName",true)or b:FindFirstChildWhichIsA("TextLabel",true);local aTL=b:FindFirstChild("ActualTimer",true);if kL and kL:IsA("TextLabel")then pcall(function()kL.Text=ABILITY_KEY.Name end)else warn("KeybindLbl Missing")end;if tL and tL:IsA("TextLabel")then pcall(function()tL.Text=TIMER_TEXT end)else warn("TimerLbl Missing")end;if aTL and aTL:IsA("TextLabel")then pcall(function()aTL.Text=""end)end;local cV=b:FindFirstChild("Cooldown")or b:FindFirstChild("cooldown");if cV then cV:Destroy()end;local aF=b:FindFirstChild("Ability")or b;if aF and aF:IsA("GuiObject")then local cF=Instance.new("Frame");cF.Name="Cooldown";cF.BackgroundColor3=Color3.fromRGB(0,0,0);cF.BackgroundTransparency=0.6;cF.BorderSizePixel=0;cF.Size=UDim2.new(1,0,1,0);cF.Position=UDim2.new(0,0,1,0);cF.AnchorPoint=Vector2.new(0,1);cF.ZIndex=(aF.ZIndex or 1)+1;cF.Parent=aF;local uC=Instance.new("UICorner",cF);local aS=aF.AbsoluteSize;local r=math.max(1,math.min(aS.X,aS.Y)*0.15);uC.CornerRadius=UDim.new(0,r);aF:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()pcall(function()if not uC or not uC.Parent then return end;local nS=aF.AbsoluteSize;local nR=math.max(1,math.min(nS.X,nS.Y)*0.15);uC.CornerRadius=UDim.new(0,nR)end)end)else warn("Ability Frame missing")end;traumaShootButton=b;print("UI Button Created:",ABILITY_NAME);traumaShootButton.Activated:Connect(TraumatizedShoot);print("Connected Activated")
end

-- // --- Single Button Cooldown Update --- (No Changes Here)
RunService.Heartbeat:Connect(function(dt)if traumaShootButton and traumaShootButton.Parent then local tl=(lastTraumaShootTime or 0)+COOLDOWN-tick();local aF=traumaShootButton:FindFirstChild("Ability")or traumaShootButton;local cF=aF and aF:FindFirstChild("Cooldown");local tL=traumaShootButton:FindFirstChild("Timer")or traumaShootButton:FindFirstChild("AbilityName",true);if tL and tL:IsA("TextLabel") then if tl>0 then if cF then local p=math.clamp(tl/COOLDOWN,0,1);pcall(function()if cF and cF.Parent then cF.Size=UDim2.new(1,0,p,0); cF.Visible=true end end) end;local s,e=pcall(function()tL.Text=string.format("%.1fs",tl)end); if not s then warn("Cooldown Text Error:",e)end else if cF then pcall(function() if cF and cF.Parent then cF.Visible=false end end) end;local s,cT=pcall(function() return tL.Text end); if s and cT~=TIMER_TEXT then pcall(function() if tL and tL.Parent then tL.Text=TIMER_TEXT end end)end end end end end)

-- // --- Input Handling --- (No Changes Here)
UserInputService.InputBegan:Connect(function(i,gp)if gp then return end;if i.UserInputType==Enum.UserInputType.Keyboard and i.KeyCode==ABILITY_KEY then pcall(TraumatizedShoot)end end)

-- // --- Respawn Handling --- (No Changes Here)
player.CharacterAdded:Connect(function(nc)print("Character Added (Single Test)");character=nc;humanoid=character:WaitForChild("Humanoid");rootPart=character:WaitForChild("HumanoidRootPart");playerValues=character:WaitForChild("Values",10);lastTraumaShootTime=0;
print("Traumatized Shoot Test: Respawned.")end)

-- // --- Initial Setup --- (No Changes Here)
if ShootRemote then setupSingleButtonUI();print(ABILITY_NAME.." Test Script Loaded! (V11 Mod)")else warn(ABILITY_NAME.." Test Script FAILED TO LOAD due to missing ShootRemote.") end

-- // --- Cleanup --- (No Changes Here)
Players.PlayerRemoving:Connect(function(lp) if lp==player then 
 print("Player removing cleanup.") end end)

-- V2 - Integrated VFX, Original UI Restored

-- fixed v4
-- fixed v3
-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10) -- Assuming this path

-- // Remote Event Acquisition
local ShootRemote = nil
local function findShootRemoteStandardPath()
    print("BHS_v22_Simplified_SFX: Attempting Standard Path for ShootRemote...")
    local knitPath = ReplicatedStorage:FindFirstChild("Packages",5)
    if not knitPath then warn("BHS_v22_Simplified_SFX: Packages not found in ReplicatedStorage"); return nil end
    local knitService = knitPath:FindFirstChild("Knit",5)
    if not knitService then warn("BHS_v22_Simplified_SFX: Knit not found in Packages"); return nil end
    local ballServicePath = knitService:FindFirstChild("Services",5)
    if not ballServicePath then warn("BHS_v22_Simplified_SFX: Services not found in Knit"); return nil end
    local ballService = ballServicePath:FindFirstChild("BallService",5)
    if not ballService then warn("BHS_v22_Simplified_SFX: BallService not found in Services"); return nil end
    local rePath = ballService:FindFirstChild("RE",5)
    if not rePath then warn("BHS_v22_Simplified_SFX: RE not found in BallService"); return nil end
    local remote = rePath:FindFirstChild("Shoot",5)
    
    if remote and remote:IsA("RemoteEvent")then
        print("BHS_v22_Simplified_SFX: ShootRemote FOUND via Standard Path:",remote);
        return remote
    else
        warn("BHS_v22_Simplified_SFX: ShootRemote NOT found via Standard Path!");
        return nil
    end
end
ShootRemote = findShootRemoteStandardPath()

-- // --- CONFIGURABLE VALUES (Black Hole Strike v22 - Simplified SFX) --- //
local ABILITY_KEY_BHS = Enum.KeyCode.G -- User can change this
local COOLDOWN_BHS = 5 -- Cooldown in seconds (can be adjusted)

-- Shot Parameters
local ADJUSTABLE_INITIAL_FIREPOWER_BHS = 20 -- Power for the initial FireServer call
local ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS = 4 -- Delay AFTER button press BEFORE the shot is fired. Adjust to sync shot timing.
local ADJUSTABLE_SHOT_SPEED_BHS = 300    -- Speed of the ball (studs/second)
local SHOT_DURATION_BHS = 3   -- Duration BodyVelocity/BodyForce are active

-- Animation Parameters
local ANIMATION_ID_BHS = "rbxassetid://88134271748429" -- The main animation ID
local ANIMATION_DELAY_BHS = 0.1 -- Delay AFTER button press BEFORE animation starts.
local ANIMATION_SPEED_BHS = 1.5 -- Speed multiplier (e.g., 2 = twice as fast).
local ANIMATION_DURATION_BHS = 4.5  -- How long the animation should play in seconds (0 or less means play full length).
local ANIMATION_LOOPED_BHS = false -- Whether the animation should loop (ignored if ANIMATION_DURATION_BHS > 0)

-- SFX Parameters (SIMPLIFIED - Plays ONCE after delay, no loop/duration/cleanup)
local SFX_ID_BHS = "rbxassetid://5773418559" -- SFX ID
local SFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE SFX starts.
local SFX_VOLUME_BHS = 1 -- Volume for the SFX (0 to 1).
-- *** SFX_DURATION_BHS and SFX_LOOPED_BHS REMOVED ***


-- VFX Parameters
local VFX_ENABLED_BHS = true -- Set to false to disable this VFX
local VFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE VFX starts.
local VFX_DURATION_MULTIPLIER_BHS = 1.0 -- Adjust VFX duration (1.0 = default, 0.5 = half, 2.0 = double)
-- // --- END CONFIGURABLE VALUES --- //

local ABILITY_NAME_BHS = "BlackHoleStrike_v22_Simplified_SFX"
local BUTTON_NAME_BHS = "BlackHoleStrikeButton_v22_Simplified_SFX"
local TIMER_TEXT_BHS = "BLACK HOLE STRIKE" -- Button text
local LAYOUT_ORDER_BHS = 7 -- Adjust as needed

local lastAbilityTime_BHS = 0
local blackHoleStrikeButton = nil
local isAbilityActive_BHS = false
-- *** No sfxInstance_BHS needed globally anymore ***
local currentAnimationTrack_BHS = nil -- Variable to hold the active animation track

-- // Helper Functions
local function findBall(retries, delay)
    retries = retries or 3; delay = delay or 0.1; local ball = nil
    for i = 1, retries do
        local f = Workspace:FindFirstChild("Football")
        if f then
            local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
            if b and b:IsA("BasePart") then ball = b; break
            elseif f:IsA("Model") and f.PrimaryPart then ball = f.PrimaryPart; break
            elseif f:IsA("BasePart") then ball = f; break end
        end
        if i < retries then task.wait(delay) end
    end
    if not ball then warn(ABILITY_NAME_BHS .. " findBall: Ball not found after " .. retries .. " retries.") end
    return ball
end

local function cleanupAllMovers(target)
    if not target or not target.Parent then return end
    for _, mover in ipairs(target:GetChildren()) do
        if mover:IsA("BodyMover") then
            mover:Destroy()
        end
    end
end

local function playAnimation(humanoidRef, animationId, speed, looped)
    if not humanoidRef or not humanoidRef.Parent then return nil, nil end
    local animator = humanoidRef:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoidRef)
    local anim = Instance.new("Animation"); anim.AnimationId = animationId
    local track = animator:LoadAnimation(anim)
    if speed and speed ~= 1 then track:AdjustSpeed(speed) end
    track.Looped = looped
    track:Play()
    return track, anim 
end

-- SIMPLIFIED playSound: Parent to Workspace, clamp volume, NO loop param, NO cleanup.
local function playSound(soundId, volume)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = math.clamp(volume or 1, 0, 1) 
    sound.Looped = false -- Always false now
    sound.Parent = Workspace -- Parent to Workspace to decouple from character
    sound:Play()
    -- *** NO Debris or other cleanup logic here. Let Roblox handle it. ***
    return sound
end

local function IsReady_BHS() return tick() - lastAbilityTime_BHS >= COOLDOWN_BHS end

local function StartCooldown_BHS()
    lastAbilityTime_BHS = tick()
    if blackHoleStrikeButton then
        local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local TweenService = game:GetService("TweenService") 
                local tweenInfo = TweenInfo.new(COOLDOWN_BHS, Enum.EasingStyle.Linear)
                local targetProperties = {Offset = Vector2.new(0, 1)}
                uiGradient.Offset = Vector2.new(0, 0)
                local tween = TweenService:Create(uiGradient, tweenInfo, targetProperties)
                tween:Play()
            end
        end
    end
end

-- // Main Ability Execution Logic
local function BlackHoleStrike_Execute()
    if isAbilityActive_BHS then print(ABILITY_NAME_BHS .. ": Ability already active."); return end
    
    -- Pre-checks
    character = player.Character or player.CharacterAdded:Wait()
    if not character then print(ABILITY_NAME_BHS .. ": Character not found."); return end
    humanoid = character:FindFirstChildOfClass("Humanoid")
    rootPart = character:FindFirstChild("HumanoidRootPart")
    playerValues = character:FindFirstChild("Values")
    if not (humanoid and rootPart and playerValues) then print(ABILITY_NAME_BHS .. ": Character components missing."); return end
    local hasBallValue = playerValues:FindFirstChild("HasBall")
    if not (hasBallValue and hasBallValue:IsA("BoolValue") and hasBallValue.Value) then print(ABILITY_NAME_BHS .. ": Player does not have ball."); return end
    if not ShootRemote then ShootRemote = findShootRemoteStandardPath(); if not ShootRemote then print(ABILITY_NAME_BHS .. ": ShootRemote missing!"); return end end
    if not IsReady_BHS() then print(ABILITY_NAME_BHS .. ": Ability on cooldown. Time left: " .. string.format("%.1f", COOLDOWN_BHS - (tick() - lastAbilityTime_BHS))); return end

    -- Cleanup potential leftovers before starting
    if rootPart and rootPart.Parent then cleanupAllMovers(rootPart) end
    local ballForPreCleanup = findBall(1,0); if ballForPreCleanup then cleanupAllMovers(ballForPreCleanup) end
    if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
    -- *** No SFX pre-cleanup needed ***
    task.wait(0.05)

    -- Activate Ability
    isAbilityActive_BHS = true
    StartCooldown_BHS()
    print(ABILITY_NAME_BHS .. " Activated")

    -- Store references needed inside the spawn
    local currentCharacter_scope = character
    local currentHumanoid_scope = humanoid
    local currentRootPart_scope = rootPart

    task.spawn(function()
        local cleanupGuard_BHS = Instance.new("BoolValue", currentCharacter_scope)
        cleanupGuard_BHS.Name = ABILITY_NAME_BHS .. "_CleanupGuard"
        local ballInstance_thread_scope = nil
        local animationInstance_thread_scope = nil
        if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end

        local function performCleanupAndReset_BHS_Thread()
            if not cleanupGuard_BHS or not cleanupGuard_BHS.Parent then return end; cleanupGuard_BHS:Destroy()
            if currentCharacter_scope and currentCharacter_scope:FindFirstChild("HumanoidRootPart") then cleanupAllMovers(currentCharacter_scope:FindFirstChild("HumanoidRootPart")) end
            local ballToClean = ballInstance_thread_scope or findBall(1,0)
            if ballToClean and ballToClean.Parent then cleanupAllMovers(ballToClean) end
            
            -- *** SFX Cleanup REMOVED ***
            
            if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then animationInstance_thread_scope:Destroy() end
            isAbilityActive_BHS = false
            print(ABILITY_NAME_BHS .. ": Ability finished and cleaned up.")
        end

        local pcallSuccess, pcallResult = pcall(function()
            if not Camera then Camera = Workspace.CurrentCamera end
            if not Camera then warn(ABILITY_NAME_BHS .. ": Camera not found!"); performCleanupAndReset_BHS_Thread(); return end
            local aimVector = Camera.CFrame.LookVector

            -- // --- Animation and SFX Scheduling --- //

            -- Schedule Animation
            if ANIMATION_ID_BHS and ANIMATION_ID_BHS ~= "" and currentHumanoid_scope then
                task.delay(ANIMATION_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Playing animation after " .. ANIMATION_DELAY_BHS .. "s delay. Speed: " .. ANIMATION_SPEED_BHS .. ", Duration: " .. (ANIMATION_DURATION_BHS > 0 and ANIMATION_DURATION_BHS .. "s" or "Full"))
                    local track, animInstance = playAnimation(currentHumanoid_scope, ANIMATION_ID_BHS, ANIMATION_SPEED_BHS, ANIMATION_LOOPED_BHS)
                    if track then
                        currentAnimationTrack_BHS = track
                        animationInstance_thread_scope = animInstance
                        if ANIMATION_DURATION_BHS > 0 then
                            task.delay(ANIMATION_DURATION_BHS, function()
                                if not cleanupGuard_BHS.Parent then return end
                                if currentAnimationTrack_BHS and currentAnimationTrack_BHS == track and currentAnimationTrack_BHS.IsPlaying then
                                    print(ABILITY_NAME_BHS .. ": Stopping animation after " .. ANIMATION_DURATION_BHS .. "s duration.")
                                    currentAnimationTrack_BHS:Stop()
                                    if animationInstance_thread_scope and animationInstance_thread_scope.Parent then 
                                        Debris:AddItem(animationInstance_thread_scope, 0.1)
                                        animationInstance_thread_scope = nil
                                    end 
                                end
                            end)
                        elseif not ANIMATION_LOOPED_BHS then 
                            local effectiveLength = track.Length / (track.Speed > 0 and track.Speed or 1)
                            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then
                                Debris:AddItem(animationInstance_thread_scope, effectiveLength + 0.1)
                            end
                        end
                    end
                end)
            end

            -- Schedule SFX (SIMPLIFIED - Plays ONCE after delay)
            if SFX_ID_BHS and SFX_ID_BHS ~= "" and SFX_ID_BHS ~= "rbxassetid://YOUR_SFX_ID_HERE" then
                 task.delay(SFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Triggering SFX after " .. SFX_DELAY_BHS .. "s delay. ID: " .. SFX_ID_BHS)
                    
                    -- Play the sound (parented to Workspace, no loop, no explicit cleanup)
                    local sound = playSound(SFX_ID_BHS, SFX_VOLUME_BHS)
                    
                    if sound then
                        print(ABILITY_NAME_BHS .. ": SFX Playing (Volume: " .. sound.Volume .. ", Full Length: " .. sound.TimeLength .. "s)")
                        -- *** NO duration stop, NO manual destroy, NO Debris add here. ***
                    else
                        warn(ABILITY_NAME_BHS .. ": Failed to create sound instance for SFX.")
                    end
                 end)
            end

            -- Schedule VFX
            if VFX_ENABLED_BHS then
                task.delay(VFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end -- Check if ability was cancelled
                    print(ABILITY_NAME_BHS .. ": Triggering VFX after " .. VFX_DELAY_BHS .. "s delay.")

                    -- --- BEGIN VFX CODE INSERTION ---
                    -- Using player from outer scope (ensure player is valid here)
                    local currentCharacter_vfx = player.Character -- Re-get character just in case
                    if not currentCharacter_vfx then print(ABILITY_NAME_BHS .. ": VFX - Character not found."); return end
                    local currentRootPart_vfx = currentCharacter_vfx:FindFirstChild("HumanoidRootPart")
                    if not currentRootPart_vfx then print(ABILITY_NAME_BHS .. ": VFX - RootPart not found."); return end
                    
                    local effectPart_vfx = Instance.new("Part")
                    effectPart_vfx.Name = ABILITY_NAME_BHS .. "_VFX_Part" -- Unique name
                    effectPart_vfx.Anchored = true
                    effectPart_vfx.CanCollide = false
                    effectPart_vfx.Transparency = 1
                    effectPart_vfx.Parent = Workspace
                    
                    local forward_vfx = currentRootPart_vfx.CFrame.LookVector -- Use currentRootPart_vfx
                    local effectCFrame_vfx = CFrame.new(
                        currentRootPart_vfx.Position + (forward_vfx * 5),
                        currentRootPart_vfx.Position + (forward_vfx * 5) + forward_vfx
                    )
                    effectPart_vfx.CFrame = effectCFrame_vfx
                    
                    local function createFolderPath_vfx(parent, path)
                        if not path or path == "" then return parent end
                        
                        local current = parent
                        for _, name in ipairs(string.split(path, ".")) do
                            local existing = current:FindFirstChild(name)
                            if not existing then
                                local new = Instance.new("Folder")
                                new.Name = name
                                new.Parent = current
                                current = new
                            else
                                current = existing
                            end
                        end
                        return current
                    end
                    
                    local particles_vfx = {}
                    
                        do
                            local particle = Instance.new("ParticleEmitter")
                            local parent = effectPart_vfx
                                    particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
                            particle.FlipbookFramerate = NumberRange.new(2.000000, 10.000000)
                            particle.LightInfluence = 0
                            particle.Lifetime = NumberRange.new(0.200000, 0.300000)
                            particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
                            particle.SpreadAngle = Vector2.new(15.000000, 15.000000)
                            particle.LockedToPart = false
                            particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.600000, 0.000000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
                            particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                            particle.Color = ColorSequence.new(Color3.new(0, 0, 0)) -- Changed to Black
                            particle.Drag = 0
                            particle.FlipbookStartRandom = false
                            particle.TimeScale = 1
                            particle.VelocitySpread = 15
                            particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
                            particle.Speed = NumberRange.new(0.105000, 0.105000)
                            particle.Brightness = 5
                            particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 14.959538), NumberSequenceKeypoint.new(0.211349, 21.643269), NumberSequenceKeypoint.new(1.000000, 21.845776)})
                            particle.Enabled = false
                            particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
                            particle.RotSpeed = NumberRange.new(500.000000, 800.000000)
                            particle.ZOffset = 0
                            particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
                            particle.Rate = 20
                            particle.VelocityInheritance = 0
                            particle.Rotation = NumberRange.new(-360.000000, 360.000000)
                            particle.ShapePartial = 0.3400000035762787
                            particle.Texture = "rbxassetid://12597716531"
                            particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
                            particle.EmissionDirection = Enum.NormalId.Front
                            particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
                            particle.Shape = Enum.ParticleEmitterShape.Box
                            particle.LightEmission = 0
                    
                            particle.Parent = parent
                            table.insert(particles_vfx, particle)
                        end
                    
                        do
                            local particle = Instance.new("ParticleEmitter")
                            local parent = effectPart_vfx
                                    particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
                            particle.FlipbookFramerate = NumberRange.new(30.000000, 30.000000)
                            particle.LightInfluence = 0
                            particle.Lifetime = NumberRange.new(0.600000, 1.350000)
                            particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
                            particle.SpreadAngle = Vector2.new(5.000000, 5.000000)
                            particle.LockedToPart = true
                            particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
                            particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                            particle.Color = ColorSequence.new(Color3.new(0, 0, 0)) -- Changed to Black
                            particle.Drag = 0
                            particle.FlipbookStartRandom = false
                            particle.TimeScale = 1
                            particle.VelocitySpread = 5
                            particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
                            particle.Speed = NumberRange.new(0.010500, 1.050000)
                            particle.Brightness = 0.15000000596046448
                            particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 8.147511), NumberSequenceKeypoint.new(0.101481, 13.579604), NumberSequenceKeypoint.new(1.000000, 13.808828)})
                            particle.Enabled = false
                            particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
                            particle.RotSpeed = NumberRange.new(25.000000, 50.000000)
                            particle.ZOffset = 0
                            particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
                            particle.Rate = 10
                            particle.VelocityInheritance = 0
                            particle.Rotation = NumberRange.new(-360.000000, 360.000000)
                            particle.ShapePartial = 1
                            particle.Texture = "rbxassetid://13681366618"
                            particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
                            particle.EmissionDirection = Enum.NormalId.Front
                            particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
                            particle.Shape = Enum.ParticleEmitterShape.Box
                            particle.LightEmission = 0
                    
                            particle.Parent = parent
                            table.insert(particles_vfx, particle)
                        end
                    
                        do
                            local particle = Instance.new("ParticleEmitter")
                            local parent = effectPart_vfx
                                    particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Surface
                            particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
                            particle.LightInfluence = 0
                            particle.Lifetime = NumberRange.new(0.250000, 0.600000)
                            particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
                            particle.SpreadAngle = Vector2.new(0.000000, 0.000000)
                            particle.LockedToPart = true
                            particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
                            particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                            particle.Color = ColorSequence.new(Color3.new(0, 0, 0)) -- Changed to Black (All Black now)
                            particle.Drag = 0
                            particle.FlipbookStartRandom = false
                            particle.TimeScale = 1
                            particle.VelocitySpread = 0
                            particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
                            particle.Speed = NumberRange.new(0.010500, 0.010500)
                            particle.Brightness = 10
                            particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 15.750000), NumberSequenceKeypoint.new(0.103516, 32.749283), NumberSequenceKeypoint.new(1.000000, 32.836845)})
                            particle.Enabled = false
                            particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
                            particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
                            particle.ZOffset = 0
                            particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
                            particle.Rate = 50
                            particle.VelocityInheritance = 0
                            particle.Rotation = NumberRange.new(-360.000000, 360.000000)
                            particle.ShapePartial = 1
                            particle.Texture = "rbxassetid://16383559934"
                            particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
                            particle.EmissionDirection = Enum.NormalId.Front
                            particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
                            particle.Shape = Enum.ParticleEmitterShape.Box
                            particle.LightEmission = 0
                    
                            particle.Parent = parent
                            table.insert(particles_vfx, particle)
                        end
                    
                    for _, particle in ipairs(particles_vfx) do
                        particle.Enabled = true
                    end
                    
                    local maxLifetime_vfx = 0
                    for _, particle in ipairs(particles_vfx) do
                        maxLifetime_vfx = math.max(maxLifetime_vfx, particle.Lifetime.Max)
                    end

                    local totalDuration_vfx = maxLifetime_vfx * 1.5 * VFX_DURATION_MULTIPLIER_BHS
                    print(ABILITY_NAME_BHS .. ": VFX active. Calculated duration: " .. string.format("%.2f", totalDuration_vfx) .. "s (Multiplier: " .. VFX_DURATION_MULTIPLIER_BHS .. ")")
                    task.delay(totalDuration_vfx, function()
                        if effectPart_vfx and effectPart_vfx.Parent then
                            print(ABILITY_NAME_BHS .. ": Disabling VFX emitters after duration.")
                            for _, particle in ipairs(particles_vfx) do
                                if particle and particle.Parent then particle.Enabled = false end
                            end
                            task.wait(1) -- Wait for fade
                            if effectPart_vfx and effectPart_vfx.Parent then
                                print(ABILITY_NAME_BHS .. ": Destroying VFX part.")
                                effectPart_vfx:Destroy()
                            end
                        else
                            print(ABILITY_NAME_BHS .. ": VFX part already gone before cleanup.")
                        end
                    end)
                    -- --- END VFX CODE INSERTION ---
                end)
            end

            -- // --- Pre-Shot Delay --- //
            if ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS > 0 then
                print(ABILITY_NAME_BHS .. ": Waiting for pre-shot delay: " .. ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS .. "s before firing.")
                task.wait(ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS)
            end
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled during pre-shot delay."); performCleanupAndReset_BHS_Thread(); return end 

            -- // --- Fire the Shot --- //
            print(ABILITY_NAME_BHS .. ": Firing ShootRemote with power: " .. ADJUSTABLE_INITIAL_FIREPOWER_BHS)
            local sOk, sErr = pcall(ShootRemote.FireServer, ShootRemote, ADJUSTABLE_INITIAL_FIREPOWER_BHS)
            if not sOk then warn(ABILITY_NAME_BHS .. ": ShootRemote:FireServer() failed: ", sErr); performCleanupAndReset_BHS_Thread(); return end

            task.wait(0.1) 
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled after FireServer."); performCleanupAndReset_BHS_Thread(); return end

            local ball = findBall()
            if not ball then warn(ABILITY_NAME_BHS .. ": Ball not found after FireServer."); performCleanupAndReset_BHS_Thread(); return end
            ballInstance_thread_scope = ball
            cleanupAllMovers(ball)
            -- Schedule Ball VFX (NEW - Manus Implementation)
            if BALL_VFX_ENABLED_BHS then
                task.delay(BALL_VFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS or not cleanupGuard_BHS.Parent then return end -- Check if ability was cancelled

                    -- Ensure we still have a valid ball reference
                    local currentBallForVFX = ballInstance_thread_scope 
                    if not currentBallForVFX or not currentBallForVFX.Parent then 
                        warn(ABILITY_NAME_BHS .. ": Ball VFX - Ball instance lost before VFX could be applied.")
                        return 
                    end

                    print(ABILITY_NAME_BHS .. ": Triggering Ball VFX after " .. BALL_VFX_DELAY_BHS .. "s delay on ball: ", currentBallForVFX)
                    applyBallVFX_BHS(currentBallForVFX, ADJUSTABLE_BALL_VFX_DURATION_BHS)
                end)
            end 
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled after finding ball."); performCleanupAndReset_BHS_Thread(); return end

            print(ABILITY_NAME_BHS .. ": Applying force/velocity to ball. Speed: " .. ADJUSTABLE_SHOT_SPEED_BHS .. ", Duration: " .. SHOT_DURATION_BHS .. "s")
            local bodyVelocity = Instance.new("BodyVelocity"); bodyVelocity.Name = ABILITY_NAME_BHS .. "_BV"
            bodyVelocity.Velocity = aimVector * ADJUSTABLE_SHOT_SPEED_BHS
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge); bodyVelocity.P = math.huge
            bodyVelocity.Parent = ball
            local bodyForce = Instance.new("BodyForce"); bodyForce.Name = ABILITY_NAME_BHS .. "_BF"
            bodyForce.Force = Vector3.new(0, ball:GetMass() * Workspace.Gravity, 0) -- Counteract gravity
            bodyForce.Parent = ball

            -- Schedule cleanup for the ball movers
            task.delay(SHOT_DURATION_BHS, function()
                if not cleanupGuard_BHS.Parent then return end
                if ballInstance_thread_scope and ballInstance_thread_scope.Parent then
                    print(ABILITY_NAME_BHS .. ": Removing force/velocity from ball after " .. SHOT_DURATION_BHS .. "s.")
                    cleanupAllMovers(ballInstance_thread_scope)
                end
            end)

            -- Final cleanup scheduling (ensure it runs after all other delays)
            local maxDelay = math.max(ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS, ANIMATION_DELAY_BHS + (ANIMATION_DURATION_BHS > 0 and ANIMATION_DURATION_BHS or 0), SFX_DELAY_BHS, VFX_DELAY_BHS) -- Find the latest start time
            local maxDuration = math.max(SHOT_DURATION_BHS, (ANIMATION_DURATION_BHS > 0 and ANIMATION_DURATION_BHS or (currentAnimationTrack_BHS and currentAnimationTrack_BHS.Length / (currentAnimationTrack_BHS.Speed > 0 and currentAnimationTrack_BHS.Speed or 1) or 0)), 1) -- Consider shot, anim, and VFX cleanup wait
            local cleanupDelay = maxDelay + maxDuration + 2 -- Add buffer
            print(ABILITY_NAME_BHS .. ": Scheduling final cleanup in " .. string.format("%.2f", cleanupDelay) .. "s.")
            task.delay(cleanupDelay, performCleanupAndReset_BHS_Thread)

        end)

        if not pcallSuccess then
            warn(ABILITY_NAME_BHS .. ": Error during execution: ", pcallResult)
            performCleanupAndReset_BHS_Thread() -- Ensure cleanup on error
        end
    end)
end

-- // UI Creation and Input Handling
local function CreateAbilityButton_BHS()
    if not playerGui then print(ABILITY_NAME_BHS .. ": PlayerGui not found."); return end
    local inGameUI = playerGui:WaitForChild("InGameUI", 10); if not inGameUI then warn(ABILITY_NAME_BHS .. ": InGameUI not found!"); return end
    local bottomFrame = inGameUI:WaitForChild("Bottom", 5); if not bottomFrame then warn(ABILITY_NAME_BHS .. ": Bottom frame not found!"); return end
    local abilitiesFrame = bottomFrame:WaitForChild("Abilities", 5); if not abilitiesFrame then warn(ABILITY_NAME_BHS .. ": Abilities frame not found!"); return end
    
    local templateButton = abilitiesFrame:FindFirstChild("1") or abilitiesFrame:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME_BHS .. ": Template button (","1"," or ImageButton) not found! Cannot create button."); return end

    if abilitiesFrame:FindFirstChild(BUTTON_NAME_BHS) then abilitiesFrame[BUTTON_NAME_BHS]:Destroy() end

    blackHoleStrikeButton = templateButton:Clone()
    blackHoleStrikeButton.Name = BUTTON_NAME_BHS
    blackHoleStrikeButton.LayoutOrder = LAYOUT_ORDER_BHS
    blackHoleStrikeButton.Parent = abilitiesFrame

    local abilityTextLabel = blackHoleStrikeButton:FindFirstChild("Title") or blackHoleStrikeButton:FindFirstChild("Timer", true)
    if abilityTextLabel and abilityTextLabel:IsA("TextLabel") then abilityTextLabel.Text = TIMER_TEXT_BHS
    else warn(ABILITY_NAME_BHS .. ": Ability TextLabel (","Title"," or ","Timer",") not found.") end

    local keybindTextLabel = blackHoleStrikeButton:FindFirstChild("Key") or blackHoleStrikeButton:FindFirstChild("Keybind", true)
    if keybindTextLabel and keybindTextLabel:IsA("TextLabel") then keybindTextLabel.Text = ABILITY_KEY_BHS.Name
    else warn(ABILITY_NAME_BHS .. ": Keybind TextLabel (","Key"," or ","Keybind",") not found.") end
    
    local actualTimerLabel = blackHoleStrikeButton:FindFirstChild("ActualTimer", true)
    if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = ""; actualTimerLabel.Visible = false end
    
    local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
    if cooldownFrame then 
        local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
        if not uiGradient then
            warn(ABILITY_NAME_BHS .. ": No UIGradient found in Cooldown frame. Creating default.")
            uiGradient = Instance.new("UIGradient")
            uiGradient.Color = ColorSequence.new(Color3.new(0,0,0), Color3.new(0,0,0))
            uiGradient.Transparency = NumberSequence.new(0.5)
            uiGradient.Rotation = 90; uiGradient.Offset = Vector2.new(0,1)
            uiGradient.Parent = cooldownFrame
        else
            print(ABILITY_NAME_BHS .. ": Found UIGradient in Cooldown frame. Using its style.")
            uiGradient.Offset = Vector2.new(0,1) -- Ensure starts cooled down
        end
    else warn(ABILITY_NAME_BHS .. ": Cooldown frame not found on button.") end

    blackHoleStrikeButton.MouseButton1Click:Connect(BlackHoleStrike_Execute)
    print(ABILITY_NAME_BHS .. ": Button created and connected.")
end

local function HandleInput_BHS(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == ABILITY_KEY_BHS and input.UserInputState == Enum.UserInputState.Begin then
            BlackHoleStrike_Execute()
        end
    end
end

-- // Initialization
CreateAbilityButton_BHS()
UserInputService.InputBegan:Connect(HandleInput_BHS)

print(ABILITY_NAME_BHS .. " Script Loaded and Initialized.")

-- // Cleanup on Character Removal (Optional but good practice)
if character then
    character.Destroying:Connect(function()
        print(ABILITY_NAME_BHS .. ": Character removing, cleaning up button and connections.")
        if blackHoleStrikeButton and blackHoleStrikeButton.Parent then blackHoleStrikeButton:Destroy() end
        if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
        
        -- *** SFX Cleanup REMOVED from character removal ***
        
        -- Disconnect InputBegan connection if stored
        -- Any other cleanup
    end)
end



-- Ball VFX Parameters (NEW - Manus Implementation)
local BALL_VFX_ENABLED_BHS = true -- Set to false to disable the ball VFX
local BALL_VFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE ball VFX starts (User Request: 4 seconds)
local ADJUSTABLE_BALL_VFX_DURATION_BHS = 5.5 -- Duration the ball VFX stays active (User Request: 5-6 seconds, adjustable)



-- // Function to Create and Apply Actual VFX Directly to Ball (NEW - Manus Implementation)
local function applyBallVFX_BHS(targetBall, duration)
    if not targetBall or not targetBall.Parent then
        warn(ABILITY_NAME_BHS .. ": applyBallVFX_BHS - Target ball is invalid or has no parent.")
        return
    end
    print(ABILITY_NAME_BHS .. ": Applying actual VFX directly to ball: ", targetBall, " for duration: ", duration)
    
    -- Table to hold created emitters for cleanup
    local createdEmitters = {}
    local vfxContainer = Instance.new("Folder") -- Create a container for organization and easier cleanup
    vfxContainer.Name = ABILITY_NAME_BHS .. "_BallVFXContainer"

    -- --- BEGIN ACTUAL VFX CODE (Adapted from actual_ball_vfx_test_script_v3.txt) ---
    -- Parenting emitters DIRECTLY to the targetBall via the container

    -- Emitter 1 (Black)
    pcall(function() -- Wrap each emitter creation in pcall for safety
        local particle = Instance.new("ParticleEmitter")
        particle.Name = ABILITY_NAME_BHS .. "_BallVFX_Emitter1"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.500000, 1.500000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(-360.000000, 360.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.Drag = 5
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = -360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(50.000000, 80.000000)
        particle.Brightness = 4
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.155052, 0.937500), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 2
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 0.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://8030760338"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 1
        particle.Parent = vfxContainer -- Parent to container
        table.insert(createdEmitters, particle)
    end)

    -- Emitter 2 (Black)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.Name = ABILITY_NAME_BHS .. "_BallVFX_Emitter2"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.150000, 0.200000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(360.000000, 360.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.903559, 0.000000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.503067, -0.032258), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.000000, 0.000000)
        particle.Brightness = 10
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.718100, 23.106750), NumberSequenceKeypoint.new(0.870100, 24.985435), NumberSequenceKeypoint.new(1.000000, 6.557378)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(-45.000000, 45.000000)
        particle.ZOffset = 3
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 15
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://4456661344"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0
        particle.Parent = vfxContainer -- Parent to container
        table.insert(createdEmitters, particle)
    end)

    -- Emitter 3 (Black)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.Name = ABILITY_NAME_BHS .. "_BallVFX_Emitter3"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.250000, 0.300000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(-120.000000, 120.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityParallel
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.Drag = 10
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = -120
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.050000), NumberSequenceKeypoint.new(1.000000, 1.987500)})
        particle.Speed = NumberRange.new(200.000000, 400.000000)
        particle.Brightness = 4
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.298628, 5.187500), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 2.75
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 19
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-90.000000, -90.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://8708744804"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0.5
        particle.Parent = vfxContainer -- Parent to container
        table.insert(createdEmitters, particle)
    end)

    -- Emitter 4 (White - The prominent one)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.Name = ABILITY_NAME_BHS .. "_BallVFX_Emitter4"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.200000, 0.300000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(-180.000000, 180.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.799292, 0.000000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new(Color3.new(1, 1, 1))
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = -180
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 14.672911), NumberSequenceKeypoint.new(0.302100, -2.045662), NumberSequenceKeypoint.new(0.502100, 1.606739), NumberSequenceKeypoint.new(0.664100, 1.312191), NumberSequenceKeypoint.new(1.000000, -3.000000)})
        particle.Speed = NumberRange.new(5.000000, 25.000000)
        particle.Brightness = 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 19.300756), NumberSequenceKeypoint.new(0.366100, 11.014299), NumberSequenceKeypoint.new(0.506100, 1.749936), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 2.5
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 5000
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 0.000000)
        particle.ShapePartial = 1
        particle.Texture = "http://www.roblox.com/asset/?id=6889406891"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Left
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 1
        particle.Parent = vfxContainer -- Parent to container
        table.insert(createdEmitters, particle)
    end)

    -- Emitter 5 (Black)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.Name = ABILITY_NAME_BHS .. "_BallVFX_Emitter5"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.250000, 0.300000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(360.000000, -360.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.069463, 0.000000), NumberSequenceKeypoint.new(0.125424, 0.006380), NumberSequenceKeypoint.new(0.160452, 0.591707), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.024126, 0.024126)
        particle.Brightness = 1
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 135.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(-125.000000, 125.000000)
        particle.ZOffset = 6
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 5
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://7216848832"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Front
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 1
        particle.Parent = vfxContainer -- Parent to container
        table.insert(createdEmitters, particle)
    end)

    -- Emitter 6 (Black)
    pcall(function()
        local particle = Instance.new("ParticleEmitter")
        particle.Name = ABILITY_NAME_BHS .. "_BallVFX_Emitter6"
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.325000, 0.500000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(-360.000000, 360.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityParallel
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0))
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = -360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(50.000000, 80.000000)
        particle.Brightness = 4
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.149826, 0.562500), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = true
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 2
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 24
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(-90.000000, -90.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://8271975883"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
        particle.EmissionDirection = Enum.NormalId.Top
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 1
        particle.Parent = vfxContainer -- Parent to container
        table.insert(createdEmitters, particle)
    end)
    -- --- END ACTUAL VFX CODE ---

    -- Parent the container to the ball AFTER adding emitters
    vfxContainer.Parent = targetBall

    -- Schedule cleanup for the VFX container
    if duration > 0 then
        task.delay(duration, function()
            if vfxContainer and vfxContainer.Parent then
                print(ABILITY_NAME_BHS .. ": Cleaning up Ball VFX container after " .. duration .. "s.")
                vfxContainer:Destroy()
            end
        end)
    else
        -- If duration is 0 or less, maybe destroy immediately or handle differently?
        -- For now, let's just destroy if duration is invalid.
        warn(ABILITY_NAME_BHS .. ": Ball VFX duration is zero or negative, destroying immediately.")
        if vfxContainer and vfxContainer.Parent then
             vfxContainer:Destroy()
        end
    end
end


-- V2 - Integrated VFX, Original UI Restored

-- fixed v4
-- fixed v3
-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10) -- Assuming this path

-- // Remote Event Acquisition
local ShootRemote = nil
local function findShootRemoteStandardPath()
    print("BHS_v22_Simplified_SFX: Attempting Standard Path for ShootRemote...")
    local knitPath = ReplicatedStorage:FindFirstChild("Packages",5)
    if not knitPath then warn("BHS_v22_Simplified_SFX: Packages not found in ReplicatedStorage"); return nil end
    local knitService = knitPath:FindFirstChild("Knit",5)
    if not knitService then warn("BHS_v22_Simplified_SFX: Knit not found in Packages"); return nil end
    local ballServicePath = knitService:FindFirstChild("Services",5)
    if not ballServicePath then warn("BHS_v22_Simplified_SFX: Services not found in Knit"); return nil end
    local ballService = ballServicePath:FindFirstChild("BallService",5)
    if not ballService then warn("BHS_v22_Simplified_SFX: BallService not found in Services"); return nil end
    local rePath = ballService:FindFirstChild("RE",5)
    if not rePath then warn("BHS_v22_Simplified_SFX: RE not found in BallService"); return nil end
    local remote = rePath:FindFirstChild("Shoot",5)
    
    if remote and remote:IsA("RemoteEvent")then
        print("BHS_v22_Simplified_SFX: ShootRemote FOUND via Standard Path:",remote);
        return remote
    else
        warn("BHS_v22_Simplified_SFX: ShootRemote NOT found via Standard Path!");
        return nil
    end
end
ShootRemote = findShootRemoteStandardPath()

-- // --- CONFIGURABLE VALUES (Black Hole Strike v22 - Simplified SFX) --- //
local ABILITY_KEY_BHS = Enum.KeyCode.G -- User can change this
local COOLDOWN_BHS = 5 -- Cooldown in seconds (can be adjusted)

-- Shot Parameters
local ADJUSTABLE_INITIAL_FIREPOWER_BHS = 20 -- Power for the initial FireServer call
local ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS = 4 -- Delay AFTER button press BEFORE the shot is fired. Adjust to sync shot timing.
local ADJUSTABLE_SHOT_SPEED_BHS = 300    -- Speed of the ball (studs/second)
local SHOT_DURATION_BHS = 3   -- Duration BodyVelocity/BodyForce are active

-- Animation Parameters
local ANIMATION_ID_BHS = "rbxassetid://88134271748429" -- The main animation ID
local ANIMATION_DELAY_BHS = 0.1 -- Delay AFTER button press BEFORE animation starts.
local ANIMATION_SPEED_BHS = 1.5 -- Speed multiplier (e.g., 2 = twice as fast).
local ANIMATION_DURATION_BHS = 4.5  -- How long the animation should play in seconds (0 or less means play full length).
local ANIMATION_LOOPED_BHS = false -- Whether the animation should loop (ignored if ANIMATION_DURATION_BHS > 0)

-- SFX Parameters (SIMPLIFIED - Plays ONCE after delay, no loop/duration/cleanup)
local SFX_ID_BHS = "rbxassetid://5773418559" -- SFX ID
local SFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE SFX starts.
local SFX_VOLUME_BHS = 1 -- Volume for the SFX (0 to 1).
-- *** SFX_DURATION_BHS and SFX_LOOPED_BHS REMOVED ***


-- VFX Parameters
local VFX_ENABLED_BHS = true -- Set to false to disable this VFX
local VFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE VFX starts.
local VFX_DURATION_MULTIPLIER_BHS = 1.0 -- Adjust VFX duration (1.0 = default, 0.5 = half, 2.0 = double)
-- // --- END CONFIGURABLE VALUES --- //

local ABILITY_NAME_BHS = "BlackHoleStrike_v22_Simplified_SFX"
local BUTTON_NAME_BHS = "BlackHoleStrikeButton_v22_Simplified_SFX"
local TIMER_TEXT_BHS = "BLACK HOLE STRIKE" -- Button text
local LAYOUT_ORDER_BHS = 7 -- Adjust as needed

local lastAbilityTime_BHS = 0
local blackHoleStrikeButton = nil
local isAbilityActive_BHS = false
-- *** No sfxInstance_BHS needed globally anymore ***
local currentAnimationTrack_BHS = nil -- Variable to hold the active animation track

-- // Helper Functions
local function findBall(retries, delay)
    retries = retries or 3; delay = delay or 0.1; local ball = nil
    for i = 1, retries do
        local f = Workspace:FindFirstChild("Football")
        if f then
            local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
            if b and b:IsA("BasePart") then ball = b; break
            elseif f:IsA("Model") and f.PrimaryPart then ball = f.PrimaryPart; break
            elseif f:IsA("BasePart") then ball = f; break end
        end
        if i < retries then task.wait(delay) end
    end
    if not ball then warn(ABILITY_NAME_BHS .. " findBall: Ball not found after " .. retries .. " retries.") end
    return ball
end

local function cleanupAllMovers(target)
    if not target or not target.Parent then return end
    for _, mover in ipairs(target:GetChildren()) do
        if mover:IsA("BodyMover") then
            mover:Destroy()
        end
    end
end

local function playAnimation(humanoidRef, animationId, speed, looped)
    if not humanoidRef or not humanoidRef.Parent then return nil, nil end
    local animator = humanoidRef:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoidRef)
    local anim = Instance.new("Animation"); anim.AnimationId = animationId
    local track = animator:LoadAnimation(anim)
    if speed and speed ~= 1 then track:AdjustSpeed(speed) end
    track.Looped = looped
    track:Play()
    return track, anim 
end

-- SIMPLIFIED playSound: Parent to Workspace, clamp volume, NO loop param, NO cleanup.
local function playSound(soundId, volume)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = math.clamp(volume or 1, 0, 1) 
    sound.Looped = false -- Always false now
    sound.Parent = Workspace -- Parent to Workspace to decouple from character
    sound:Play()
    -- *** NO Debris or other cleanup logic here. Let Roblox handle it. ***
    return sound
end

local function IsReady_BHS() return tick() - lastAbilityTime_BHS >= COOLDOWN_BHS end

local function StartCooldown_BHS()
    lastAbilityTime_BHS = tick()
    if blackHoleStrikeButton then
        local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local TweenService = game:GetService("TweenService") 
                local tweenInfo = TweenInfo.new(COOLDOWN_BHS, Enum.EasingStyle.Linear)
                local targetProperties = {Offset = Vector2.new(0, 1)}
                uiGradient.Offset = Vector2.new(0, 0)
                local tween = TweenService:Create(uiGradient, tweenInfo, targetProperties)
                tween:Play()
            end
        end
    end
end

-- // Main Ability Execution Logic
local function BlackHoleStrike_Execute()
    if isAbilityActive_BHS then print(ABILITY_NAME_BHS .. ": Ability already active."); return end
    
    -- Pre-checks
    character = player.Character or player.CharacterAdded:Wait()
    if not character then print(ABILITY_NAME_BHS .. ": Character not found."); return end
    humanoid = character:FindFirstChildOfClass("Humanoid")
    rootPart = character:FindFirstChild("HumanoidRootPart")
    playerValues = character:FindFirstChild("Values")
    if not (humanoid and rootPart and playerValues) then print(ABILITY_NAME_BHS .. ": Character components missing."); return end
    local hasBallValue = playerValues:FindFirstChild("HasBall")
    if not (hasBallValue and hasBallValue:IsA("BoolValue") and hasBallValue.Value) then print(ABILITY_NAME_BHS .. ": Player does not have ball."); return end
    if not ShootRemote then ShootRemote = findShootRemoteStandardPath(); if not ShootRemote then print(ABILITY_NAME_BHS .. ": ShootRemote missing!"); return end end
    if not IsReady_BHS() then print(ABILITY_NAME_BHS .. ": Ability on cooldown. Time left: " .. string.format("%.1f", COOLDOWN_BHS - (tick() - lastAbilityTime_BHS))); return end

    -- Cleanup potential leftovers before starting
    if rootPart and rootPart.Parent then cleanupAllMovers(rootPart) end
    local ballForPreCleanup = findBall(1,0); if ballForPreCleanup then cleanupAllMovers(ballForPreCleanup) end
    if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
    -- *** No SFX pre-cleanup needed ***
    task.wait(0.05)

    -- Activate Ability
    isAbilityActive_BHS = true
    StartCooldown_BHS()
    print(ABILITY_NAME_BHS .. " Activated")

    -- Store references needed inside the spawn
    local currentCharacter_scope = character
    local currentHumanoid_scope = humanoid
    local currentRootPart_scope = rootPart

    task.spawn(function()
        local cleanupGuard_BHS = Instance.new("BoolValue", currentCharacter_scope)
        cleanupGuard_BHS.Name = ABILITY_NAME_BHS .. "_CleanupGuard"
        local ballInstance_thread_scope = nil
        local animationInstance_thread_scope = nil
        if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end

        local function performCleanupAndReset_BHS_Thread()
            if not cleanupGuard_BHS or not cleanupGuard_BHS.Parent then return end; cleanupGuard_BHS:Destroy()
            if currentCharacter_scope and currentCharacter_scope:FindFirstChild("HumanoidRootPart") then cleanupAllMovers(currentCharacter_scope:FindFirstChild("HumanoidRootPart")) end
            local ballToClean = ballInstance_thread_scope or findBall(1,0)
            if ballToClean and ballToClean.Parent then cleanupAllMovers(ballToClean) end
            
            -- *** SFX Cleanup REMOVED ***
            
            if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then animationInstance_thread_scope:Destroy() end
            isAbilityActive_BHS = false
            print(ABILITY_NAME_BHS .. ": Ability finished and cleaned up.")
        end

        local pcallSuccess, pcallResult = pcall(function()
            if not Camera then Camera = Workspace.CurrentCamera end
            if not Camera then warn(ABILITY_NAME_BHS .. ": Camera not found!"); performCleanupAndReset_BHS_Thread(); return end
            local aimVector = Camera.CFrame.LookVector

            -- // --- Animation and SFX Scheduling --- //

            -- Schedule Animation
            if ANIMATION_ID_BHS and ANIMATION_ID_BHS ~= "" and currentHumanoid_scope then
                task.delay(ANIMATION_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Playing animation after " .. ANIMATION_DELAY_BHS .. "s delay. Speed: " .. ANIMATION_SPEED_BHS .. ", Duration: " .. (ANIMATION_DURATION_BHS > 0 and ANIMATION_DURATION_BHS .. "s" or "Full"))
                    local track, animInstance = playAnimation(currentHumanoid_scope, ANIMATION_ID_BHS, ANIMATION_SPEED_BHS, ANIMATION_LOOPED_BHS)
                    if track then
                        currentAnimationTrack_BHS = track
                        animationInstance_thread_scope = animInstance
                        if ANIMATION_DURATION_BHS > 0 then
                            task.delay(ANIMATION_DURATION_BHS, function()
                                if not cleanupGuard_BHS.Parent then return end
                                if currentAnimationTrack_BHS and currentAnimationTrack_BHS == track and currentAnimationTrack_BHS.IsPlaying then
                                    print(ABILITY_NAME_BHS .. ": Stopping animation after " .. ANIMATION_DURATION_BHS .. "s duration.")
                                    currentAnimationTrack_BHS:Stop()
                                    if animationInstance_thread_scope and animationInstance_thread_scope.Parent then 
                                        Debris:AddItem(animationInstance_thread_scope, 0.1)
                                        animationInstance_thread_scope = nil
                                    end 
                                end
                            end)
                        elseif not ANIMATION_LOOPED_BHS then 
                            local effectiveLength = track.Length / (track.Speed > 0 and track.Speed or 1)
                            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then
                                Debris:AddItem(animationInstance_thread_scope, effectiveLength + 0.1)
                            end
                        end
                    end
                end)
            end

            -- Schedule SFX (SIMPLIFIED - Plays ONCE after delay)
            if SFX_ID_BHS and SFX_ID_BHS ~= "" and SFX_ID_BHS ~= "rbxassetid://YOUR_SFX_ID_HERE" then
                 task.delay(SFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    print(ABILITY_NAME_BHS .. ": Triggering SFX after " .. SFX_DELAY_BHS .. "s delay. ID: " .. SFX_ID_BHS)
                    
                    -- Play the sound (parented to Workspace, no loop, no explicit cleanup)
                    local sound = playSound(SFX_ID_BHS, SFX_VOLUME_BHS)
                    
                    if sound then
                        print(ABILITY_NAME_BHS .. ": SFX Playing (Volume: " .. sound.Volume .. ", Full Length: " .. sound.TimeLength .. "s)")
                        -- *** NO duration stop, NO manual destroy, NO Debris add here. ***
                    else
                        warn(ABILITY_NAME_BHS .. ": Failed to create sound instance for SFX.")
                    end
                 end)
            end

            -- Schedule VFX
            if VFX_ENABLED_BHS then
                task.delay(VFX_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end -- Check if ability was cancelled
                    print(ABILITY_NAME_BHS .. ": Triggering VFX after " .. VFX_DELAY_BHS .. "s delay.")

                    -- --- BEGIN VFX CODE INSERTION ---
                    -- Using player from outer scope (ensure player is valid here)
                    local currentCharacter_vfx = player.Character -- Re-get character just in case
                    if not currentCharacter_vfx then print(ABILITY_NAME_BHS .. ": VFX - Character not found."); return end
                    local currentRootPart_vfx = currentCharacter_vfx:FindFirstChild("HumanoidRootPart")
                    if not currentRootPart_vfx then print(ABILITY_NAME_BHS .. ": VFX - RootPart not found."); return end
                    
                    local effectPart_vfx = Instance.new("Part")
                    effectPart_vfx.Name = ABILITY_NAME_BHS .. "_VFX_Part" -- Unique name
                    effectPart_vfx.Anchored = true
                    effectPart_vfx.CanCollide = false
                    effectPart_vfx.Transparency = 1
                    effectPart_vfx.Parent = Workspace
                    
                    local forward_vfx = currentRootPart_vfx.CFrame.LookVector -- Use currentRootPart_vfx
                    local effectCFrame_vfx = CFrame.new(
                        currentRootPart_vfx.Position + (forward_vfx * 5),
                        currentRootPart_vfx.Position + (forward_vfx * 5) + forward_vfx
                    )
                    effectPart_vfx.CFrame = effectCFrame_vfx
                    
                    -- Create Attachment
                    local attachment_vfx = Instance.new("Attachment", effectPart_vfx)
                    
                    -- Create Particle Emitters
                    local p1=Instance.new("ParticleEmitter");p1.Color=ColorSequence.new(Color3.new(0,0,0));p1.LightEmission=0;p1.Brightness=0;p1.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p1.FlipbookFramerate=NumberRange.new(1);p1.Lifetime=NumberRange.new(0.5*VFX_DURATION_MULTIPLIER_BHS,1*VFX_DURATION_MULTIPLIER_BHS);p1.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p1.SpreadAngle=Vector2.new(360,360);p1.LockedToPart=false;p1.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.5,0),NumberSequenceKeypoint.new(1,1)});p1.Orientation=Enum.ParticleOrientation.FacingCamera;p1.Drag=0;p1.FlipbookStartRandom=false;p1.TimeScale=1;p1.VelocitySpread=0;p1.Squash=NumberSequence.new(0);p1.Speed=NumberRange.new(0);p1.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,20),NumberSequenceKeypoint.new(1,20)});p1.Enabled=false;p1.Acceleration=Vector3.new(0,0,0);p1.RotSpeed=NumberRange.new(0);p1.ZOffset=0;p1.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p1.Rate=100;p1.VelocityInheritance=0;p1.Rotation=NumberRange.new(0);p1.ShapePartial=1;p1.Texture="rbxassetid://17258046088";p1.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p1.EmissionDirection=Enum.NormalId.Front;p1.Shape=Enum.ParticleEmitterShape.Sphere;p1.Parent=attachment_vfx
                    local p2=Instance.new("ParticleEmitter");p2.Color=ColorSequence.new(Color3.new(0,0,0));p2.LightEmission=0;p2.Brightness=0;p2.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p2.FlipbookFramerate=NumberRange.new(1);p2.Lifetime=NumberRange.new(0.5*VFX_DURATION_MULTIPLIER_BHS,1*VFX_DURATION_MULTIPLIER_BHS);p2.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p2.SpreadAngle=Vector2.new(360,360);p2.LockedToPart=false;p2.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.5,0),NumberSequenceKeypoint.new(1,1)});p2.Orientation=Enum.ParticleOrientation.FacingCamera;p2.Drag=0;p2.FlipbookStartRandom=false;p2.TimeScale=1;p2.VelocitySpread=0;p2.Squash=NumberSequence.new(0);p2.Speed=NumberRange.new(0);p2.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,20),NumberSequenceKeypoint.new(1,20)});p2.Enabled=false;p2.Acceleration=Vector3.new(0,0,0);p2.RotSpeed=NumberRange.new(0);p2.ZOffset=0;p2.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p2.Rate=100;p2.VelocityInheritance=0;p2.Rotation=NumberRange.new(0);p2.ShapePartial=1;p2.Texture="rbxassetid://17258046088";p2.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p2.EmissionDirection=Enum.NormalId.Front;p2.Shape=Enum.ParticleEmitterShape.Sphere;p2.Parent=attachment_vfx
                    local p3=Instance.new("ParticleEmitter");p3.Color=ColorSequence.new(Color3.new(0,0,0));p3.LightEmission=0;p3.Brightness=0;p3.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p3.FlipbookFramerate=NumberRange.new(1);p3.Lifetime=NumberRange.new(0.5*VFX_DURATION_MULTIPLIER_BHS,1*VFX_DURATION_MULTIPLIER_BHS);p3.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p3.SpreadAngle=Vector2.new(360,360);p3.LockedToPart=false;p3.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.5,0),NumberSequenceKeypoint.new(1,1)});p3.Orientation=Enum.ParticleOrientation.FacingCamera;p3.Drag=0;p3.FlipbookStartRandom=false;p3.TimeScale=1;p3.VelocitySpread=0;p3.Squash=NumberSequence.new(0);p3.Speed=NumberRange.new(0);p3.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,20),NumberSequenceKeypoint.new(1,20)});p3.Enabled=false;p3.Acceleration=Vector3.new(0,0,0);p3.RotSpeed=NumberRange.new(0);p3.ZOffset=0;p3.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p3.Rate=100;p3.VelocityInheritance=0;p3.Rotation=NumberRange.new(0);p3.ShapePartial=1;p3.Texture="rbxassetid://17258046088";p3.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p3.EmissionDirection=Enum.NormalId.Front;p3.Shape=Enum.ParticleEmitterShape.Sphere;p3.Parent=attachment_vfx
                    
                    -- Enable Emitters
                    p1.Enabled = true
                    p2.Enabled = true
                    p3.Enabled = true
                    
                    -- Cleanup VFX Part
                    local maxLifetime_vfx = 1 * VFX_DURATION_MULTIPLIER_BHS -- Based on emitter lifetime
                    Debris:AddItem(effectPart_vfx, maxLifetime_vfx + 0.1)
                    print(ABILITY_NAME_BHS .. ": VFX created and scheduled for cleanup in " .. maxLifetime_vfx + 0.1 .. "s.")
                    -- --- END VFX CODE INSERTION ---
                end)
            end

            -- // --- Ball Manipulation Scheduling --- //
            task.delay(ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS, function()
                if not cleanupGuard_BHS.Parent then return end
                print(ABILITY_NAME_BHS .. ": Executing ball manipulation after " .. ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS .. "s delay.")
                
                ballInstance_thread_scope = findBall(3, 0.1)
                if not ballInstance_thread_scope or not ballInstance_thread_scope.Parent then
                    warn(ABILITY_NAME_BHS .. ": Ball not found for shot!")
                    performCleanupAndReset_BHS_Thread()
                    return
                end
                
                -- Fire initial remote (if needed by game logic)
                if ShootRemote then
                    print(ABILITY_NAME_BHS .. ": Firing ShootRemote with power: " .. ADJUSTABLE_INITIAL_FIREPOWER_BHS)
                    ShootRemote:FireServer(ADJUSTABLE_INITIAL_FIREPOWER_BHS)
                end
                
                -- Apply BodyVelocity
                cleanupAllMovers(ballInstance_thread_scope)
                local bv = Instance.new("BodyVelocity")
                bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.Velocity = aimVector * ADJUSTABLE_SHOT_SPEED_BHS
                bv.Parent = ballInstance_thread_scope
                print(ABILITY_NAME_BHS .. ": Applied BodyVelocity with speed: " .. ADJUSTABLE_SHOT_SPEED_BHS .. ", Duration: " .. SHOT_DURATION_BHS .. "s")
                
                -- Schedule BodyVelocity removal
                Debris:AddItem(bv, SHOT_DURATION_BHS)
                
                -- Schedule final cleanup for the entire ability
                task.delay(SHOT_DURATION_BHS + 0.1, performCleanupAndReset_BHS_Thread)
            end)
        end)

        if not pcallSuccess then
            warn(ABILITY_NAME_BHS .. ": Error during execution: " .. tostring(pcallResult))
            performCleanupAndReset_BHS_Thread()
        end
    end)
end

-- // --- UI Setup --- //
local function setupAbilityUI_BHS()
    local playerGui = player:WaitForChild("PlayerGui")
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn(ABILITY_NAME_BHS .. ": InGameUI not found."); return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn(ABILITY_NAME_BHS .. ": Bottom frame not found."); return end
    local bottomAbilities = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilities then warn(ABILITY_NAME_BHS .. ": Abilities Frame not found!"); return end
    local templateButton = bottomAbilities:FindFirstChild("1") or bottomAbilities:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME_BHS .. ": Template button ("1" or ImageButton) not found in Abilities Frame!"); return end

    -- Remove existing button if it exists
    local oldBtn = bottomAbilities:FindFirstChild(BUTTON_NAME_BHS)
    if oldBtn then oldBtn:Destroy() end
    task.wait(0.1)

    -- Create new button
    local button = templateButton:Clone()
    button.Name = BUTTON_NAME_BHS
    button.Parent = bottomAbilities
    button.LayoutOrder = LAYOUT_ORDER_BHS

    local keybindLabel = button:FindFirstChild("Keybind", true)
    local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
    local actualTimerLabel = button:FindFirstChild("ActualTimer", true)

    if keybindLabel and keybindLabel:IsA("TextLabel") then keybindLabel.Text = ABILITY_KEY_BHS.Name else warn(ABILITY_NAME_BHS .. ": Keybind Label not found") end
    if timerLabel and timerLabel:IsA("TextLabel") then timerLabel.Text = TIMER_TEXT_BHS else warn(ABILITY_NAME_BHS .. ": Timer Label not found") end
    if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = "" end

    -- Cooldown Visual Setup (Gradient Style)
    local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown")
    if cdVisual then cdVisual:Destroy() end

    local abilityFrame = button:FindFirstChild("Ability") or button
    if abilityFrame then
        local cooldownFrame = Instance.new("Frame")
        cooldownFrame.Name = "Cooldown"
        cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        cooldownFrame.BackgroundTransparency = 0.6
        cooldownFrame.BorderSizePixel = 0
        cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
        cooldownFrame.Position = UDim2.new(0, 0, 0, 0)
        cooldownFrame.AnchorPoint = Vector2.new(0, 0)
        cooldownFrame.ZIndex = (abilityFrame:IsA("GuiObject") and abilityFrame.ZIndex or 1) + 1
        cooldownFrame.ClipsDescendants = true
        cooldownFrame.Parent = abilityFrame

        local uiGradient = Instance.new("UIGradient")
        uiGradient.Color = ColorSequence.new(Color3.fromRGB(0,0,0), Color3.fromRGB(0,0,0))
        uiGradient.Transparency = NumberSequence.new(0.6, 1)
        uiGradient.Rotation = 90
        uiGradient.Offset = Vector2.new(0, 1) -- Start fully transparent (covered)
        uiGradient.Parent = cooldownFrame

        local uiCorner = Instance.new("UICorner", cooldownFrame)
        local absSize = abilityFrame:IsA("GuiObject") and abilityFrame.AbsoluteSize or Vector2.new(50,50)
        local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
        uiCorner.CornerRadius = UDim.new(0, radius)

        if abilityFrame:IsA("GuiObject") then
            abilityFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                local newAbsSize = abilityFrame.AbsoluteSize
                local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                uiCorner.CornerRadius = UDim.new(0, newRadius)
            end)
        end
    else
        warn(ABILITY_NAME_BHS .. ": Could not find 'Ability' frame or base button to parent cooldown visual")
    end

    blackHoleStrikeButton = button
    print(ABILITY_NAME_BHS .. ": UI Button Created")

    -- Connect Activation
    button.Activated:Connect(BlackHoleStrike_Execute)
    print(ABILITY_NAME_BHS .. ": Button Activated connected")
end

-- // Cooldown Update Loop (Timer Text)
RunService.Heartbeat:Connect(function(dt)
    if blackHoleStrikeButton and blackHoleStrikeButton.Parent then
        local timeLeft = lastAbilityTime_BHS + COOLDOWN_BHS - tick()
        local timerLabel = blackHoleStrikeButton:FindFirstChild("Timer") or blackHoleStrikeButton:FindFirstChild("AbilityName", true)
        if timerLabel and timerLabel:IsA("TextLabel") then
            if timeLeft > 0 then
                timerLabel.Text = string.format("%.1fs", timeLeft)
            else
                if timerLabel.Text ~= TIMER_TEXT_BHS then
                    timerLabel.Text = TIMER_TEXT_BHS
                end
            end
        end
    end
end)

-- // Character Respawn Handling
player.CharacterAdded:Connect(function(newCharacter)
    print(ABILITY_NAME_BHS .. ": Character Added Event Fired")
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10)
    lastAbilityTime_BHS = 0
    isAbilityActive_BHS = false
    if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
    -- *** No SFX instance to reset ***
    print(ABILITY_NAME_BHS .. ": Character respawned, variables reset.")
    -- Re-setup UI if needed
    task.wait(0.5) -- Give UI time to potentially load
    if player:FindFirstChild("PlayerGui") then setupAbilityUI_BHS() end
end)

-- // Input Handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY_BHS then
        BlackHoleStrike_Execute()
    end
end)

-- // Initial Setup
task.wait(1) -- Wait a bit for game elements to load
setupAbilityUI_BHS()

print(ABILITY_NAME_BHS .. " Script Loaded Successfully!")


-- V11
--[[
    Style Name: EGO JINPANCHI (Concept)
    Ability: TRAUMATIZED SHOOT - Standalone Test V26 (Lift/Freeze + Goal Target + Speed 650) -> V11 Mod
    Creator: Gemini (Restoring Confirmed Working Version, Modified by Manus)
    Version: V11 - Added robust post-shot ball physics cleanup to fix goal glitch.
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- // Player & Character Variables
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerValues = character:WaitForChild("Values", 10)

-- // Remote Event Acquisition (Direct Path First)
local ShootRemote = nil
local function findShootRemoteStandardPath() print("Attempting Standard Path...") local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil;if p then k=p:FindFirstChild("Knit",5)end;if k then s=k:FindFirstChild("Services",5)end;if s then b=s:FindFirstChild("BallService",5)end;if b then r=b:FindFirstChild("RE",5)end;local remote=r and r:FindFirstChild("Shoot",5);if remote and remote:IsA("RemoteEvent")then print("ShootRemote FOUND via Standard Path:",remote);return remote else warn("ShootRemote NOT found via Standard Path!");return nil end end
ShootRemote = findShootRemoteStandardPath()
if not ShootRemote then warn("!!! CRITICAL: ShootRemote could not be located. Ability may fail. !!!") end

-- // Ability Settings
local ABILITY_NAME = "TraumatizedShoot"
local ABILITY_KEY = Enum.KeyCode.X -- Using X for this test script
local COOLDOWN = 1
local BUTTON_NAME = "TraumatizedShootButton"
local TIMER_TEXT = "Traumatized Shoot"
local LAYOUT_ORDER = 2

-- // Modifiable Parameters (V11)
local ANIMATION_ID = "rbxassetid://83474010887370" -- Animation to play on activation
local KICK_VFX_DURATION = 2.5 -- How long the kick VFX lasts (seconds)
local BALL_SPEED = 300 -- Speed of the ball after the freeze (Confirmed V4)
local BALL_LIFT_FORCE = 100000 -- Controls the force/speed of the ball lift (BodyPosition P value) (Adjusted V4)
local SOUND_ID_TRAUMA_SHOOT = "rbxassetid://18893204466" -- SFX ID (Updated V4)
local BALL_CIRCLE_VFX_DURATION = 4.5 -- How long the black circle VFX on the ball lasts (seconds) (Added V5)
local NEWEST_BALL_VFX_DURATION = 5.0 -- Duration for the newest V10 ball VFX (White/Black from user)
local BALL_VELOCITY_CLEANUP_TIME = 0.75 -- Time after shot before BodyVelocity is removed (Adjusted V7 for physics bug)
local POST_SHOT_PHYSICS_CLEANUP_DELAY = BALL_VELOCITY_CLEANUP_TIME + 0.1 -- V11: Delay before forceful physics cleanup

-- // Cooldown Tracking
local lastTraumaShootTime = 0

-- // Helper Functions
local function IsReady() return tick()-lastTraumaShootTime>=COOLDOWN end;local function StartCooldown() lastTraumaShootTime=tick() end;
-- V7.1: SFX Fix Attempt 3: Parent *then* set ID/Play.
local function playSound(id, p)
    if not id or id == "rbxassetid://SOUND_ID_HERE" or not p or not p.Parent then
        print("SFX Skipped (Placeholder or invalid Parent)")
        return
    end
    local s = Instance.new("Sound")
    s.Name = "TraumaShootSFX_Temp"
    s.Volume = 2
    s.Parent = p -- Parent first to ensure it exists in the world
    s.SoundId = id -- Set ID after parenting
    s:Play() -- Play immediately
    print("Playing SFX Attempt (V7.1):", id, "Parented to:", p:GetFullName())

    -- Schedule cleanup using Debris
    task.delay(0.1, function()
        if s and s.Parent then
            local duration = s.TimeLength
            if duration <= 0 then duration = 3 end -- Fallback duration
            print("SFX Cleanup Scheduled. Duration:", duration)
            Debris:AddItem(s, duration + 0.5)
        end
    end)
end
local function shakeCamera(i,d)if not Camera or not Camera.Parent then return end;local o=Camera.CFrame;local e=0;local h=RunService.Heartbeat;local c;local function s()if c and c.Connected then if Camera and Camera.Parent then Camera.CFrame=o end c:Disconnect();c=nil end end;c=h:Connect(function(t)e=e+t;if e<d then local f=CFrame.new((math.random()*2-1)*i/100,(math.random()*2-1)*i/100,(math.random()*2-1)*i/100)*CFrame.Angles(math.rad((math.random()*2-1)*i*0.1),math.rad((math.random()*2-1)*i*0.1),math.rad((math.random()*2-1)*i*0.1));if Camera and Camera.Parent then Camera.CFrame=o*f else s()end else s()end end);task.delay(d+0.1,s)end;local homeGoalPos=Vector3.new(325,15,-49);local awayGoalPos=Vector3.new(-247,15,-50);local function getOpponentGoalPos()local t=player.Team;if t then if t.Name=="Home"then return awayGoalPos elseif t.Name=="Away"then return homeGoalPos end end;warn("NoOppGoal");return nil end;
local function findBall()local f=Workspace:FindFirstChild("Football");if f then local b=(f:FindFirstChild("BallAnims")and f.BallAnims:FindFirstChild("BALL"))or f:FindFirstChild("BALL");if b and b:IsA("BasePart")then return b elseif f:IsA("Model")and f.PrimaryPart then return f.PrimaryPart elseif f:IsA("BasePart")then return f end end; warn("findBall: Could not find Football in Workspace"); return nil end
local function playerHasBall() character=player.Character;if not character then return false end;local v=character:FindFirstChild("Values");local h=v and v:FindFirstChild("HasBall");return h and h.Value==true end

-- // V11: Robust Ball Physics Cleanup Function
local function cleanupBallPhysics(ballInstance)
    if not ballInstance or not ballInstance.Parent or not ballInstance:IsA("BasePart") then
        print("CleanupBallPhysics: Ball instance invalid or missing.")
        return
    end
    print("CleanupBallPhysics: Running cleanup on", ballInstance:GetFullName())
    -- Remove all BodyMovers
    for _, child in ipairs(ballInstance:GetChildren()) do
        if child:IsA("BodyMover") or child:IsA("BodyGyro") then
            print("CleanupBallPhysics: Destroying", child.Name)
            pcall(child.Destroy, child)
        end
    end
    -- Reset Velocities
    if ballInstance:IsA("BasePart") then
        pcall(function()
            ballInstance.Velocity = Vector3.zero
            ballInstance.RotVelocity = Vector3.zero
            print("CleanupBallPhysics: Velocities reset.")
        end)
    end
end

-- // VFX Function (V1 - Based on 'the best kick vfx.txt') - UNCHANGED
local function playKickVFX(targetPart, duration)
    if not targetPart or not targetPart.Parent then warn("Kick VFX Target Part invalid."); return end
    local RunService = game:GetService("RunService"); local Debris = game:GetService("Debris")
    if not RunService:IsClient() then return end
    local vfxContainer = Instance.new("Attachment"); vfxContainer.Name = "BestKickVFX_Temp"; vfxContainer.Parent = targetPart
    local particles = {}
    -- Emitter 1 (White Streaks)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0.8;p.Brightness=10;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.Lifetime=NumberRange.new(0.2,0.35);p.SpreadAngle=Vector2.new(360,360);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=10;p.Speed=NumberRange.new(400,600);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.17266,7.764939),NumberSequenceKeypoint.new(1,0)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(90,90);p.Texture="rbxassetid://13386858482";p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 2 (Black Swirl)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0,0,0));p.LightEmission=0;p.Brightness=0;p.Lifetime=NumberRange.new(0.25,0.35);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(50,50);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Speed=NumberRange.new(0.1,0.1);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(-360,360);p.Texture="rbxassetid://13395479051";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 3 (Dark Gray Wisps)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0.1;p.Lifetime=NumberRange.new(0.15,0.35);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(5,5);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Speed=NumberRange.new(0.1,0.1);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(-360,360);p.Texture="rbxassetid://13395481373";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 4 (White Flash)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=1;p.Brightness=10;p.Lifetime=NumberRange.new(0.05,0.05);p.SpreadAngle=Vector2.new(360,360);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.30137,0.475),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.FacingCamera;p.Drag=5;p.Speed=NumberRange.new(0,0);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,13.051071),NumberSequenceKeypoint.new(1,101.363541)});p.Enabled=false;p.ZOffset=3;p.Rate=32;p.Texture="rbxassetid://11503727043";p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 5 (Alternating B&W Swirl)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new({ColorSequenceKeypoint.new(0.0,Color3.new(0,0,0)),ColorSequenceKeypoint.new(0.5,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1.0,Color3.new(0,0,0))});p.LightEmission=0.5;p.Brightness=4;p.Lifetime=NumberRange.new(0.25,0.35);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(50,50);p.LockedToPart=true;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0)});p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Speed=NumberRange.new(0.1,0.1);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,18.65996),NumberSequenceKeypoint.new(0.16866,43.199478),NumberSequenceKeypoint.new(1,51.387165)});p.Enabled=false;p.Rate=50;p.Rotation=NumberRange.new(-360,360);p.Texture="rbxassetid://13395479051";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    for _,p in ipairs(particles) do p.Enabled=true;p:Emit(p.Rate*0.1) end
    local function cleanup() if vfxContainer and vfxContainer.Parent then Debris:AddItem(vfxContainer,0.1) end end
    task.delay(duration,cleanup); print("Kick VFX Playing for",duration,"seconds")
end

-- // VFX Function (V5 - Black Circle on Ball) - UNCHANGED
local function playBallCircleVFX(targetBall, duration)
    if not targetBall or not targetBall.Parent or not targetBall:IsA("BasePart") then warn("Ball Circle VFX Target invalid."); return end
    local Debris = game:GetService("Debris"); if not RunService:IsClient() then return end
    local attachment = Instance.new("Attachment"); attachment.Name = "BallCircleVFXAttachment"; attachment.Parent = targetBall
    local emitter = Instance.new("ParticleEmitter"); emitter.Color = ColorSequence.new(Color3.fromRGB(0,0,0)); emitter.LightEmission = 0; emitter.LightInfluence = 0
    emitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8),NumberSequenceKeypoint.new(0.1,0.2),NumberSequenceKeypoint.new(0.8,0.2),NumberSequenceKeypoint.new(1,1)})
    emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,targetBall.Size.X*0.8),NumberSequenceKeypoint.new(1,targetBall.Size.X*1.1)})
    emitter.Texture = "rbxassetid://286198181"; emitter.Lifetime = NumberRange.new(duration); emitter.Rate = 0; emitter.Speed = NumberRange.new(0)
    emitter.Rotation = NumberRange.new(0); emitter.RotSpeed = NumberRange.new(0); emitter.SpreadAngle = Vector2.new(0,0); emitter.LockedToPart = true; emitter.Parent = attachment
    emitter:Emit(1); print("Ball Circle VFX Playing for",duration,"seconds")
    Debris:AddItem(attachment,duration+0.5)
end

-- // VFX Function (V10 - Newest Ball VFX - White/Black from User) - UNCHANGED
local function playNewestBallVFX_V10(targetBall, duration)
    if not targetBall or not targetBall.Parent or not targetBall:IsA("BasePart") then warn("Newest Ball VFX (V10) Target invalid."); return end
    local Debris = game:GetService("Debris"); if not RunService:IsClient() then return end
    print("Newest Ball VFX (V10 - White/Black): Applying directly to ball: ", targetBall)
    local vfxContainer = Instance.new("Attachment") -- Use an attachment for better organization
    vfxContainer.Name = "NewestBallVFX_V10_Container"
    vfxContainer.Parent = targetBall
    local particles = {}
    local maxLifetime = 0

    -- Emitter 1 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.5, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4; particle.SpreadAngle = Vector2.new(0, 0)
        particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 0; particle.Speed = NumberRange.new(0.000589, 0.000589); particle.Brightness = 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,5.77432),NumberSequenceKeypoint.new(0.2,8.171552),NumberSequenceKeypoint.new(0.3,9.606454),NumberSequenceKeypoint.new(0.4,10.565664),NumberSequenceKeypoint.new(0.5,11.232748),NumberSequenceKeypoint.new(0.6,11.698775),NumberSequenceKeypoint.new(0.7,12.016293),NumberSequenceKeypoint.new(0.8,12.218694),NumberSequenceKeypoint.new(0.9,12.328683),NumberSequenceKeypoint.new(1,12.36249),NumberSequenceKeypoint.new(1,12.36249)})
        particle.Enabled = false; particle.Rate = 50; particle.Rotation = NumberRange.new(-180, 180)
        particle.Texture = "rbxassetid://16945167413"; particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Bottom; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end
    -- Emitter 2 (White/Black)
    do
        local particle = Instance.new("ParticleEmitter")
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.5, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4; particle.SpreadAngle = Vector2.new(0, 0)
        particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(0.6, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1.0, Color3.new(0,0,0))})
        particle.Drag = 0; particle.Speed = NumberRange.new(0.000589, 0.000589); particle.Brightness = 5
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.1,5.77432),NumberSequenceKeypoint.new(0.2,8.171552),NumberSequenceKeypoint.new(0.3,9.606454),NumberSequenceKeypoint.new(0.4,10.565664),NumberSequenceKeypoint.new(0.5,11.232748),NumberSequenceKeypoint.new(0.6,11.698775),NumberSequenceKeypoint.new(0.7,12.016293),NumberSequenceKeypoint.new(0.8,12.218694),NumberSequenceKeypoint.new(0.9,12.328683),NumberSequenceKeypoint.new(1,12.36249),NumberSequenceKeypoint.new(1,12.36249)})
        particle.Enabled = false; particle.Rate = 50; particle.Rotation = NumberRange.new(-180, 180)
        particle.Texture = "rbxassetid://16945167413"; particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Bottom; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 0
        particle.Parent = vfxContainer; table.insert(particles, particle)
    end

    for _, p in ipairs(particles) do p.Enabled = true; p:Emit(p.Rate * 0.1) end
    local cleanupTime = math.max(maxLifetime, duration) + 0.5
    Debris:AddItem(vfxContainer, cleanupTime)
    print("Newest Ball VFX (V10 - White/Black) Playing for", duration, "seconds. Cleanup in", cleanupTime, "s")
end

-- // Main Ability Function
local function TraumatizedShoot()
    if not IsReady() then print("Traumatized Shoot on cooldown."); return end
    if not playerHasBall() then print("Traumatized Shoot: Player does not have ball."); return end
    if not ShootRemote then print("Traumatized Shoot: ShootRemote missing!"); return end

    local ball = findBall()
    if not ball then print("Traumatized Shoot: Ball not found."); return end

    local opponentGoalPos = getOpponentGoalPos()
    if not opponentGoalPos then print("Traumatized Shoot: Opponent goal position not found."); return end

    StartCooldown()
    print("Traumatized Shoot Activated")

    -- Play Animation
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local anim = Instance.new("Animation"); anim.AnimationId = ANIMATION_ID
    local track = animator:LoadAnimation(anim)
    track:Play(0.1, 1, 1.2)
    Debris:AddItem(anim, track.Length / 1.2 + 0.1)

    -- Play Kick VFX on Player
    playKickVFX(rootPart, KICK_VFX_DURATION)

    -- Play SFX
    playSound(SOUND_ID_TRAUMA_SHOOT, rootPart)

    -- Shake Camera
    shakeCamera(10, 0.5)

    -- Apply Ball VFX (V5 & V10)
    playBallCircleVFX(ball, BALL_CIRCLE_VFX_DURATION)
    playNewestBallVFX_V10(ball, NEWEST_BALL_VFX_DURATION)

    -- Initial FireServer (Important for game logic)
    ShootRemote:FireServer(10) -- Low power, just to register the shot

    -- V11: Ensure physics cleanup before applying new forces
    cleanupBallPhysics(ball)
    task.wait(0.05) -- Small delay after cleanup

    -- Ball Lift & Freeze (Using BodyPosition)
    local bp = Instance.new("BodyPosition")
    bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bp.P = BALL_LIFT_FORCE
    bp.D = bp.P / 40 -- Damping
    bp.Position = ball.Position + Vector3.new(0, 3, 0) -- Lift slightly above current position
    bp.Parent = ball
    Debris:AddItem(bp, 0.5) -- Short duration for lift/freeze
    print("Traumatized Shoot: Ball Lift/Freeze applied.")

    -- Wait for lift/freeze to settle, then shoot
    task.wait(0.4) -- Wait slightly less than BP duration

    -- V11: Ensure physics cleanup AGAIN before applying final velocity
    cleanupBallPhysics(ball)
    task.wait(0.05)

    -- Apply Final Shot Velocity (BodyVelocity)
    local direction = (opponentGoalPos - ball.Position).Unit
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = direction * BALL_SPEED
    bv.Parent = ball
    print("Traumatized Shoot: Final Shot Velocity applied. Speed:", BALL_SPEED)

    -- V7: Schedule BodyVelocity removal
    Debris:AddItem(bv, BALL_VELOCITY_CLEANUP_TIME)
    print("Traumatized Shoot: BodyVelocity scheduled for removal in", BALL_VELOCITY_CLEANUP_TIME, "s")

    -- V11: Schedule Robust Physics Cleanup AFTER BodyVelocity removal
    task.delay(POST_SHOT_PHYSICS_CLEANUP_DELAY, function()
        print("Traumatized Shoot: Executing V11 Post-Shot Physics Cleanup.")
        local currentBall = findBall() -- Re-find ball in case reference changed
        cleanupBallPhysics(currentBall)
    end)
end

-- // --- UI Setup --- (Copied from Black Hole Strike, adapted)
local traumaShootButton = nil
local function setupAbilityUI_Trauma()
    local playerGui = player:WaitForChild("PlayerGui")
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn(ABILITY_NAME .. ": InGameUI not found."); return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn(ABILITY_NAME .. ": Bottom frame not found."); return end
    local bottomAbilities = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilities then warn(ABILITY_NAME .. ": Abilities Frame not found!"); return end
    local templateButton = bottomAbilities:FindFirstChild("1") or bottomAbilities:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME .. ": Template button ('1' or ImageButton) not found in Abilities Frame!"); return end

    local oldBtn = bottomAbilities:FindFirstChild(BUTTON_NAME)
    if oldBtn then oldBtn:Destroy() end
    task.wait(0.1)

    local button = templateButton:Clone()
    button.Name = BUTTON_NAME
    button.Parent = bottomAbilities
    button.LayoutOrder = LAYOUT_ORDER

    local keybindLabel = button:FindFirstChild("Keybind", true)
    local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
    local actualTimerLabel = button:FindFirstChild("ActualTimer", true)

    if keybindLabel and keybindLabel:IsA("TextLabel") then keybindLabel.Text = ABILITY_KEY.Name else warn(ABILITY_NAME .. ": Keybind Label not found") end
    if timerLabel and timerLabel:IsA("TextLabel") then timerLabel.Text = TIMER_TEXT else warn(ABILITY_NAME .. ": Timer Label not found") end
    if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = "" end

    local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown")
    if cdVisual then cdVisual:Destroy() end

    local abilityFrame = button:FindFirstChild("Ability") or button
    if abilityFrame then
        local cooldownFrame = Instance.new("Frame")
        cooldownFrame.Name = "Cooldown"
        cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        cooldownFrame.BackgroundTransparency = 0.6
        cooldownFrame.BorderSizePixel = 0
        cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
        cooldownFrame.Position = UDim2.new(0, 0, 1, 0) -- Start from bottom
        cooldownFrame.AnchorPoint = Vector2.new(0, 1) -- Anchor to bottom
        cooldownFrame.ZIndex = (abilityFrame:IsA("GuiObject") and abilityFrame.ZIndex or 1) + 1
        cooldownFrame.ClipsDescendants = true
        cooldownFrame.Parent = abilityFrame

        local uiCorner = Instance.new("UICorner", cooldownFrame)
        local absSize = abilityFrame:IsA("GuiObject") and abilityFrame.AbsoluteSize or Vector2.new(50,50)
        local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
        uiCorner.CornerRadius = UDim.new(0, radius)

        if abilityFrame:IsA("GuiObject") then
            abilityFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                local newAbsSize = abilityFrame.AbsoluteSize
                local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                uiCorner.CornerRadius = UDim.new(0, newRadius)
            end)
        end
    else
        warn(ABILITY_NAME .. ": Could not find 'Ability' frame or base button to parent cooldown visual")
    end

    traumaShootButton = button
    print(ABILITY_NAME .. ": UI Button Created")

    button.Activated:Connect(TraumatizedShoot)
    print(ABILITY_NAME .. ": Button Activated connected")
end

-- // Cooldown Update Loop (Timer Text)
RunService.Heartbeat:Connect(function(dt)
    if traumaShootButton and traumaShootButton.Parent then
        local timeLeft = lastTraumaShootTime + COOLDOWN - tick()
        local abilityFrame = traumaShootButton:FindFirstChild("Ability") or traumaShootButton
        local cooldownFrame = abilityFrame and abilityFrame:FindFirstChild("Cooldown")
        local timerLabel = traumaShootButton:FindFirstChild("Timer") or traumaShootButton:FindFirstChild("AbilityName", true)

        if timeLeft > 0 then
            if cooldownFrame then
                local progress = math.clamp(timeLeft / COOLDOWN, 0, 1)
                pcall(function() cooldownFrame.Size = UDim2.new(1, 0, progress, 0) end)
                cooldownFrame.Visible = true
            end
            if timerLabel and timerLabel:IsA("TextLabel") then
                pcall(function() timerLabel.Text = string.format("%.1fs", timeLeft) end)
            end
        else
            if cooldownFrame then cooldownFrame.Visible = false end
            if timerLabel and timerLabel:IsA("TextLabel") then
                if timerLabel.Text ~= TIMER_TEXT then
                    pcall(function() timerLabel.Text = TIMER_TEXT end)
                end
            end
        end
    end
end)

-- // Character Respawn Handling
player.CharacterAdded:Connect(function(newCharacter)
    print(ABILITY_NAME .. ": Character Added Event Fired")
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10)
    lastTraumaShootTime = 0
    print(ABILITY_NAME .. ": Character respawned, variables reset.")
    task.wait(0.5)
    if player:FindFirstChild("PlayerGui") then setupAbilityUI_Trauma() end
end)

-- // Input Handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY then
        TraumatizedShoot()
    end
end)

-- // Initial Setup
task.wait(1)
setupAbilityUI_Trauma()

print(ABILITY_NAME .. " Script Loaded Successfully! (V11)")


--[[
    Ability: ELASTO PASS - Standalone Test V67 (aPass Logic + SFX/Anim Fix)
    Creator: Manus (Based on User Requirements & Ace Style Reference)
    Version: V67 - Integrated aPass logic, fixed SFX/Anim playback.
]]

-- // Services
local Players = nil; local pcall_Players = pcall(function() Players = game:GetService("Players") end); if not pcall_Players then warn("Failed to get Players service") end
local ReplicatedStorage = nil; local pcall_RS = pcall(function() ReplicatedStorage = game:GetService("ReplicatedStorage") end); if not pcall_RS then warn("Failed to get ReplicatedStorage service") end
local UserInputService = nil; local pcall_UIS = pcall(function() UserInputService = game:GetService("UserInputService") end); if not pcall_UIS then warn("Failed to get UserInputService service") end
local RunService = nil; local pcall_RunS = pcall(function() RunService = game:GetService("RunService") end); if not pcall_RunS then warn("Failed to get RunService service") end
local Debris = nil; local pcall_Debris = pcall(function() Debris = game:GetService("Debris") end); if not pcall_Debris then warn("Failed to get Debris service") end
local Workspace = nil; local pcall_WS = pcall(function() Workspace = game:GetService("Workspace") end); if not pcall_WS then warn("Failed to get Workspace service") end
local Camera = nil; local pcall_Cam = pcall(function() Camera = Workspace and Workspace.CurrentCamera end); if not pcall_Cam or not Camera then warn("Failed to get Camera") end
local CoreGui = nil; local pcall_CG = pcall(function() CoreGui = game:GetService("CoreGui") end); if not pcall_CG then warn("Failed to get CoreGui service") end
local SoundService = nil; local pcall_SS = pcall(function() SoundService = game:GetService("SoundService") end); if not pcall_SS then warn("Failed to get SoundService service") end

-- Check if essential services loaded
if not Players or not ReplicatedStorage or not UserInputService or not RunService or not Debris or not Workspace or not CoreGui or not SoundService then
    warn("CRITICAL: One or more essential services failed to load. Script cannot continue.")
    return
end

-- // Player & Character Variables
local player = Players.LocalPlayer
if not player then warn("CRITICAL: LocalPlayer not found!"); return end

local playerGui = player:WaitForChild("PlayerGui", 10)
if not playerGui then warn("CRITICAL: PlayerGui not found!"); return end

local character = player.Character or player.CharacterAdded:Wait()
if not character then warn("CRITICAL: Character not found!"); return end

local humanoid = character:WaitForChild("Humanoid", 10)
if not humanoid then warn("CRITICAL: Humanoid not found!"); return end

local rootPart = character:WaitForChild("HumanoidRootPart", 10)
if not rootPart then warn("CRITICAL: HumanoidRootPart not found!"); return end

local playerValues = character:WaitForChild("Values", 10)
-- Values can be nil, will check when needed

-- // Remote Event Acquisition (Direct Path - Confirmed Working)
local shootEvent = nil
local function findShootRemoteStandardPath()
    print("Attempting Standard Path...")
    local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil
    if p then k=p:FindFirstChild("Knit",5) end
    if k then s=k:FindFirstChild("Services",5) end
    if s then b=s:FindFirstChild("BallService",5) end
    if b then r=b:FindFirstChild("RE",5) end
    local remote=r and r:FindFirstChild("Shoot",5)
    if remote and remote:IsA("RemoteEvent")then
        print("ShootRemote FOUND via Standard Path:",remote)
        return remote
    else
        warn("ShootRemote NOT found via Standard Path!")
        return nil
    end
end

local successShoot, resultShoot = pcall(function()
    shootEvent = findShootRemoteStandardPath()
end)
if not successShoot then warn("Error finding ShootRemote:", resultShoot) end
if not shootEvent then warn("!!! CRITICAL: ShootRemote could not be located. Ability may fail. !!!") end

-- // Ability Settings
local ABILITY_NAME = "Elasto Pass"
local ABILITY_KEY = Enum.KeyCode.C
local BUTTON_NAME = "ElastoPassButton"
local TIMER_TEXT = "Elasto Pass"
local LAYOUT_ORDER = 3
local APASS_VELOCITY = 250 -- Velocity from aPass.txt
local APASS_UPWARD_BIAS = 0.25 -- Upward bias from aPass.txt
local PASS_MAX_DURATION = 3.0 -- Max time velocity is applied (slightly increased)
local COOLDOWN = 1
local INITIAL_SHOOT_POWER = 30
local BALL_LIFT_FORCE = 100000
local BALL_LIFT_HEIGHT = 30
local BALL_FREEZE_DURATION = 0.5
local BALL_VFX_DURATION = 4 -- Duration for the VFX attached to the ball
local BUTTON_CLICK_VFX_DURATION = 4 -- Duration for the VFX played when button is clicked
local HIGHLIGHT_PULSE_SPEED = 1.5
local HIGHLIGHT_BASE_SIZE = UDim2.new(8, 0, 10, 0) -- Increased default base size
local HIGHLIGHT_SIZE_SCALE = 1.0 -- Multiplier for base size (e.g., 1.2 for 20% larger)
local HIGHLIGHT_TRANSPARENCY_VALUE = 0.7 -- Base transparency (0 = visible, 1 = invisible)
local HIGHLIGHT_PULSE_MIN_TRANSPARENCY = 0.6 -- Adjusted pulse range (relative to base transparency)
local HIGHLIGHT_PULSE_MAX_TRANSPARENCY = 0.85

-- // Sound/Animation IDs
local SOUND_ID_ELASTO_PASS = "rbxassetid://9125573611"
local SOUND_ID_ELASTO_IMPACT = "rbxassetid://9114487369"
local ANIM_ID_ELASTO_PASS = "rbxassetid://137923447090846"

-- // State & Connection Variables
local lastElastoPassTime = 0
local passVelocityConnection = nil
local currentTargetTeammate = nil
local targetHighlight = nil
local targetingConnection = nil
local highlightPulseConnection = nil
local isAbilityActive = false
local reinitializationTimer = nil
local abilityExecutionCount = 0
local currentPassAnimTrack = nil

-- // Sound Effects Container
local sfxContainer = nil
local successSFXContainer, resultSFXContainer = pcall(function()
    sfxContainer = Instance.new("Folder")
    sfxContainer.Name = "ElastoPassSFX_Container"
    sfxContainer.Parent = SoundService
end)
if not successSFXContainer then warn("Failed to create SFX container:", resultSFXContainer) end

-- // Helper Functions
local function IsReady()
    if isAbilityActive then print("Elasto Pass: Ability is currently active, cannot use again"); return false end
    local last=lastElastoPassTime or 0; if typeof(last)~="number" then last=0 end
    return tick()-last>=COOLDOWN
end

local function StartCooldown()
    lastElastoPassTime=tick(); isAbilityActive = true; abilityExecutionCount = abilityExecutionCount + 1
    print("Elasto Pass: Execution #" .. abilityExecutionCount)
end

-- // Simple SFX Player (Reliable)
local function playAbilitySound(soundId, volume, parentPart)
    if not soundId or soundId == "rbxassetid://YOUR_SOUND_ID_HERE" then print("SFX Skipped (Placeholder)"); return end
    if not sfxContainer and not parentPart then warn("Cannot play sound: No SFX container or parent part."); return end

    local success, result = pcall(function()
        local sound = Instance.new("Sound")
        sound.SoundId = soundId
        sound.Volume = volume or 1
        sound.Parent = parentPart or sfxContainer -- Parent to part if provided, else container
        sound:Play()
        print("Playing SFX:", soundId, "Volume:", sound.Volume, "Parent:", sound.Parent.Name)
        Debris:AddItem(sound, sound.TimeLength + 0.2) -- Auto cleanup
    end)
    if not success then
        warn("Failed to play sound", soundId, ":", result)
    end
end

-- // Simple Animation Player (Reliable)
local function playAbilityAnimation(animId)
    if not animId or animId == "rbxassetid://YOUR_ANIM_ID_HERE" then print("Animation Skipped (Placeholder)"); return nil end
    local currentCharacter = player.Character; if not currentCharacter then warn("playAbilityAnimation: Character not found"); return nil end
    local currentHumanoid = currentCharacter:FindFirstChild("Humanoid"); if not currentHumanoid then warn("playAbilityAnimation: Humanoid not found"); return nil end
    local animator = currentHumanoid:FindFirstChildOfClass("Animator"); if not animator then pcall(function() animator = Instance.new("Animator", currentHumanoid) end); if not animator then warn("playAbilityAnimation: Failed to create Animator"); return nil end end

    -- Stop previous animation if it's still playing
    if currentPassAnimTrack and currentPassAnimTrack.IsPlaying then
        pcall(function() currentPassAnimTrack:Stop() end)
        currentPassAnimTrack = nil
    end

    local animInstance = Instance.new("Animation"); animInstance.AnimationId = animId; animInstance.Parent = currentHumanoid
    local success, animTrack = pcall(function() return animator:LoadAnimation(animInstance) end)
    pcall(function() if animInstance and animInstance.Parent then animInstance:Destroy() end end) -- Clean up the temporary instance

    if success and animTrack then
        currentPassAnimTrack = animTrack -- Store the track
        pcall(function() animTrack:Play() end)
        print("Playing Animation:", animId)
        return animTrack
    else
        warn("Animation load/play failed:", animId, "| Error:", tostring(animTrack))
        return nil
    end
end

local function cleanupBallPhysics(ballInstance)
    if not ballInstance or not ballInstance.Parent or not ballInstance:IsA("BasePart") then return end
    pcall(function() for _, child in ipairs(ballInstance:GetChildren()) do if child:IsA("BodyMover") or child:IsA("BodyGyro") then pcall(function() child:Destroy() end) end end end)
end

local function findBallInWorkspace()
    local f = Workspace:FindFirstChild("Football")
    if f then
        local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
        if b and b:IsA("BasePart") then return b elseif f:IsA("Model") and f.PrimaryPart then return f.PrimaryPart elseif f:IsA("BasePart") then return f end
    end
    local charBall = player.Character and player.Character:FindFirstChild("BALL"); if charBall and charBall.Parent and charBall:IsA("BasePart") then return charBall end
    return nil
end

local function playerHasBall()
    local currentCharacter = player.Character; if not currentCharacter then return false end
    local v = currentCharacter:FindFirstChild("Values"); if not v then return false end
    local h = v:FindFirstChild("HasBall"); return h and h.Value == true
end

local function isPlayerInTeam(cP,tF)
    if not cP or not tF then return false end
    local success, result = pcall(function() for _,o in ipairs(tF:GetChildren()) do if o:IsA("ObjectValue")then if o.Value==cP or o.Name==cP.Name then return true end end end; return false end)
    if not success then warn("isPlayerInTeam error:", result); return false end; return result
end

local function getPlayerTeam(cP)
    if not cP then return nil end; local tf=ReplicatedStorage:FindFirstChild("Teams"); if not tf then return nil end
    local at=tf:FindFirstChild("AwayTeam"); local ht=tf:FindFirstChild("HomeTeam"); if not(at and ht)then return nil end
    if isPlayerInTeam(cP,at)then return at elseif isPlayerInTeam(cP,ht)then return ht else return nil end
end

-- // VFX Function: Button Click (User Provided)
local function playButtonClickVFX(duration)
    local currentCharacter = player.Character; if not currentCharacter then warn("Button Click VFX: Character missing"); return end
    local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart"); if not currentRootPart then warn("Button Click VFX: HRP missing"); return end
    if not RunService:IsClient() then return end
    print("Creating Button Click VFX for", duration, "seconds")

    local effectPart = nil
    local successPart, resultPart = pcall(function()
        local part = Instance.new("Part")
        part.Name = "ElastoPassButtonClickVFX"
        part.Anchored = true
        part.CanCollide = false
        part.Transparency = 1
        part.Parent = workspace
        local forward = currentRootPart.CFrame.LookVector
        local effectCFrame = CFrame.new(currentRootPart.Position + (forward * 5), currentRootPart.Position + (forward * 5) + forward)
        part.CFrame = effectCFrame
        return part
    end)
    if not successPart or not resultPart then warn("Failed to create Button Click VFX part:", resultPart); return end
    effectPart = resultPart

    local particles = {}
    local maxLifetime = 0

    local successVFX, errorVFX = pcall(function()
        do -- Emitter 1
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.2, 0.45); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-5, 5); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.199108, 0.265432), NumberSequenceKeypoint.new(0.399703, 0), NumberSequenceKeypoint.new(0.602526, 0), NumberSequenceKeypoint.new(0.799406, 0.246914), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -5; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(100, 150); particle.Brightness = 25; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 40.547779)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(700, 700); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-360, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://9324968005"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 2
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.3, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-40, 40); particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.196326, 0.2375), NumberSequenceKeypoint.new(0.406429, 0), NumberSequenceKeypoint.new(0.600459, 0), NumberSequenceKeypoint.new(0.797933, 0.2625), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityParallel; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 3; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -40; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.825), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(80, 120); particle.Brightness = 10; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2.75), NumberSequenceKeypoint.new(0.252568, 6.95611), NumberSequenceKeypoint.new(0.500568, 8.893476), NumberSequenceKeypoint.new(0.702568, 7.69388), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(0, 0); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(0, 0); particle.ShapePartial = 1; particle.Texture = "rbxassetid://16637904761"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = effectPart; table.insert(particles, particle)
        end
        do -- Emitter 3
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.2, 0.45); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-5, 5); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.199108, 0.265432), NumberSequenceKeypoint.new(0.399703, 0), NumberSequenceKeypoint.new(0.602526, 0), NumberSequenceKeypoint.new(0.799406, 0.246914), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -5; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(100, 150); particle.Brightness = 25; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 40.547779)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(700, 700); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-360, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://9324968005"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = effectPart; table.insert(particles, particle)
        end
    end)

    if not successVFX then
        warn("Failed to create Button Click VFX emitters:", errorVFX)
        pcall(function() if effectPart and effectPart.Parent then effectPart:Destroy() end end)
        return
    end

    for _, p in ipairs(particles) do p.Enabled = true; p:Emit(p.Rate * 0.1) end
    local cleanupTime = math.max(maxLifetime, duration) + 0.5
    Debris:AddItem(effectPart, cleanupTime)
    print("Button Click VFX Playing for", duration, "seconds. Cleanup in", cleanupTime, "s")
end

-- // VFX Function: Ball Trail (User Provided)
local function playBallTrailVFX(targetBall, duration)
    if not targetBall or not targetBall.Parent or not targetBall:IsA("BasePart") then warn("Ball Trail VFX: Target invalid"); return end
    if not RunService:IsClient() then return end
    print("Creating Ball Trail VFX for", duration, "seconds")

    local vfxContainer = nil
    local successContainer, resultContainer = pcall(function()
        local container = Instance.new("Attachment")
        container.Name = "ElastoPassBallTrailVFX"
        container.Parent = targetBall
        return container
    end)
    if not successContainer or not resultContainer then warn("Failed to create Ball Trail VFX container:", resultContainer); return end
    vfxContainer = resultContainer

    local particles = {}
    local maxLifetime = 0

    local successVFX, errorVFX = pcall(function()
        do -- Emitter 1
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.2, 0.45); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-5, 5); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.199108, 0.265432), NumberSequenceKeypoint.new(0.399703, 0), NumberSequenceKeypoint.new(0.602526, 0), NumberSequenceKeypoint.new(0.799406, 0.246914), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -5; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(100, 150); particle.Brightness = 25; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 40.547779)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(700, 700); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-360, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://9324968005"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = vfxContainer; table.insert(particles, particle)
        end
        do -- Emitter 2
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.3, 0.5); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-40, 40); particle.LockedToPart = false; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.196326, 0.2375), NumberSequenceKeypoint.new(0.406429, 0), NumberSequenceKeypoint.new(0.600459, 0), NumberSequenceKeypoint.new(0.797933, 0.2625), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityParallel; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 3; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -40; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.825), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(80, 120); particle.Brightness = 10; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2.75), NumberSequenceKeypoint.new(0.252568, 6.95611), NumberSequenceKeypoint.new(0.500568, 8.893476), NumberSequenceKeypoint.new(0.702568, 7.69388), NumberSequenceKeypoint.new(1, 0)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(0, 0); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(0, 0); particle.ShapePartial = 1; particle.Texture = "rbxassetid://16637904761"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = vfxContainer; table.insert(particles, particle)
        end
        do -- Emitter 3
            local particle = Instance.new("ParticleEmitter")
            particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume; particle.FlipbookFramerate = NumberRange.new(1, 1); particle.LightInfluence = 0; particle.Lifetime = NumberRange.new(0.2, 0.45); maxLifetime = math.max(maxLifetime, particle.Lifetime.Max); particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None; particle.SpreadAngle = Vector2.new(-5, 5); particle.LockedToPart = true; particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.199108, 0.265432), NumberSequenceKeypoint.new(0.399703, 0), NumberSequenceKeypoint.new(0.602526, 0), NumberSequenceKeypoint.new(0.799406, 0.246914), NumberSequenceKeypoint.new(1, 1)}); particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular; particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}); particle.Drag = 0; particle.FlipbookStartRandom = false; particle.TimeScale = 1; particle.VelocitySpread = -5; particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)}); particle.Speed = NumberRange.new(100, 150); particle.Brightness = 25; particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 40.547779)}); particle.Enabled = false; particle.Acceleration = Vector3.new(0, 0, 0); particle.RotSpeed = NumberRange.new(700, 700); particle.ZOffset = 0.30321580171585083; particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward; particle.Rate = 10; particle.VelocityInheritance = 0; particle.Rotation = NumberRange.new(-360, 360); particle.ShapePartial = 1; particle.Texture = "rbxassetid://9324968005"; particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop; particle.EmissionDirection = Enum.NormalId.Front; particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."; particle.Shape = Enum.ParticleEmitterShape.Box; particle.LightEmission = 5; particle.Parent = vfxContainer; table.insert(particles, particle)
        end
    end)

    if not successVFX then
        warn("Failed to create Ball Trail VFX emitters:", errorVFX)
        pcall(function() if vfxContainer and vfxContainer.Parent then vfxContainer:Destroy() end end)
        return
    end

    for _, p in ipairs(particles) do p.Enabled = true end
    local cleanupTime = math.max(maxLifetime, duration) + 0.5
    Debris:AddItem(vfxContainer, cleanupTime)
    print("Ball Trail VFX Playing for", duration, "seconds. Cleanup in", cleanupTime, "s")
end

-- // Teammate Targeting & Highlighting
local function findClosestTeammate(maxDist)
    local currentCharacter = player.Character; if not currentCharacter then return nil end
    local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart"); if not currentRootPart then return nil end
    local myTeam = getPlayerTeam(player); if not myTeam then return nil end

    local closestTeammate = nil; local minDist = maxDist or 150

    local success, result = pcall(function()
        for _, otherPlayer in ipairs(Players:GetPlayers()) do
            if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") and otherPlayer.Character:FindFirstChild("Humanoid") and otherPlayer.Character.Humanoid.Health > 0 then
                local otherTeam = getPlayerTeam(otherPlayer)
                if otherTeam == myTeam then
                    local otherRootPart = otherPlayer.Character.HumanoidRootPart
                    local dist = (currentRootPart.Position - otherRootPart.Position).Magnitude
                    if dist < minDist then
                        -- Raycast check for visibility
                        local ray = Ray.new(currentRootPart.Position, (otherRootPart.Position - currentRootPart.Position).Unit * dist)
                        local hit, pos = Workspace:FindPartOnRayWithIgnoreList(ray, {currentCharacter, otherPlayer.Character})
                        if not hit or hit:IsDescendantOf(otherPlayer.Character) then
                            minDist = dist
                            closestTeammate = otherPlayer
                        end
                    end
                end
            end
        end
    end)
    if not success then warn("Error finding teammate:", result) end
    return closestTeammate
end

local function createOrUpdateHighlight(targetPlayer)
    local targetCharacter = targetPlayer and targetPlayer.Character
    local targetHRP = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")

    if not targetHRP then
        if targetHighlight and targetHighlight.Parent then targetHighlight:Destroy() end
        targetHighlight = nil
        return
    end

    if not targetHighlight or not targetHighlight.Parent then
        local success, result = pcall(function()
            targetHighlight = Instance.new("Highlight")
            targetHighlight.Name = "ElastoPassTargetHighlight"
            targetHighlight.Adornee = targetHRP
            targetHighlight.FillColor = Color3.fromRGB(0, 255, 0) -- Green
            targetHighlight.OutlineColor = Color3.fromRGB(0, 100, 0)
            targetHighlight.FillTransparency = HIGHLIGHT_TRANSPARENCY_VALUE
            targetHighlight.OutlineTransparency = 0.5
            targetHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            targetHighlight.Parent = CoreGui -- Parent to CoreGui for visibility
        end)
        if not success then warn("Failed to create highlight:", result); targetHighlight = nil; return end
    else
        targetHighlight.Adornee = targetHRP -- Update adornee if it changed
    end
end

local function startHighlightPulse()
    if not targetHighlight or not targetHighlight.Parent then return end
    if highlightPulseConnection and highlightPulseConnection.Connected then highlightPulseConnection:Disconnect() end

    local startTime = tick()
    highlightPulseConnection = RunService.Heartbeat:Connect(function()
        if not targetHighlight or not targetHighlight.Parent then
            if highlightPulseConnection and highlightPulseConnection.Connected then highlightPulseConnection:Disconnect() end
            return
        end
        local elapsed = tick() - startTime
        local pulse = math.sin(elapsed * HIGHLIGHT_PULSE_SPEED * math.pi * 2) -- Sine wave for pulsing
        local minT = HIGHLIGHT_TRANSPARENCY_VALUE * HIGHLIGHT_PULSE_MIN_TRANSPARENCY
        local maxT = HIGHLIGHT_TRANSPARENCY_VALUE * HIGHLIGHT_PULSE_MAX_TRANSPARENCY
        targetHighlight.FillTransparency = minT + (maxT - minT) * (pulse * 0.5 + 0.5)
    end)
end

local function stopHighlightPulse()
    if highlightPulseConnection and highlightPulseConnection.Connected then highlightPulseConnection:Disconnect() end
    if targetHighlight and targetHighlight.Parent then
        targetHighlight.FillTransparency = HIGHLIGHT_TRANSPARENCY_VALUE -- Reset transparency
    end
end

local function startTargeting()
    if targetingConnection and targetingConnection.Connected then return end -- Already targeting
    print("Starting teammate targeting...")
    targetingConnection = RunService.Heartbeat:Connect(function()
        local teammate = findClosestTeammate()
        if teammate ~= currentTargetTeammate then
            currentTargetTeammate = teammate
            createOrUpdateHighlight(currentTargetTeammate)
            if currentTargetTeammate then
                startHighlightPulse()
            else
                stopHighlightPulse()
                if targetHighlight and targetHighlight.Parent then targetHighlight:Destroy(); targetHighlight = nil end
            end
        end
    end)
end

local function stopTargeting()
    if targetingConnection and targetingConnection.Connected then targetingConnection:Disconnect() end
    if targetHighlight and targetHighlight.Parent then targetHighlight:Destroy(); targetHighlight = nil end
    stopHighlightPulse()
    currentTargetTeammate = nil
    print("Stopped teammate targeting.")
end

-- // Main Ability Logic
local function ElastoPass()
    if not IsReady() then return end
    if not playerHasBall() then print("Elasto Pass: Player does not have ball."); return end
    if not shootEvent then print("Elasto Pass: ShootRemote missing!"); return end

    local ball = findBallInWorkspace()
    if not ball then print("Elasto Pass: Ball not found."); return end

    local targetTeammate = currentTargetTeammate -- Use the currently highlighted teammate
    if not targetTeammate or not targetTeammate.Character or not targetTeammate.Character:FindFirstChild("HumanoidRootPart") then
        print("Elasto Pass: No valid teammate targeted.")
        return
    end

    StartCooldown()
    stopTargeting() -- Stop targeting once pass is initiated

    print("Elasto Pass Activated towards", targetTeammate.Name)

    -- Play Animation & SFX
    playAbilityAnimation(ANIM_ID_ELASTO_PASS)
    playAbilitySound(SOUND_ID_ELASTO_PASS, 1, rootPart)
    playButtonClickVFX(BUTTON_CLICK_VFX_DURATION)

    -- Initial FireServer
    pcall(function() shootEvent:FireServer(INITIAL_SHOOT_POWER) end)

    -- Ball Lift (Briefly)
    cleanupBallPhysics(ball)
    task.wait(0.05)
    local bp = Instance.new("BodyPosition")
    bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bp.P = BALL_LIFT_FORCE
    bp.D = bp.P / 40
    bp.Position = ball.Position + Vector3.new(0, BALL_LIFT_HEIGHT, 0)
    bp.Parent = ball
    Debris:AddItem(bp, BALL_FREEZE_DURATION)
    print("Elasto Pass: Ball Lift applied.")

    -- Wait for lift, then apply pass velocity
    task.wait(BALL_FREEZE_DURATION * 0.8)

    -- Apply Pass Velocity (aPass Logic)
    cleanupBallPhysics(ball)
    task.wait(0.05)

    local targetHRP = targetTeammate.Character.HumanoidRootPart
    local direction = (targetHRP.Position - ball.Position).Unit
    local passVelocity = direction * APASS_VELOCITY + Vector3.new(0, APASS_VELOCITY * APASS_UPWARD_BIAS, 0)

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = passVelocity
    bv.Parent = ball
    print("Elasto Pass: Pass Velocity applied. Target:", targetTeammate.Name, "Velocity:", bv.Velocity)

    -- Play Ball Trail VFX
    playBallTrailVFX(ball, BALL_VFX_DURATION)

    -- Cleanup pass velocity after duration or if ball is touched
    local passStartTime = tick()
    local ballTouchedConnection = nil

    local function cleanupPassVelocity()
        if bv and bv.Parent then pcall(function() bv:Destroy() end) end
        if ballTouchedConnection and ballTouchedConnection.Connected then ballTouchedConnection:Disconnect() end
        playAbilitySound(SOUND_ID_ELASTO_IMPACT, 0.8, ball) -- Play impact sound on cleanup
        print("Elasto Pass: Pass velocity cleaned up.")
        isAbilityActive = false -- Allow reuse after cleanup
    end

    ballTouchedConnection = ball.Touched:Connect(function(hit)
        if hit and hit.Parent and hit.Parent:FindFirstChild("Humanoid") and hit.Parent ~= character then
            print("Elasto Pass: Ball touched by", hit.Parent.Name)
            cleanupPassVelocity()
        end
    end)

    Debris:AddItem(bv, PASS_MAX_DURATION)
    task.delay(PASS_MAX_DURATION + 0.1, function()
        if bv and bv.Parent then cleanupPassVelocity() end -- Ensure cleanup if not touched
    end)
end

-- // --- UI Setup --- (Adapted from other scripts)
local elastoPassButton = nil
local function setupAbilityUI_Elasto()
    local playerGui = player:WaitForChild("PlayerGui")
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn(ABILITY_NAME .. ": InGameUI not found."); return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn(ABILITY_NAME .. ": Bottom frame not found."); return end
    local bottomAbilities = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilities then warn(ABILITY_NAME .. ": Abilities Frame not found!"); return end
    local templateButton = bottomAbilities:FindFirstChild("1") or bottomAbilities:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME .. ": Template button ("1" or ImageButton) not found in Abilities Frame!"); return end

    local oldBtn = bottomAbilities:FindFirstChild(BUTTON_NAME)
    if oldBtn then pcall(function() oldBtn:Destroy() end) end
    task.wait(0.1)

    local success, button = pcall(function() return templateButton:Clone() end)
    if not success or not button then warn("Failed to clone button for Elasto Pass"); return end

    button.Name = BUTTON_NAME
    button.Parent = bottomAbilities
    button.LayoutOrder = LAYOUT_ORDER

    local keybindLabel = button:FindFirstChild("Keybind", true)
    local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
    local actualTimerLabel = button:FindFirstChild("ActualTimer", true)

    if keybindLabel and keybindLabel:IsA("TextLabel") then pcall(function() keybindLabel.Text = ABILITY_KEY.Name end) else warn(ABILITY_NAME .. ": Keybind Label not found") end
    if timerLabel and timerLabel:IsA("TextLabel") then pcall(function() timerLabel.Text = TIMER_TEXT end) else warn(ABILITY_NAME .. ": Timer Label not found") end
    if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then pcall(function() actualTimerLabel.Text = "" end) end

    local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown")
    if cdVisual then pcall(function() cdVisual:Destroy() end) end

    local abilityFrame = button:FindFirstChild("Ability") or button
    if abilityFrame then
        local successCD, cooldownFrame = pcall(function()
            local frame = Instance.new("Frame")
            frame.Name = "Cooldown"
            frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            frame.BackgroundTransparency = 0.6
            frame.BorderSizePixel = 0
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.Position = UDim2.new(0, 0, 1, 0) -- Start from bottom
            frame.AnchorPoint = Vector2.new(0, 1) -- Anchor to bottom
            frame.ZIndex = (abilityFrame:IsA("GuiObject") and abilityFrame.ZIndex or 1) + 1
            frame.ClipsDescendants = true
            frame.Parent = abilityFrame

            local uiCorner = Instance.new("UICorner", frame)
            local absSize = abilityFrame:IsA("GuiObject") and abilityFrame.AbsoluteSize or Vector2.new(50,50)
            local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
            uiCorner.CornerRadius = UDim.new(0, radius)

            if abilityFrame:IsA("GuiObject") then
                abilityFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                    local newAbsSize = abilityFrame.AbsoluteSize
                    local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                    pcall(function() uiCorner.CornerRadius = UDim.new(0, newRadius) end)
                end)
            end
            return frame
        end)
        if not successCD then warn("Failed to create cooldown visual:", cooldownFrame) end
    else
        warn(ABILITY_NAME .. ": Could not find 'Ability' frame or base button to parent cooldown visual")
    end

    elastoPassButton = button
    print(ABILITY_NAME .. ": UI Button Created")

    button.Activated:Connect(ElastoPass)
    print(ABILITY_NAME .. ": Button Activated connected")
end

-- // Cooldown Update Loop (Timer Text)
RunService.Heartbeat:Connect(function(dt)
    if elastoPassButton and elastoPassButton.Parent then
        local timeLeft = (lastElastoPassTime or 0) + COOLDOWN - tick()
        local abilityFrame = elastoPassButton:FindFirstChild("Ability") or elastoPassButton
        local cooldownFrame = abilityFrame and abilityFrame:FindFirstChild("Cooldown")
        local timerLabel = elastoPassButton:FindFirstChild("Timer") or elastoPassButton:FindFirstChild("AbilityName", true)

        if timeLeft > 0 then
            if cooldownFrame then
                local progress = math.clamp(timeLeft / COOLDOWN, 0, 1)
                pcall(function() cooldownFrame.Size = UDim2.new(1, 0, progress, 0) end)
                cooldownFrame.Visible = true
            end
            if timerLabel and timerLabel:IsA("TextLabel") then
                pcall(function() timerLabel.Text = string.format("%.1fs", timeLeft) end)
            end
        else
            if cooldownFrame then cooldownFrame.Visible = false end
            if timerLabel and timerLabel:IsA("TextLabel") then
                if timerLabel.Text ~= TIMER_TEXT then
                    pcall(function() timerLabel.Text = TIMER_TEXT end)
                end
            end
        end
    end
end)

-- // Character Respawn Handling
player.CharacterAdded:Connect(function(newCharacter)
    print(ABILITY_NAME .. ": Character Added Event Fired")
    character = newCharacter
    humanoid = newCharacter:WaitForChild("Humanoid", 10)
    rootPart = newCharacter:WaitForChild("HumanoidRootPart", 10)
    playerValues = newCharacter:WaitForChild("Values", 10)
    lastElastoPassTime = 0
    isAbilityActive = false
    stopTargeting() -- Ensure targeting stops on respawn
    if currentPassAnimTrack then pcall(function() currentPassAnimTrack:Stop() end); currentPassAnimTrack = nil end
    print(ABILITY_NAME .. ": Character respawned, variables reset.")
    task.wait(0.5)
    if player:FindFirstChild("PlayerGui") then setupAbilityUI_Elasto() end
end)

-- // Input Handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY then
        ElastoPass()
    end
end)

-- // Initial Setup
task.wait(1)
setupAbilityUI_Elasto()
startTargeting() -- Start targeting teammates on load

print(ABILITY_NAME .. " Script Loaded Successfully! (V67)")


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local SoundService = game:GetService("SoundService")

-- // Player & Character Variables
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- // Animation Variables
local movementAnimation = Instance.new("Animation")
movementAnimation.AnimationId = "rbxassetid://74249210159048"
local movementAnimTrack = nil

-- // Knit Framework (Used in the game)
local Knit = require(ReplicatedStorage.Packages.Knit)
local StatesController = Knit.GetController("StatesController")

-- // --- CONFIGURABLE VALUES --- //
-- Key binding for PC
local ABILITY_KEY_GR = Enum.KeyCode.G  -- Default key for Glitch Rush

-- Cooldown
local COOLDOWN_GR = 3  -- Cooldown in seconds

-- Glitch Effect (Left-Right Illusion)
local GLITCH_DURATION = 1.5  -- Duration of glitch effect in seconds (adjustable: 1-2 seconds)
local GLITCH_FREQUENCY = 0.05  -- How quickly to move left-right (lower = faster)
local GLITCH_DISTANCE = 6  -- How far to move left/right during glitch effect
local GLITCH_ITERATIONS = 30  -- Number of left-right movements

-- First Dash
local DASH1_DISTANCE = 3.0  -- Distance of first forward dash in studs
local DASH1_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH1_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH1_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during first dash

-- Wait Time Between Dashes
local WAIT_BETWEEN_DASHES = 1.0  -- Wait time between dashes (in seconds)

-- Second Dash
local DASH2_DISTANCE = 3.0  -- Distance of second forward dash in studs
local DASH2_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH2_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH2_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during second dash

-- Third Dash
local DASH3_DISTANCE = 3.0  -- Distance of third forward dash in studs
local DASH3_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH3_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH3_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during third dash

-- Visual Effects
local GLITCH_COLOR_PRIMARY = Color3.fromRGB(255, 255, 255)  -- White
local GLITCH_COLOR_SECONDARY = Color3.fromRGB(0, 0, 0)  -- Black

-- // --- ANIMATION IDs --- //
local DASH_ANIMATION_ID = "rbxassetid://131979551237806"  -- Dash animation ID

-- // --- SOUND IDs --- //
local SOUND_ID_DASH = "rbxassetid://3084314259"  -- Updated dash sound effect ID
local SOUND_ID_ACTIVATION = "rbxassetid://YOUR_ACTIVATION_SOUND_ID"  -- Activation sound ID (placeholder)
local SOUND_ID_LEFT_RIGHT = "rbxassetid://6896112317"  -- Left-right movement sound ID

-- Sound Properties
local DASH_SOUND_VOLUME = 5
local DASH_SOUND_LIFETIME = 2.0  -- How long before the sound is automatically destroyed
local LEFT_RIGHT_SOUND_VOLUME = 5  -- Volume for left-right movement sound

-- // --- END CONFIGURABLE VALUES --- //

-- // Button and UI Variables
local ABILITY_NAME_GR = "GlitchRush"
local BUTTON_NAME_GR = "custom"  -- As specified by user
local TIMER_TEXT_GR = "GLITCH RUSH"  -- As specified by user
local lastGlitchRushTime = 0
local glitchRushButton = nil
local isAbilityActive_GR = false

-- // Animation Variables
local dashAnimation = nil
local dashAnimTrack = nil

-- // Helper Functions
local function IsReady_GR() 
    return tick() - lastGlitchRushTime >= COOLDOWN_GR 
end

local function StartCooldown_GR()
    lastGlitchRushTime = tick()
    if glitchRushButton then
        local cooldownFrame = glitchRushButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local tweenInfo = TweenInfo.new(COOLDOWN_GR, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(uiGradient, tweenInfo, {Offset = Vector2.new(0, 1)})
                uiGradient.Offset = Vector2.new(0, 0)
                tween:Play()
            end
        end
    end
end

-- // Create and Play Sound Effect
local function CreateAndPlaySound(soundId, parent, volume, lifetime)
    -- Default values if not provided
    parent = parent or rootPart
    volume = volume or 1.0
    lifetime = lifetime or 2.0
    
    -- Validate parent
    if not parent or not parent:IsA("Instance") then
        warn("Sound Effect: Invalid parent for sound")
        return nil
    end
    
    -- Create sound instance
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume
    sound.Name = "AbilitySound_" .. tick()
    sound.Parent = parent
    
    -- Play the sound
    pcall(function()
        sound:Play()
        print("Sound Effect: Playing sound " .. soundId)
    end)
    
    -- Schedule cleanup if lifetime is provided
    if lifetime > 0 then
        Debris:AddItem(sound, lifetime)
    end
    
    return sound
end

-- // Create Looping Sound Effect
local function CreateLoopingSound(soundId, parent, volume)
    local sound = CreateAndPlaySound(soundId, parent, volume, 0) -- 0 lifetime means no auto-cleanup
    
    if sound then
        sound.Looped = true
    end
    
    return sound
end

-- // Stop and Clean Up Sound
local function StopAndCleanupSound(sound)
    if sound and sound.Parent then
        pcall(function()
            sound:Stop()
            sound:Destroy()
            print("Sound Effect: Stopped and cleaned up sound")
        end)
    end
end

-- // Preload Dash Animation
local function PreloadDashAnimation()
    -- Create animation object
    dashAnimation = Instance.new("Animation")
    dashAnimation.AnimationId = DASH_ANIMATION_ID
    
    -- Load animation on humanoid
    if humanoid then
        dashAnimTrack = humanoid:LoadAnimation(dashAnimation)
        
        -- Configure animation properties
        dashAnimTrack.Priority = Enum.AnimationPriority.Action
        dashAnimTrack.Looped = false
        
        -- Note: FadeTime is not a property of AnimationTrack
        -- Instead, we'll pass the fade time when playing the animation
        
        print("Glitch Rush: Dash animation preloaded successfully")
    else
        warn("Glitch Rush: Failed to preload dash animation - humanoid not found")
    end
end

-- // Get Player's Current Pointing Direction
local function GetPlayerPointingDirection(humanoid)
    -- First try to get direction from humanoid's MoveDirection
    if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
        return humanoid.MoveDirection.Unit
    end
    
    -- If not moving, use the direction the character is facing
    if rootPart then
        return rootPart.CFrame.LookVector
    end
    
    -- Fallback to camera direction if all else fails
    return Camera.CFrame.LookVector
end

-- // Perform smooth left-right movement for illusion effect
local function PerformLeftRightIllusion(rootPart, duration, frequency, distance, iterations)
    if not rootPart then return end
    
    -- Create and play the left-right movement sound (looping)
    local leftRightSound = CreateLoopingSound(SOUND_ID_LEFT_RIGHT, rootPart, LEFT_RIGHT_SOUND_VOLUME)
    
    local startTime = tick()
    local rightVector = rootPart.CFrame.RightVector -- Initial right vector for consistency
    
    -- Create a counter for iterations
    local iterationCount = 0
    local direction = 1  -- Start by moving right
    
    -- Create a connection to the heartbeat event for smooth movement
    local connection
    connection = RunService.Heartbeat:Connect(function()
        -- Check if we've exceeded the duration or iterations
        if (tick() - startTime > duration) or (iterationCount >= iterations) then
            if connection then
                connection:Disconnect()
                connection = nil
            end
            return
        end
        
        -- Only move at the frequency rate
        if (tick() - startTime) % frequency < 0.01 then
            -- Calculate movement offset - alternating left and right
            local sideOffset = rightVector * (direction * distance)
            
            -- Get current position and preserve Y value
            local currentPos = rootPart.Position
            local newPos = currentPos + sideOffset
            newPos = Vector3.new(newPos.X, currentPos.Y, newPos.Z)  -- Maintain Y position
            
            -- Move to the new position while maintaining current orientation
            local currentOrientation = rootPart.CFrame - rootPart.Position
            rootPart.CFrame = CFrame.new(newPos) * currentOrientation
            
            -- Flip direction for next movement
            direction = -direction
            iterationCount = iterationCount + 1
        end
    end)
    
    -- Wait for the illusion effect to complete
    task.wait(duration)
    
    -- Ensure connection is cleaned up
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    -- Stop and clean up the left-right movement sound
    StopAndCleanupSound(leftRightSound)
    
    -- No need to reset position - allow player to end up where they moved to
    return leftRightSound -- Return the sound reference in case we need to stop it early
end

-- // Perform anti-cheat safe forward dash
local function PerformAntiCheatSafeDash(rootPart, humanoid, direction, totalDistance, steps, stepDelay, speedMultiplier, isLastDash)
    if not rootPart or not direction or not humanoid then return end
    
    local stepDistance = totalDistance / steps
    local originalCFrame = rootPart.CFrame
    local originalWalkSpeed = humanoid.WalkSpeed
    
    -- Create a temporary speed boost effect
    humanoid.WalkSpeed = originalWalkSpeed * speedMultiplier
    
    -- Create a BodyVelocity for smoother movement
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(50000, 0, 50000)  -- Only apply force horizontally
    bodyVelocity.P = 1250  -- Adjust this for responsiveness
    bodyVelocity.Velocity = direction * (stepDistance / stepDelay) * 1.5  -- Slightly boost velocity for effect
    bodyVelocity.Parent = rootPart
    
    -- Play dash animation with fade time parameter
    if dashAnimTrack then
        dashAnimTrack:Play(0.1) -- 0.1 second fade time
        print("Glitch Rush: Playing dash animation")
    else
        -- Try to load animation if not already loaded
        PreloadDashAnimation()
        if dashAnimTrack then
            dashAnimTrack:Play(0.1) -- 0.1 second fade time
            print("Glitch Rush: Playing dash animation (after reload)")
        else
            warn("Glitch Rush: Failed to play dash animation - track not available")
        end
    end
    
    -- Play dash sound effect
    CreateAndPlaySound(SOUND_ID_DASH, rootPart, DASH_SOUND_VOLUME, DASH_SOUND_LIFETIME)
    
    -- Perform the forward dash in small steps to avoid anti-cheat detection
    for i = 1, steps do
        -- Calculate the new position
        local newPos = rootPart.Position + (direction * stepDistance)
        newPos = Vector3.new(newPos.X, rootPart.Position.Y, newPos.Z)  -- Maintain Y position
        
        -- Move to the new position while maintaining orientation
        rootPart.CFrame = CFrame.new(newPos) * CFrame.Angles(
            originalCFrame:ToOrientation()
        )
        
        -- Small wait between steps
        task.wait(stepDelay)
    end
    
    -- Clean up the BodyVelocity
    if bodyVelocity and bodyVelocity.Parent then
        bodyVelocity:Destroy()
    end
    
    -- Restore original walk speed
    humanoid.WalkSpeed = originalWalkSpeed
    
    -- Explicitly stop the animation if this is the last dash
    if isLastDash and dashAnimTrack then
        dashAnimTrack:Stop()
        print("Glitch Rush: Explicitly stopping dash animation after final dash")
    end
    -- Otherwise animation will stop automatically since it's not looped
end

-- // Main Glitch Rush Function
local function GlitchRush()
    if isAbilityActive_GR then 
        print("Glitch Rush: Ability already active.")
        return 
    end
    
    if not IsReady_GR() then 
        print("Glitch Rush: Ability on cooldown.")
        return 
    end
    
    -- Update character references
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    if not (humanoid and rootPart) then 
        print("Glitch Rush: Character components missing.")
        return 
    end
    
    -- VFX CODE START
    local effectDuration = 5 -- Duration in seconds before the effect disappears

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    if not RunService:IsClient() then return end

    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    local effectPart = Instance.new("Part")
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Parent = workspace

    -- Initial position - directly on the player
    local effectCFrame = humanoidRootPart.CFrame
    effectPart.CFrame = effectCFrame

    local function createFolderPath(parent, path)
        if not path or path == "" then return parent end
        
        local current = parent
        for _, name in ipairs(string.split(path, ".")) do
            local existing = current:FindFirstChild(name)
            if not existing then
                local new = Instance.new("Folder")
                new.Name = name
                new.Parent = current
                current = new
            else
                current = existing
            end
        end
        return current
    end

    local particles = {}

    do
        local particle = Instance.new("ParticleEmitter")
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.300000, 0.400000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(15.000000, 15.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.598806, 0.000000), NumberSequenceKeypoint.new(0.720159, 0.618750), NumberSequenceKeypoint.new(0.872679, 0.925000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 15
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.001000, 0.001000)
        particle.Brightness = 3
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 1.500000), NumberSequenceKeypoint.new(0.200000, 2.500000), NumberSequenceKeypoint.new(0.300000, 3.000000), NumberSequenceKeypoint.new(0.400000, 3.500000), NumberSequenceKeypoint.new(0.500000, 4.000000), NumberSequenceKeypoint.new(0.600000, 4.500000), NumberSequenceKeypoint.new(0.700000, 5.000000), NumberSequenceKeypoint.new(0.800000, 5.500000), NumberSequenceKeypoint.new(0.900000, 6.000000), NumberSequenceKeypoint.new(1.000000, 6.500000)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 0.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://17258046088"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0
        particle.Parent = parent
        table.insert(particles, particle)
    end

    do
        local particle = Instance.new("ParticleEmitter")
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.300000, 0.400000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(15.000000, 15.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.598806, 0.000000), NumberSequenceKeypoint.new(0.720159, 0.618750), NumberSequenceKeypoint.new(0.872679, 0.925000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.Drag = 0
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 15
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.001000, 0.001000)
        particle.Brightness = 3
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 1.500000), NumberSequenceKeypoint.new(0.200000, 2.500000), NumberSequenceKeypoint.new(0.300000, 3.000000), NumberSequenceKeypoint.new(0.400000, 3.500000), NumberSequenceKeypoint.new(0.500000, 4.000000), NumberSequenceKeypoint.new(0.600000, 4.500000), NumberSequenceKeypoint.new(0.700000, 5.000000), NumberSequenceKeypoint.new(0.800000, 5.500000), NumberSequenceKeypoint.new(0.900000, 6.000000), NumberSequenceKeypoint.new(1.000000, 6.500000)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(0.000000, 0.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://17258046088"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Front
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.LightEmission = 0
        particle.Parent = parent
        table.insert(particles, particle)
    end

    -- Enable all particles
    for _, p in ipairs(particles) do
        p.Enabled = true
    end

    -- Function to update effect position
    local function updateEffectPosition()
        if effectPart and effectPart.Parent and humanoidRootPart and humanoidRootPart.Parent then
            effectPart.CFrame = humanoidRootPart.CFrame
        end
    end

    -- Connect to RenderStepped to keep the effect on the player
    local connection = RunService.RenderStepped:Connect(updateEffectPosition)

    -- Schedule cleanup
    game:GetService("Debris"):AddItem(effectPart, effectDuration)

    -- Disconnect the update function after the duration
    task.delay(effectDuration, function()
        if connection then
            connection:Disconnect()
        end
    end)
    -- VFX CODE END
    
    isAbilityActive_GR = true
    StartCooldown_GR()
    print("Glitch Rush Activated")
    
    -- Play activation sound
    CreateAndPlaySound(SOUND_ID_ACTIVATION, rootPart, 1.0, 2.0)
    
    -- Get the direction the player is pointing
    local pointingDirection = GetPlayerPointingDirection(humanoid)
    
    -- Perform the first dash
    PerformAntiCheatSafeDash(rootPart, humanoid, pointingDirection, DASH1_DISTANCE, DASH1_STEPS, DASH1_STEP_DELAY, DASH1_SPEED_MULTIPLIER, false)
    
    -- Wait between dashes
    task.wait(WAIT_BETWEEN_DASHES)
    
    -- Perform the second dash
    PerformAntiCheatSafeDash(rootPart, humanoid, pointingDirection, DASH2_DISTANCE, DASH2_STEPS, DASH2_STEP_DELAY, DASH2_SPEED_MULTIPLIER, false)
    
    -- Wait between dashes
    task.wait(WAIT_BETWEEN_DASHES)
    
    -- Perform the third dash
    PerformAntiCheatSafeDash(rootPart, humanoid, pointingDirection, DASH3_DISTANCE, DASH3_STEPS, DASH3_STEP_DELAY, DASH3_SPEED_MULTIPLIER, true)
    
    -- Ability finished
    isAbilityActive_GR = false
    print("Glitch Rush Finished")
end

-- // --- UI Setup --- //
local function setupAbilityUI_GR()
    local playerGui = player:WaitForChild("PlayerGui")
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn(ABILITY_NAME_GR .. ": InGameUI not found."); return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn(ABILITY_NAME_GR .. ": Bottom frame not found."); return end
    local bottomAbilities = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilities then warn(ABILITY_NAME_GR .. ": Abilities Frame not found!"); return end
    local templateButton = bottomAbilities:FindFirstChild("1") or bottomAbilities:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME_GR .. ": Template button ('1' or ImageButton) not found in Abilities Frame!"); return end

    -- Remove existing button if it exists
    local oldBtn = bottomAbilities:FindFirstChild(BUTTON_NAME_GR)
    if oldBtn then oldBtn:Destroy() end
    task.wait(0.1)

    -- Create new button
    local button = templateButton:Clone()
    button.Name = BUTTON_NAME_GR
    button.Parent = bottomAbilities
    button.LayoutOrder = 7 -- Adjust layout order as needed

    local keybindLabel = button:FindFirstChild("Keybind", true)
    local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
    local actualTimerLabel = button:FindFirstChild("ActualTimer", true)

    if keybindLabel and keybindLabel:IsA("TextLabel") then keybindLabel.Text = ABILITY_KEY_GR.Name else warn(ABILITY_NAME_GR .. ": Keybind Label not found") end
    if timerLabel and timerLabel:IsA("TextLabel") then timerLabel.Text = TIMER_TEXT_GR else warn(ABILITY_NAME_GR .. ": Timer Label not found") end
    if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = "" end

    -- Cooldown Visual Setup (Gradient Style)
    local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown")
    if cdVisual then cdVisual:Destroy() end

    local abilityFrame = button:FindFirstChild("Ability") or button
    if abilityFrame then
        local cooldownFrame = Instance.new("Frame")
        cooldownFrame.Name = "Cooldown"
        cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        cooldownFrame.BackgroundTransparency = 0.6
        cooldownFrame.BorderSizePixel = 0
        cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
        cooldownFrame.Position = UDim2.new(0, 0, 0, 0)
        cooldownFrame.AnchorPoint = Vector2.new(0, 0)
        cooldownFrame.ZIndex = (abilityFrame:IsA("GuiObject") and abilityFrame.ZIndex or 1) + 1
        cooldownFrame.ClipsDescendants = true
        cooldownFrame.Parent = abilityFrame

        local uiGradient = Instance.new("UIGradient")
        uiGradient.Color = ColorSequence.new(Color3.fromRGB(0,0,0), Color3.fromRGB(0,0,0))
        uiGradient.Transparency = NumberSequence.new(0.6, 1)
        uiGradient.Rotation = 90
        uiGradient.Offset = Vector2.new(0, 1) -- Start fully transparent (covered)
        uiGradient.Parent = cooldownFrame

        local uiCorner = Instance.new("UICorner", cooldownFrame)
        local absSize = abilityFrame:IsA("GuiObject") and abilityFrame.AbsoluteSize or Vector2.new(50,50)
        local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
        uiCorner.CornerRadius = UDim.new(0, radius)

        if abilityFrame:IsA("GuiObject") then
            abilityFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                local newAbsSize = abilityFrame.AbsoluteSize
                local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                uiCorner.CornerRadius = UDim.new(0, newRadius)
            end)
        end
    else
        warn(ABILITY_NAME_GR .. ": Could not find 'Ability' frame or base button to parent cooldown visual")
    end

    glitchRushButton = button
    print(ABILITY_NAME_GR .. ": UI Button Created")

    -- Connect Activation
    button.Activated:Connect(GlitchRush)
    print(ABILITY_NAME_GR .. ": Button Activated connected")
end

-- // Cooldown Update Loop (Timer Text)
RunService.Heartbeat:Connect(function(dt)
    if glitchRushButton and glitchRushButton.Parent then
        local timeLeft = lastGlitchRushTime + COOLDOWN_GR - tick()
        local timerLabel = glitchRushButton:FindFirstChild("Timer") or glitchRushButton:FindFirstChild("AbilityName", true)
        if timerLabel and timerLabel:IsA("TextLabel") then
            if timeLeft > 0 then
                timerLabel.Text = string.format("%.1fs", timeLeft)
            else
                if timerLabel.Text ~= TIMER_TEXT_GR then
                    timerLabel.Text = TIMER_TEXT_GR
                end
            end
        end
    end
end)

-- // Character Respawn Handling
player.CharacterAdded:Connect(function(newCharacter)
    print(ABILITY_NAME_GR .. ": Character Added Event Fired")
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    lastGlitchRushTime = 0
    isAbilityActive_GR = false
    
    -- Preload animation again for the new character
    PreloadDashAnimation()
    
    print(ABILITY_NAME_GR .. ": Character respawned, variables reset.")
    
    -- Re-setup UI if needed
    task.wait(0.5) -- Give UI time to potentially load
    if player:FindFirstChild("PlayerGui") then setupAbilityUI_GR() end
end)

-- // Input Handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY_GR then
        GlitchRush()
    end
end)

-- // Initial Setup
task.wait(1) -- Wait a bit for game elements to load
PreloadDashAnimation() -- Preload animation on initial load
setupAbilityUI_GR()

print(ABILITY_NAME_GR .. " Script Loaded Successfully!")

