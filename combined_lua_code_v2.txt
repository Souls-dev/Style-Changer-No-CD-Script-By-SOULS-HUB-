--[[
    Style Name: EGO JINPANCHI
    Rarity: World Class
    Description: TRUE INJURED EGOIST WHO ONCE RULE THE FIELD
    Creator: Gemini (Based on User Prompt)
]]

-- // Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
-- // Player & Character Variables
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
-- // Knit Framework References (Added more checks)
local KnitPackage = ReplicatedStorage:WaitForChild("Packages", 5):WaitForChild("Knit", 5)
if not KnitPackage then warn("Knit package not found!") return end -- Stop if Knit package missing
local KnitPresent, Knit = pcall(require, KnitPackage)
if not KnitPresent or not Knit then warn("Failed to require Knit framework.") return end -- Stop if require fails
-- Attempt to get Services, check type rigorously
local BallService = Knit.GetService and Knit.GetService("BallService")
local AbilityService = Knit.GetService and Knit.GetService("AbilityService")
local TeamService = Knit.GetService and Knit.GetService("TeamService")
local StatesController = Knit.GetController and Knit.GetController("StatesController")
-- // Remote Events (Revised with TYPE checks and more specific waits)
local BallServiceRE, AbilityServiceRE
local ShootRemote, SlideRemote, DribbleRemote, BodyBlockAbilityRemote, BodyBlockUsedRemote
-- Wait for BallService RE table only if BallService is a valid Instance
if BallService and typeof(BallService) == "userdata" and BallService.ClassName == "Instance" then -- Check ClassName for services
    BallServiceRE = BallService:WaitForChild("RE", 10) -- Increased wait time
    if BallServiceRE then
        ShootRemote = BallServiceRE:WaitForChild("Shoot", 5)
        SlideRemote = BallServiceRE:WaitForChild("Slide", 5)
        DribbleRemote = BallServiceRE:WaitForChild("Dribble", 5)
    else
        warn("BallService.RE table not found after waiting!")
    end
else
    warn("BallService is not a valid Instance or is nil.")
end
-- Wait for AbilityService RE table only if AbilityService is a valid Instance
if AbilityService and typeof(AbilityService) == "userdata" and AbilityService.ClassName == "Instance" then
    AbilityServiceRE = AbilityService:WaitForChild("RE", 10)
    if AbilityServiceRE then
        BodyBlockAbilityRemote = AbilityServiceRE:WaitForChild("Ability", 5)
        BodyBlockUsedRemote = AbilityServiceRE:WaitForChild("AbilityUsed", 5)
        warn("AbilityService.RE table not found after waiting!")
     warn("AbilityService is not a valid Instance or is nil.")
-- Final check for essential remotes needed for Egoist Slick
if not SlideRemote then warn("SlideRemote could not be located! Egoist Slick steal might fail.") end
if not BodyBlockAbilityRemote then warn("BodyBlockAbilityRemote not found! Void Guard might fail.") end -- Check for Void Guard dependency early
-- // Style Configuration
local STYLE_NAME = "EGO JINPANCHI"
local STYLE_RARITY = "World Class"
local STYLE_DESCRIPTION = "TRUE INJURED EGOIST WHO ONCE RULE THE FIELD"
local STYLE_TEXT_COLOR = Color3.fromRGB(0, 0, 0) -- Black
-- // Ability Settings & Cooldowns
local abilities = {
    EgoistSlick = { Key = Enum.KeyCode.Z, Cooldown = 5, ButtonName = "EgoistSlickButton", TimerText = "Egoist Slick", LayoutOrder = 1 },
    TraumatizedCurve = { Key = Enum.KeyCode.X, Cooldown = 12, ButtonName = "TraumatizedCurveButton", TimerText = "Traumatized Curve", LayoutOrder = 2 },
    ElastoPass = { Key = Enum.KeyCode.C, Cooldown = 8, ButtonName = "ElastoPassButton", TimerText = "Elasto Pass", LayoutOrder = 3 },
    VoidGuard = { Key = Enum.KeyCode.V, Cooldown = 0.5, ButtonName = "VoidGuardButton", TimerText = "Void Guard OFF", LayoutOrder = 4 },
    ChaosImpact = { Key = Enum.KeyCode.F, Cooldown = 15, ButtonName = "ChaosImpactButton", TimerText = "Chaos Impact", LayoutOrder = 5 },
    BlackHoleStrike = { Key = Enum.KeyCode.G, Cooldown = 20, ButtonName = "BlackHoleStrikeButton", TimerText = "Black Hole Strike", LayoutOrder = 6 }
}
local abilityCooldowns = {}
local lastAbilityTimes = {}
for name, data in pairs(abilities) do
    abilityCooldowns[name] = data.Cooldown
    lastAbilityTimes[name] = 0
-- For Void Guard Toggle State
local isVoidGuardActive = false
local lastVoidGuardUseTime = 0
-- // Placeholder IDs
local ANIM_ID_EGOIST_SLICK = "rbxassetid://74760828875758"
local ANIM_ID_TRAUMA_CURVE = "rbxassetid://115758343285328"
local ANIM_ID_ELASTO_PASS = "rbxassetid://18668827116"
local ANIM_ID_CHAOS_IMPACT = "rbxassetid://88982797209625"
local ANIM_ID_BLACK_HOLE = "rbxassetid://115758343285328"
local SOUND_ID_EGOIST_SLICK = "rbxassetid://SOUND_ID_HERE"
local SOUND_ID_TRAUMA_CURVE = "rbxassetid://SOUND_ID_HERE"
local SOUND_ID_ELASTO_PASS = "rbxassetid://SOUND_ID_HERE"
local SOUND_ID_CHAOS_IMPACT = "rbxassetid://SOUND_ID_HERE"
local SOUND_ID_BLACK_HOLE = "rbxassetid://SOUND_ID_HERE"
-- // VFX Code Blocks
local VFX = {} -- Initialize VFX Table
-- Integrated "BEST SHOOTING VFX 2" (Color Only Change)
VFX.BestShootingVFX2 = function(targetPart)
    if not targetPart then warn("Target part invalid for BestShootingVFX2") return end
    local vfxContainer = Instance.new("Attachment")
    vfxContainer.Name = "BestShootingVFX2_BW"
    vfxContainer.Parent = targetPart
    local particles = {}
    -- Emitter 1 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=3;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.13,0.96875),NumberSequenceKeypoint.new(0.31,0.94375),NumberSequenceKeypoint.new(0.46,0.95),NumberSequenceKeypoint.new(0.6,0.9625),NumberSequenceKeypoint.new(0.74,0.96875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,0.75)});p.Speed=NumberRange.new(300.9,401.2);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.21,19.88),NumberSequenceKeypoint.new(1,13.19)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=60;p.VelocityInheritance=0;p.Rotation=NumberRange.new(90);p.ShapePartial=1;p.Texture="rbxassetid://16637904761";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 2 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=3.275;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(0,0);p.LockedToPart=false;p.Transparency=NumberSequence.new(0);p.Orientation=Enum.ParticleOrientation.VelocityPerpendicular;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=0;p.Squash=NumberSequence.new(0);p.Speed=NumberRange.new(1.7);p.Size=NumberSequence.new(17.07);p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=12;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0,360);p.ShapePartial=1;p.Texture="rbxassetid://16467645316";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Front;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 3 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=4.43;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.2,0.4);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.32,0.9625),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.FacingCamera;p.Drag=7;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new(0);p.Speed=NumberRange.new(100.3,401.2);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,10.22),NumberSequenceKeypoint.new(0.28,16.64),NumberSequenceKeypoint.new(1,25.45)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=60;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0,360);p.ShapePartial=1;p.Texture="rbxassetid://12096349161";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 4 (White)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(1,1,1));p.LightEmission=0;p.Brightness=4.43;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.2);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid2x2;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.49,0.875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=12;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-1.2375)});p.Speed=NumberRange.new(401.2,601.8);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.22,25.08),NumberSequenceKeypoint.new(1,11.6)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=40;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://15572330616";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 5 (Black)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0,0,0));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.07,0.15);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid4x4;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new(0);p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-0.225)});p.Speed=NumberRange.new(212.9,532.3);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.26,7.45),NumberSequenceKeypoint.new(1,20.05)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=-0.76;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=50;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://17258046088";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Box;p.Parent=vfxContainer;table.insert(particles,p) end
    -- Emitter 6 (Dark Gray)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.25);p.FlipbookLayout=Enum.ParticleFlipbookLayout.Grid2x2;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.21,0.71875),NumberSequenceKeypoint.new(0.49,0.31875),NumberSequenceKeypoint.new(0.83,0.76875),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=0;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,-1.2375)});p.Speed=NumberRange.new(87.05,304.69);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.21,29.74),NumberSequenceKeypoint.new(1,16.25)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=1;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=50;p.VelocityInheritance=0;p.Rotation=NumberRange.new(0);p.ShapePartial=1;p.Texture="rbxassetid://15572330616";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
     -- Emitter 7 (Dark Gray)
    do local p=Instance.new("ParticleEmitter");p.Color=ColorSequence.new(Color3.new(0.1,0.1,0.1));p.LightEmission=0;p.Brightness=0;p.ShapeStyle=Enum.ParticleEmitterShapeStyle.Volume;p.FlipbookFramerate=NumberRange.new(1);p.Lifetime=NumberRange.new(0.1,0.25);p.FlipbookLayout=Enum.ParticleFlipbookLayout.None;p.SpreadAngle=Vector2.new(20,20);p.LockedToPart=false;p.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)});p.Orientation=Enum.ParticleOrientation.VelocityParallel;p.Drag=6;p.FlipbookStartRandom=false;p.TimeScale=1;p.VelocitySpread=20;p.Squash=NumberSequence.new({NumberSequenceKeypoint.new(0,0.45),NumberSequenceKeypoint.new(1,1.3875)});p.Speed=NumberRange.new(200.6,300.9);p.Size=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(0.08,21.13),NumberSequenceKeypoint.new(0.33,34.53),NumberSequenceKeypoint.new(0.65,37.09),NumberSequenceKeypoint.new(1,35.37)});p.Enabled=false;p.Acceleration=Vector3.new(0,0,0);p.RotSpeed=NumberRange.new(0);p.ZOffset=0.7;p.ShapeInOut=Enum.ParticleEmitterShapeInOut.Outward;p.Rate=30;p.VelocityInheritance=0;p.Rotation=NumberRange.new(90);p.ShapePartial=1;p.Texture="rbxassetid://11575346457";p.FlipbookMode=Enum.ParticleFlipbookMode.OneShot;p.EmissionDirection=Enum.NormalId.Back;p.Shape=Enum.ParticleEmitterShape.Disc;p.Parent=vfxContainer;table.insert(particles,p) end
    for _, p in ipairs(particles) do p.Enabled = true end
    local maxLife = 0.4
    task.delay(maxLife + 0.1, function()
        if vfxContainer and vfxContainer.Parent then
            for _, p in ipairs(particles) do if p and p.Parent then p.Enabled = false end end
            Debris:AddItem(vfxContainer, 1.5)
        end
    end)
-- Placeholder for other VFX functions
VFX.WaveKickRings = function(targetPart) warn("Placeholder: WaveKickRings triggered on", targetPart) end
VFX.PowerUpWaveFire = function(targetPart) warn("Placeholder: PowerUpWaveFire triggered on", targetPart) end
VFX.BlackFireKickBall = function(targetPart) warn("Placeholder: BlackFireKickBall triggered on", targetPart) end
VFX.BestKickBW = function(targetPart) warn("Placeholder: BestKickBW triggered on", targetPart) end
-- // Helper Functions (Start Here)
local function IsReady(abilityName)
    if not lastAbilityTimes[abilityName] then lastAbilityTimes[abilityName] = 0 end
    return tick() - lastAbilityTimes[abilityName] >= (abilityCooldowns[abilityName] or 999)
local function StartCooldown(abilityName)
    lastAbilityTimes[abilityName] = tick()
-- (Part 2 Starts Here)
local function playSound(soundId, parentPart)
    if not soundId or soundId == "rbxassetid://SOUND_ID_HERE" or not parentPart then return end
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = 2
    sound.Parent = parentPart
    sound:Play()
    Debris:AddItem(sound, sound.TimeLength + 0.5)
local loadedAnimations = {}
local function loadAnimation(animId)
    if not humanoid or not humanoid.Parent then
         character = player.Character or player.CharacterAdded:Wait()
         humanoid = character and character:WaitForChild("Humanoid")
         if not humanoid then warn("LoadAnimation: Humanoid not found"); return nil end
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    if loadedAnimations[animId] then
        if loadedAnimations[animId].Animator == animator then
             return loadedAnimations[animId]
        else
             loadedAnimations[animId]:Destroy() -- Destroy old track if animator changed
             loadedAnimations[animId] = nil
    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    -- Parent animation to humanoid temporarily for loading (common practice)
    anim.Parent = humanoid
    local track = animator:LoadAnimation(anim)
    anim:Destroy() -- Clean up the animation object after loading
    if track then
        loadedAnimations[animId] = track
        warn("Failed to load animation:", animId)
    return track
local function findBall()
    local football = Workspace:FindFirstChild("Football")
    if football then
        local ballPart = (football:FindFirstChild("BallAnims") and football.BallAnims:FindFirstChild("BALL")) or football:FindFirstChild("BALL")
        if ballPart and ballPart:IsA("BasePart") then return ballPart end
        if football:IsA("Model") and football.PrimaryPart then return football.PrimaryPart end
        if football:IsA("BasePart") then return football end
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character then
            local i = p.Character:FindFirstChild("BALL")
            if i and i:IsA("BasePart") then return i end
    return nil
local function shakeCamera(intensity, duration)
     if not Camera or not Camera.Parent then print("ShakeCamera: Camera not available"); return end -- Add camera check
    local originalCFrame = Camera.CFrame
    local elapsed = 0
    local heartbeat = RunService.Heartbeat
    local connection = nil
    local function stopShake()
        if connection and connection.Connected then
             if Camera and Camera.Parent then Camera.CFrame = originalCFrame end -- Check Camera before setting CFrame
            connection:Disconnect()
            connection = nil
    connection = heartbeat:Connect(function(dt)
        elapsed = elapsed + dt
        if elapsed < duration then
            local shakeOffset = CFrame.new(
                (math.random()*2-1)*intensity/100,
                (math.random()*2-1)*intensity/100
            ) * CFrame.Angles(
                math.rad((math.random()*2-1)*intensity*0.1),
                math.rad((math.random()*2-1)*intensity*0.1)
            )
            if Camera and Camera.Parent then Camera.CFrame = originalCFrame * shakeOffset else stopShake() end
            stopShake()
    task.delay(duration + 0.1, stopShake)
-- // Ability Implementations
--// 1. EGOIST SLICK
local function EgoistSlick()
    if not IsReady("EgoistSlick") then print("Egoist Slick on CD") return end
    if not rootPart or not rootPart.Parent then
         rootPart = character and character:WaitForChild("HumanoidRootPart")
         if not rootPart or not humanoid then warn("Egoist Slick: Cannot find player RootPart/Humanoid."); return end
    local targetPlayer = nil
    local closestDist = 15
    local minDist = 5
    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Team ~= player.Team and otherPlayer.Character then
            local otherHRP = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHRP then
                local dist = (rootPart.Position - otherHRP.Position).Magnitude
                if dist >= minDist and dist <= closestDist then
                    local ray = Ray.new(rootPart.Position, (otherHRP.Position - rootPart.Position).Unit * dist)
                    local hit, pos = Workspace:FindPartOnRayWithIgnoreList(ray, {character, otherPlayer.Character})
                    if not hit or hit:IsDescendantOf(otherPlayer.Character) then
                        closestDist = dist
                        targetPlayer = otherPlayer
                    end
                end
            end
    if not targetPlayer or not targetPlayer.Character then
        warn("Egoist Slick: No suitable opponent found.")
        return
    StartCooldown("EgoistSlick")
    local targetHRP = targetPlayer.Character.HumanoidRootPart
    local playerToTarget = (targetHRP.Position - rootPart.Position).Unit
    local rightVector = rootPart.CFrame.RightVector
    local dotProduct = playerToTarget:Dot(rightVector)
    local directionVector = targetHRP.CFrame.RightVector
    local offsetDistance = 4
    local teleportPos
    if dotProduct > 0.1 then teleportPos = targetHRP.Position - (directionVector * offsetDistance)
    elseif dotProduct < -0.1 then teleportPos = targetHRP.Position + (directionVector * offsetDistance)
    else teleportPos = targetHRP.Position + (directionVector * offsetDistance)
    teleportPos = Vector3.new(teleportPos.X, targetHRP.Position.Y + 0.5, teleportPos.Z)
    -- Check if VFX function exists before calling
    if VFX and VFX.BestShootingVFX2 then VFX.BestShootingVFX2(rootPart) else warn("BestShootingVFX2 not found in VFX table") end
    rootPart.CFrame = CFrame.lookAt(teleportPos, targetHRP.Position)
    local animTrack = loadAnimation(ANIM_ID_EGOIST_SLICK)
    if animTrack then animTrack:Play(0.1, 1, 1.2); print("Playing Egoist Slick Animation") else warn("Failed to load Egoist Slick animation") end
    playSound(SOUND_ID_EGOIST_SLICK, rootPart)
    task.wait(0.05)
    if SlideRemote then SlideRemote:FireServer(targetPlayer) else warn("SlideRemote is nil, cannot fire.") end
-- // --- UI Setup --- (Continued in Part 3)
-- // Cooldown Update Loop (Continued in Part 3)
-- // Style UI Update (Continued in Part 3)
-- // Character Respawn Handling (Continued in Part 3)
-- // Initial UI Setup (Continued in Part 3)
-- // Connect Ability Activations (Continued in Part 3)
-- // Input Handling (Continued in Part 3)
-- (Part 3 Starts Here)
-- // --- UI Setup ---
local abilityButtons = {} -- Store button instances
local function setupAbilityUI()
    local playerGui = player:WaitForChild("PlayerGui")
    local inGameUI = playerGui:WaitForChild("InGameUI", 15)
    if not inGameUI then warn("InGameUI not found.") return end
    local bottom = inGameUI:WaitForChild("Bottom", 10)
    if not bottom then warn("Bottom frame not found.") return end
    local bottomAbilities = bottom:WaitForChild("Abilities", 10)
    if not bottomAbilities then warn("Abilities Frame not found!") return end
    local templateButton = bottomAbilities:FindFirstChild("1") or bottomAbilities:FindFirstChildWhichIsA("ImageButton")
     if not templateButton then warn("Template button ('1' or ImageButton) not found in Abilities Frame!") return end
    -- Remove any existing buttons first
    for name, data in pairs(abilities) do
        local oldBtn = bottomAbilities:FindFirstChild(data.ButtonName)
        if oldBtn then
            oldBtn:Destroy()
     task.wait(0.1) -- Short delay after destroying
    -- Create new buttons
         local button = nil
         pcall(function() button = templateButton:Clone() end) -- Wrap clone in pcall
         if not button then warn("Failed to clone template button for", name); continue end -- Skip if clone failed
        button.Name = data.ButtonName
        button.Parent = bottomAbilities
        button.LayoutOrder = data.LayoutOrder
        local keybindLabel = button:FindFirstChild("Keybind", true)
        local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
        local actualTimerLabel = button:FindFirstChild("ActualTimer", true)
        if keybindLabel and keybindLabel:IsA("TextLabel") then keybindLabel.Text = data.Key.Name else warn("Keybind Label not found for", name) end
        if timerLabel and timerLabel:IsA("TextLabel") then timerLabel.Text = data.TimerText else warn("Timer Label not found for", name) end
        if actualTimerLabel and actualTimerLabel:IsA("TextLabel") then actualTimerLabel.Text = "" end
        local cdVisual = button:FindFirstChild("Cooldown") or button:FindFirstChild("cooldown")
        if cdVisual then cdVisual:Destroy() end
        local abilityFrame = button:FindFirstChild("Ability") or button
        if abilityFrame then
            local cooldownFrame = Instance.new("Frame")
            cooldownFrame.Name = "Cooldown"
            cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            cooldownFrame.BackgroundTransparency = 0.6
            cooldownFrame.BorderSizePixel = 0
            cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
            cooldownFrame.Position = UDim2.new(0, 0, 1, 0)
            cooldownFrame.AnchorPoint = Vector2.new(0, 1)
            cooldownFrame.ZIndex = (abilityFrame:IsA("GuiObject") and abilityFrame.ZIndex or 1) + 1
            cooldownFrame.Parent = abilityFrame
            local uiCorner = Instance.new("UICorner", cooldownFrame)
            local absSize = abilityFrame:IsA("GuiObject") and abilityFrame.AbsoluteSize or Vector2.new(50,50)
            local radius = math.max(1, math.min(absSize.X, absSize.Y) * 0.15)
            uiCorner.CornerRadius = UDim.new(0, radius)
            if abilityFrame:IsA("GuiObject") then
                abilityFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
                    local newAbsSize = abilityFrame.AbsoluteSize
                    local newRadius = math.max(1, math.min(newAbsSize.X, newAbsSize.Y) * 0.15)
                    uiCorner.CornerRadius = UDim.new(0, newRadius)
                end)
             warn("Could not find 'Ability' frame or base button to parent cooldown visual for", name)
        abilityButtons[name] = button
-- // Cooldown Update Loop
RunService.Heartbeat:Connect(function(dt)
    for name, button in pairs(abilityButtons) do
        local buttonExists = pcall(function() return button.Parent end)
        if not buttonExists then
             abilityButtons[name] = nil
             -- print("Button removed or invalid in Heartbeat:", name) -- Less frequent debug print
             continue
        if button and button.Parent then
            local timeLeft = (lastAbilityTimes[name] or 0) + (abilityCooldowns[name] or 0) - tick()
            local abilityFrame = button:FindFirstChild("Ability") or button
            local cooldownFrame = abilityFrame and abilityFrame:FindFirstChild("Cooldown")
            local timerLabel = button:FindFirstChild("Timer") or button:FindFirstChild("AbilityName", true)
            if timeLeft > 0 then
                if cooldownFrame then
                    local progress = math.clamp(timeLeft / abilityCooldowns[name], 0, 1)
                    pcall(function() cooldownFrame.Size = UDim2.new(1, 0, progress, 0) end) -- Wrap UI update
                    cooldownFrame.Visible = true
                if timerLabel and timerLabel:IsA("TextLabel") then
                     pcall(function() timerLabel.Text = string.format("%.1fs", timeLeft) end)
                 end
            else
                if cooldownFrame then cooldownFrame.Visible = false end
                     local newText = ""
                     if name == "VoidGuard" then
                         newText = isVoidGuardActive and "Void Guard ON" or "Void Guard OFF"
                     else
                        if abilities[name] and abilities[name].TimerText then
                            newText = abilities[name].TimerText
                        else
                             newText = name -- Fallback
                        end
                     end
                     if timerLabel.Text ~= newText then -- Only update if text changed
                        pcall(function() timerLabel.Text = newText end)
end)
-- // Style UI Update
task.spawn(function()
    local StyleBG = player:WaitForChild("PlayerGui"):WaitForChild("Style", 15)
    if not StyleBG then warn("Style GUI not found.") return end
    local BG = StyleBG:WaitForChild("BG", 10)
    if not BG then warn("Style BG Frame not found.") return end
    local StyleTxt = BG:FindFirstChild("StyleTxt")
    local Slots = BG:FindFirstChild("Slots")
    local Desc = BG:FindFirstChild("Desc")
    if not (StyleTxt and Slots and Desc) then warn("Style UI elements missing.") return end
    local ScrollingFrame = Slots:FindFirstChildOfClass("ScrollingFrame")
    local Slot1 = ScrollingFrame and ScrollingFrame:FindFirstChild("Slot1")
    local Slot1Text = Slot1 and (Slot1:FindFirstChild("TextLabel") or Slot1:FindFirstChild("Text") or Slot1:FindFirstChildWhichIsA("TextLabel", true))
    if not Slot1Text then warn("Slot 1 Text Label not found.") end
    while task.wait(1) do
        pcall(function()
            if StyleTxt then StyleTxt.Text = STYLE_NAME; StyleTxt.TextColor3 = STYLE_TEXT_COLOR end
            if Slot1Text then Slot1Text.Text = STYLE_NAME; Slot1Text.TextColor3 = STYLE_TEXT_COLOR end
            if Desc then Desc.Text = STYLE_DESCRIPTION; Desc.TextColor3 = STYLE_TEXT_COLOR end
        end)
-- // Character Respawn Handling
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    loadedAnimations = {}
    isVoidGuardActive = false
    for name, _ in pairs(abilities) do lastAbilityTimes[name] = 0 end
    -- Consider adding setupAbilityUI() call here if needed after respawn
-- // Initial UI Setup
setupAbilityUI()
-- // Connect Ability Activations
if abilityButtons.EgoistSlick then
    abilityButtons.EgoistSlick.Activated:Connect(EgoistSlick)
    warn("EgoistSlick button not found in table for Activated connection")
-- Connect other abilities here later
-- // Input Handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
    local key = input.KeyCode
    if abilities.EgoistSlick and key == abilities.EgoistSlick.Key then EgoistSlick() end
    -- Add other keybind checks here later
-- Let me know when you're ready for Ability 2!-- Chaos Impact V31 (Final Strike Fix) - Based on V30, addressing final shot failure.
-- Addresses: User-defined adjustability, v27 freeze stability, wider aim, placeholders, and final strike ball drop.
local GuiService = game:GetService("GuiService")
local playerGui = player:WaitForChild("PlayerGui")
local playerValues = character:WaitForChild("Values", 10)
-- // Remote Event Acquisition
local ShootRemote = nil
local function findShootRemoteStandardPath()
    local p,k,s,b,r=ReplicatedStorage:FindFirstChild("Packages",5),nil,nil,nil,nil;
    if p then k=p:FindFirstChild("Knit",5)end;
    if k then s=k:FindFirstChild("Services",5)end;
    if s then b=s:FindFirstChild("BallService",5)end;
    if b then r=b:FindFirstChild("RE",5)end;
    local remote=r and r:FindFirstChild("Shoot",5);
    if remote and remote:IsA("RemoteEvent")then
        return remote
        warn("CI: ShootRemote NOT found via Standard Path!");
        return nil
ShootRemote = findShootRemoteStandardPath()
-- // --- CONFIGURABLE VALUES (V31) --- //
local ABILITY_KEY_CI = Enum.KeyCode.F
local COOLDOWN_CI = 15 -- Cooldown in seconds
-- VFX Parameters (NEW - For thebestkickvfx)
local VFX_ACTIVATION_DELAY = 1.0 -- Delay before Kick VFX plays after ability activation (User Request: ~1s)
local VFX_DURATION = 4.5 -- How long the Kick VFX lasts (User Request: 4-5s)
-- Levitation
local LEVITATE_HEIGHT = 15
local LEVITATE_DURATION = 0.5
local LEVITATE_AIR_TIME = 1.0 -- How long player stays at peak height *before* shot sequence starts
-- Aiming
local AIM_VISUALIZER_DURATION = 5
local AIM_VISUALIZER_TRANSPARENCY = 0.7
local AIM_VISUALIZER_RADIUS = 200 -- Increased for wider aim leniency (was 75)
local DEFAULT_BALL_MASS = 1.5
-- Shot Sequence Delays/Pauses
local SHOT_START_DELAY = 0.1 -- Delay after LEVITATE_AIR_TIME before first shot
local SHOT_POST_INITIAL_FIRE_WAIT = 0.4 -- Wait time after initial FireServer before ball control
local SHOT_POST_STAGE1_FREEZE_DURATION = 0.7 -- Duration for the first freeze (after initial stop)
local SHOT_STAGE2_PAUSE_FREEZE_DURATION = 0.7 -- Duration for the second freeze (after sideways movement)
-- Shot Sequence Stages
local INITIAL_SHOT_POWER = 15 -- Power for the initial ShootRemote:FireServer()
local SHOT_STAGE1_SPEED = 100 -- Speed of the ball towards (Goal - StopDistance)
local SHOT_STAGE1_STOP_DISTANCE = 100 -- Distance from goal where the ball makes its first stop
local SHOT_STAGE2_SIDE_SPEED = 80 -- Speed of the sideways strike
local SHOT_STAGE2_DURATION = 0.4 -- Duration of the sideways movement
local SHOT_STAGE3_FINAL_SPEED = 400 -- Speed of the final strike towards goal
local SHOT_STAGE3_DURATION = 2.0 -- Max duration for the final strike BodyVelocity
-- BodyPosition Freeze Parameters (V27 Style - for stability)
local BODYPOS_P_GAIN = 50000 -- Proportional gain (stiffness) for BodyPosition
local BODYPOS_D_GAIN = 1250  -- Derivative gain (damping) for BodyPosition
local BODYPOS_MAXFORCE_XZ = 40000 -- MaxForce on X and Z axes for BodyPosition (Y is calculated dynamically)
-- Placeholder IDs (User to replace these with actual asset IDs)
local ANIMATION_ID_LEVITATE_PLACEHOLDER = "rbxassetid://YOUR_LEVITATE_ANIM_ID"
local ANIMATION_ID_SHOT_MAIN_PLACEHOLDER = "rbxassetid://YOUR_MAIN_SHOT_ANIM_ID"
local ANIMATION_ID_SHOT_SIDE_PLACEHOLDER = "rbxassetid://YOUR_SIDE_SHOT_ANIM_ID"
local ANIMATION_ID_SHOT_FINAL_PLACEHOLDER = "rbxassetid://YOUR_FINAL_SHOT_ANIM_ID"
local SOUND_ID_ACTIVATION_PLACEHOLDER = "rbxassetid://YOUR_ACTIVATION_SOUND_ID"
local SOUND_ID_LEVITATE_PLACEHOLDER = "rbxassetid://YOUR_LEVITATE_SOUND_ID"
local SOUND_ID_SHOT_INITIAL_PLACEHOLDER = "rbxassetid://YOUR_INITIAL_SHOT_SOUND_ID"
local SOUND_ID_SHOT_SIDE_PLACEHOLDER = "rbxassetid://YOUR_SIDE_SHOT_SOUND_ID"
local SOUND_ID_SHOT_FINAL_PLACEHOLDER = "rbxassetid://YOUR_FINAL_SHOT_SOUND_ID"
local SOUND_ID_BALL_FREEZE_PLACEHOLDER = "rbxassetid://YOUR_BALL_FREEZE_SOUND_ID"
-- Placeholder Functions for VFX (Original V31 Placeholders - Kept for reference)
local VFX_BALL_BLACK_FIRE_PLACEHOLDER = function(ballInstance, actionType) 
local VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER = function(playerRootPartInstance) 
-- // --- END CONFIGURABLE VALUES --- //
local ABILITY_NAME_CI = "ChaosImpact"
local BUTTON_NAME_CI = "ChaosImpactButton"
local TIMER_TEXT_CI = "Chaos Impact"
local LAYOUT_ORDER_CI = 5
local lastChaosImpactTime = 0
local chaosImpactButton = nil
local isAbilityActive_CI = false
local function IsReady_CI() return tick() - lastChaosImpactTime >= COOLDOWN_CI end
local function StartCooldown_CI()
    lastChaosImpactTime = tick()
    if chaosImpactButton then
        local cooldownFrame = chaosImpactButton:FindFirstChild("Cooldown")
        if cooldownFrame then
            local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
            if uiGradient then
                local tweenInfo = TweenInfo.new(COOLDOWN_CI, Enum.EasingStyle.Linear)
                local tween = TweenService:Create(uiGradient, tweenInfo, {Offset = Vector2.new(0, 1)})
                uiGradient.Offset = Vector2.new(0, 0); tween:Play()
local homeGoalPos=Vector3.new(325,15,-49);
local awayGoalPos=Vector3.new(-247,15,-50);
local function getOpponentGoalPos()
    local t = player.Team
    if not t then return nil end
    return t.Name == "Home" and awayGoalPos or (t.Name == "Away" and homeGoalPos or nil)
local function findBall(retries, delay)
    retries = retries or 3; delay = delay or 0.1; local ball = nil
    for i = 1, retries do
        local f = Workspace:FindFirstChild("Football")
        if f then
            local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL")
            if b and b:IsA("BasePart") then ball = b; break
            elseif f:IsA("Model") and f.PrimaryPart then ball = f.PrimaryPart; break
            elseif f:IsA("BasePart") then ball = f; break end
        if i < retries then task.wait(delay) end
    return ball
local function calculatePartMass(part)
    local mass = DEFAULT_BALL_MASS
    if part and part:IsA("BasePart") then
        local s, m = pcall(function() return part:GetMass() end)
        if s and typeof(m) == "number" and m > 0 then mass = m
        else s, m = pcall(function() return part.AssemblyMass end)
            if s and typeof(m) == "number" and m > 0 then mass = m end
    return mass
local function calculateModelMass(model)
    local totalMass = 0
    if model and model:IsA("Model") then
        for _, p in ipairs(model:GetDescendants()) do if p:IsA("BasePart") then totalMass = totalMass + calculatePartMass(p) end end
    return totalMass <= 0 and 10 or totalMass
local function cleanupAllMovers(target)
    if not target or not target.Parent then return end
    for _, mover in ipairs(target:GetChildren()) do
        if mover:IsA("BodyMover") then
            mover:Destroy()
local function applyBodyVelocity(target, velocity, duration, maxForce)
    if not target or not target.Parent then return nil end
    cleanupAllMovers(target)
    local bv = Instance.new("BodyVelocity"); bv.Name = "ChaosImpactMover_V31"
    bv.MaxForce = maxForce or Vector3.new(math.huge, math.huge, math.huge); bv.Velocity = velocity
    bv.Parent = target; if duration and duration > 0 then Debris:AddItem(bv, duration) end
    return bv
local function applyBodyPositionFreeze(ball, targetPosition, duration)
    if not ball or not ball.Parent then warn("CI Freeze (V31): Ball not found for BodyPosition freeze."); return end
    cleanupAllMovers(ball); RunService.Heartbeat:Wait()
    local originalAnchored = ball.Anchored
    ball.Anchored = true; RunService.Heartbeat:Wait()
    ball.CFrame = CFrame.new(targetPosition)
    ball.AssemblyLinearVelocity = Vector3.zero; ball.AssemblyAngularVelocity = Vector3.zero
    ball.Anchored = originalAnchored; RunService.Heartbeat:Wait()
    ball.AssemblyLinearVelocity = Vector3.zero; ball.AssemblyAngularVelocity = Vector3.zero; RunService.Heartbeat:Wait()
    local bp = Instance.new("BodyPosition"); bp.Name = "ChaosImpactBodyPositionFreeze_V31"
    local ballMass = calculatePartMass(ball); if ballMass <= 0 then ballMass = DEFAULT_BALL_MASS end
    local yMaxForce = Workspace.Gravity * ballMass * 1.2 + 500 
    bp.MaxForce = Vector3.new(BODYPOS_MAXFORCE_XZ, yMaxForce, BODYPOS_MAXFORCE_XZ)
    bp.P = BODYPOS_P_GAIN; bp.D = BODYPOS_D_GAIN; bp.Position = targetPosition
    bp.Parent = ball
    Debris:AddItem(bp, duration)
local function showAimVisualizerSphere(position)
    if not position then return end
    local existingVis = Workspace:FindFirstChild("ChaosImpactAimVisContainer"); if existingVis then existingVis:Destroy() end
    local visContainer = Instance.new("Model", Workspace); visContainer.Name = "ChaosImpactAimVisContainer"
    local sphere = Instance.new("Part", visContainer); sphere.Name = "ChaosImpactAimVisSphere"; sphere.Shape = Enum.PartType.Ball
    sphere.Size = Vector3.new(AIM_VISUALIZER_RADIUS*2, AIM_VISUALIZER_RADIUS*2, AIM_VISUALIZER_RADIUS*2); sphere.Position = position
    sphere.Color = Color3.new(0,0,0); sphere.Transparency = AIM_VISUALIZER_TRANSPARENCY; sphere.Anchored = true; sphere.CanCollide = false
    local billboardGui = Instance.new("BillboardGui", sphere); billboardGui.Name = "AimTextGui"; billboardGui.Adornee = sphere
    billboardGui.Size = UDim2.new(75,0,30,0); billboardGui.StudsOffset = Vector3.new(0, AIM_VISUALIZER_RADIUS + 10, 0)
    local textLabel = Instance.new("TextLabel", billboardGui); textLabel.Name = "AimTextLabel"; textLabel.BackgroundTransparency=1
    textLabel.Size=UDim2.new(1,0,1,0); textLabel.Font=Enum.Font.SourceSansBold; textLabel.Text="AIM NEAR GOAL"; textLabel.TextColor3=Color3.new(1,1,1)
    textLabel.TextScaled=true; textLabel.TextStrokeColor3=Color3.new(0,0,0); textLabel.TextStrokeTransparency=0
    Debris:AddItem(visContainer, AIM_VISUALIZER_DURATION)
local function isAimingInRadius(goalPosition)
    if not goalPosition or not Camera or not Camera.Parent then return false end
    local camPos, camLook = Camera.CFrame.Position, Camera.CFrame.LookVector
    local vecToGoal = goalPosition - camPos; local pL = vecToGoal:Dot(camLook)
    if pL < 0 then return false end
    return (goalPosition - (camPos + camLook * pL)).Magnitude <= AIM_VISUALIZER_RADIUS
local function playBestKickVFX(character, duration)
    if not character or not character.Parent then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
         warn("Player HRP not found for BEST KICK VFX.")
         return
    -- Attach to player HRP
    local effectTargetPart = humanoidRootPart
    vfxContainer.Name = "BestKickVFX_BW_ColorOnly"
    vfxContainer.Parent = effectTargetPart
    -- Emitter 1 (Original Red Streaks -> White Streaks)
    do
        local particle = Instance.new("ParticleEmitter")
        local parent = vfxContainer
        -- *** Color Change Only ***
        particle.Color = ColorSequence.new(Color3.new(1, 1, 1)) -- White
        particle.LightEmission = 0.8 -- Adjusted for white
        particle.Brightness = 10 -- Adjusted for white
        -- --- Original Properties ---
        particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.FlipbookFramerate = NumberRange.new(30.000000, 30.000000)
        particle.Lifetime = NumberRange.new(0.200000, 0.350000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.None
        particle.SpreadAngle = Vector2.new(360.000000, 360.000000)
        particle.LockedToPart = true
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Orientation = Enum.ParticleOrientation.VelocityParallel
        particle.Drag = 10
        particle.FlipbookStartRandom = false
        particle.TimeScale = 1
        particle.VelocitySpread = 360
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.226704, 1.425000), NumberSequenceKeypoint.new(1.000000, 1.650000)})
        particle.Speed = NumberRange.new(400.000000, 600.000000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.172660, 7.764939), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Enabled = false
        particle.Acceleration = Vector3.new(0.000000, 0.000000, 0.000000)
        particle.RotSpeed = NumberRange.new(0.000000, 0.000000)
        particle.ZOffset = 0
        particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
        particle.Rate = 50
        particle.VelocityInheritance = 0
        particle.Rotation = NumberRange.new(90.000000, 90.000000)
        particle.ShapePartial = 1
        particle.Texture = "rbxassetid://13386858482"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.OneShot
        particle.EmissionDirection = Enum.NormalId.Top
        particle.FlipbookIncompatible = "Particle texture must be 1024 by 1024 to use flipbooks."
        particle.Shape = Enum.ParticleEmitterShape.Box
        particle.Parent = parent
        table.insert(particles, particle)
    -- Emitter 2 (Original Red/Dark Swirl -> Black Swirl)
        particle.Color = ColorSequence.new(Color3.new(0, 0, 0)) -- Black
        particle.LightEmission = 0 -- No emission for black
        particle.Brightness = 0 -- No brightness for black
        particle.FlipbookFramerate = NumberRange.new(1.000000, 1.000000)
        particle.Lifetime = NumberRange.new(0.250000, 0.350000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4
        particle.SpreadAngle = Vector2.new(50.000000, 50.000000)
        particle.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
        particle.Drag = 0
        particle.VelocitySpread = 50
        particle.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Speed = NumberRange.new(0.100000, 0.100000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 18.659960), NumberSequenceKeypoint.new(0.168660, 43.199478), NumberSequenceKeypoint.new(1.000000, 51.387165)})
        particle.Rotation = NumberRange.new(-360.000000, 360.000000)
        particle.Texture = "rbxassetid://13395479051"
        particle.EmissionDirection = Enum.NormalId.Front
    -- Emitter 3 (Original Red Swirl 2 -> Black Wisps)
         -- *** Color Change Only ***
        particle.Color = ColorSequence.new(Color3.new(0.1, 0.1, 0.1)) -- Dark Gray
        particle.LightEmission = 0
        particle.Brightness = 0.1
         -- --- Original Properties ---
        particle.Lifetime = NumberRange.new(0.150000, 0.350000)
        particle.SpreadAngle = Vector2.new(5.000000, 5.000000)
        particle.VelocitySpread = 5
        particle.Texture = "rbxassetid://13395481373"
    -- Emitter 4 (Flash -> White Flash)
        particle.LightEmission = 1
        particle.Brightness = 10
        particle.Lifetime = NumberRange.new(0.050000, 0.050000)
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(0.301370, 0.475000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Orientation = Enum.ParticleOrientation.FacingCamera
        particle.Drag = 5
        particle.Speed = NumberRange.new(0.000000, 0.000000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 13.051071), NumberSequenceKeypoint.new(1.000000, 101.363541)})
        particle.ZOffset = 3
        particle.Rate = 32
        particle.Rotation = NumberRange.new(0.000000, 0.000000)
        particle.ShapePartial = 0.3499999940395355
        particle.Texture = "rbxassetid://11503727043"
        particle.FlipbookMode = Enum.ParticleFlipbookMode.Loop
    -- Emitter 5 (Original Red Swirl 3 -> Alternating B&W)
        particle.Color = ColorSequence.new({ -- Alternating
            ColorSequenceKeypoint.new(0.0, Color3.new(0, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.new(1, 1, 1)),
            ColorSequenceKeypoint.new(1.0, Color3.new(0, 0, 0))
        })
        particle.LightEmission = 0.5 -- Moderate emission
        particle.Brightness = 4 -- Moderate brightness
    -- Enable particles
    for _, particle in ipairs(particles) do
        particle.Enabled = true
    -- Cleanup function (Adjusted to use provided duration)
    local function cleanupVFX()
         if vfxContainer and vfxContainer.Parent then
             for _, particle in ipairs(particles) do
                 if particle and particle.Parent then
                    particle.Enabled = false
             end
             Debris:AddItem(vfxContainer, 1.5) -- Add extra time for particles to fade
    -- Trigger cleanup based on the *provided* duration parameter
    task.delay(duration, cleanupVFX)
local function ChaosImpact()
    if isAbilityActive_CI then print("CI: Ability already active."); return end
    if character then cleanupAllMovers(rootPart) end
    local bfc = findBall(1,0); if bfc then cleanupAllMovers(bfc) end
    if not IsReady_CI() then print("CI: Ability on cooldown."); return end
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid"); rootPart = character:WaitForChild("HumanoidRootPart")
    playerValues = character:WaitForChild("Values", 10)
    if not (humanoid and rootPart and playerValues) then print("CI: Character components missing."); return end
    local hbv = playerValues:FindFirstChild("HasBall"); if not hbv or not hbv.Value then print("CI: Player does not have ball."); return end
    if not ShootRemote then ShootRemote = findShootRemoteStandardPath(); if not ShootRemote then print("CI: ShootRemote missing!"); return end end
    local goalPosition = getOpponentGoalPos(); if not goalPosition then print("CI: Opponent goal not found."); return end
    if not isAimingInRadius(goalPosition) then print("CI: Aim check failed. Showing visualizer."); showAimVisualizerSphere(goalPosition); return end
    isAbilityActive_CI = true; StartCooldown_CI()
    task.spawn(function()
        local currentCharacter, currentRootPart = character, rootPart
        local success = false
        local cleanupGuard = Instance.new("BoolValue", currentCharacter); cleanupGuard.Name = "ChaosImpactCleanupGuard_V31"
        local function performCleanupAndReset()
            if not cleanupGuard or not cleanupGuard.Parent then return end; cleanupGuard:Destroy()
            if currentRootPart and currentRootPart.Parent then cleanupAllMovers(currentRootPart) end
            local ball = findBall(1,0); if ball then cleanupAllMovers(ball) end
            isAbilityActive_CI = false
        local pcallSuccess, pcallResult = pcall(function()
            local charMass = calculateModelMass(currentCharacter)
            VFX_PLAYER_LEVITATE_AURA_PLACEHOLDER(currentRootPart)
            applyBodyVelocity(currentRootPart, Vector3.new(0, LEVITATE_HEIGHT / LEVITATE_DURATION, 0), LEVITATE_DURATION, Vector3.new(0, charMass*Workspace.Gravity*1.5, 0))
            task.wait(LEVITATE_DURATION); if not cleanupGuard.Parent then return end
            cleanupAllMovers(currentRootPart)
            local totalShotDur =
                SHOT_START_DELAY
                + SHOT_POST_INITIAL_FIRE_WAIT
                + ((getOpponentGoalPos() - currentRootPart.Position).Magnitude - SHOT_STAGE1_STOP_DISTANCE)
                    / SHOT_STAGE1_SPEED
                + SHOT_POST_STAGE1_FREEZE_DURATION
                + SHOT_STAGE2_DURATION
                + SHOT_STAGE2_PAUSE_FREEZE_DURATION
                + SHOT_STAGE3_DURATION
            local airTimeBV = applyBodyVelocity(currentRootPart, Vector3.zero, LEVITATE_AIR_TIME + totalShotDur + 0.2, Vector3.new(0,charMass*Workspace.Gravity,0))
            task.wait(LEVITATE_AIR_TIME); if not cleanupGuard.Parent then return end
            task.wait(SHOT_START_DELAY); if not cleanupGuard.Parent then return end
            local sOk, sErr = pcall(ShootRemote.FireServer, ShootRemote, INITIAL_SHOT_POWER)
            if not sOk then warn("CI: ShootRemote Fail:", sErr); performCleanupAndReset(); return end
            task.wait(SHOT_POST_INITIAL_FIRE_WAIT); if not cleanupGuard.Parent then return end
            local ball = findBall(3, 0.1); if not ball then print("CI: Ball not found after initial shot."); performCleanupAndReset(); return end
            VFX_BALL_BLACK_FIRE_PLACEHOLDER(ball, "InitialShot")
            local cgp = getOpponentGoalPos(); if not cgp then print("CI: Opponent goal not found for stage 1."); performCleanupAndReset(); return end
            local vtg = cgp - ball.Position; local dtg = vtg.Magnitude
            local s1d = dtg - SHOT_STAGE1_STOP_DISTANCE; 
            if s1d <= 0 then print("CI: Ball already past stop distance for stage 1."); performCleanupAndReset(); return end
            local s1dur = s1d / SHOT_STAGE1_SPEED
            applyBodyVelocity(ball, vtg.Unit * SHOT_STAGE1_SPEED, s1dur + 0.1)
            task.wait(s1dur); if not cleanupGuard.Parent then return end
            local freezePosStage1 = ball.Position 
            applyBodyPositionFreeze(ball, freezePosStage1, SHOT_POST_STAGE1_FREEZE_DURATION + 0.05)
            task.wait(SHOT_POST_STAGE1_FREEZE_DURATION); if not cleanupGuard.Parent then return end
            cleanupAllMovers(ball); RunService.Heartbeat:Wait()
            ball = findBall(1,0); if not ball then print("CI: Ball not found for stage 2."); performCleanupAndReset(); return end
            local sideDir = currentRootPart.CFrame.RightVector
            applyBodyVelocity(ball, sideDir * SHOT_STAGE2_SIDE_SPEED, SHOT_STAGE2_DURATION + 0.1)
            task.wait(SHOT_STAGE2_DURATION); if not cleanupGuard.Parent then return end
            local freezePosStage2 = ball.Position 
            applyBodyPositionFreeze(ball, freezePosStage2, SHOT_STAGE2_PAUSE_FREEZE_DURATION + 0.05)
            task.wait(SHOT_STAGE2_PAUSE_FREEZE_DURATION); if not cleanupGuard.Parent then return end
            ball = findBall(1,0); if not ball then print("CI: Ball not found for stage 3."); performCleanupAndReset(); return end
            cgp = getOpponentGoalPos(); if not cgp then print("CI: Opponent goal not found for stage 3."); performCleanupAndReset(); return end
            vtg = cgp - ball.Position
            VFX_BALL_BLACK_FIRE_PLACEHOLDER(ball, "FinalShot")
            local finalStrikeBV = applyBodyVelocity(ball, vtg.Unit * SHOT_STAGE3_FINAL_SPEED, SHOT_STAGE3_DURATION + 0.2)
            if not (finalStrikeBV and finalStrikeBV.Parent) then 
                performCleanupAndReset()
                return
            task.wait(SHOT_STAGE3_DURATION) -- KEY FIX: Wait for the strike to happen
            if not cleanupGuard.Parent then return end
            
            success = true
        if not pcallSuccess then
            warn("CI Error (V31 - Final Strike Fix):", pcallResult)
            if success then
        performCleanupAndReset()
local function setupAbilityButton_CI()
    local abilitiesFrame = playerGui:WaitForChild("InGameUI", 10):WaitForChild("Bottom", 10):WaitForChild("Abilities", 10)
    if not abilitiesFrame then warn("CI: Abilities Frame not found!"); return nil end
    local templateButton = abilitiesFrame:FindFirstChild("1")
    if not templateButton then warn("CI: Template button '1' not found!"); return nil end
    local existingButton = abilitiesFrame:FindFirstChild(BUTTON_NAME_CI)
    if existingButton then existingButton:Destroy(); task.wait(0.1) end
    chaosImpactButton = templateButton:Clone()
    chaosImpactButton.Name = BUTTON_NAME_CI
    chaosImpactButton.Parent = abilitiesFrame
    chaosImpactButton.LayoutOrder = LAYOUT_ORDER_CI
    chaosImpactButton.Keybind.Text = ABILITY_KEY_CI.Name
    chaosImpactButton.Timer.Text = TIMER_TEXT_CI
    chaosImpactButton.ActualTimer.Text = ""
    local cdFrame = chaosImpactButton:FindFirstChild("Cooldown")
    if cdFrame then local grad = cdFrame:FindFirstChildOfClass("UIGradient"); if grad then grad.Offset = Vector2.new(0, 1) end end
    chaosImpactButton.Activated:Connect(ChaosImpact)
    return chaosImpactButton
-- // --- INITIALIZATION (Original V31) --- //
setupAbilityButton_CI()
    if not gameProcessed and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY_CI then
        if chaosImpactButton and chaosImpactButton.Parent and chaosImpactButton.Visible then ChaosImpact() end
if not ShootRemote then warn("CI: ShootRemote was not found on initial load. Will try again on ability use.") end
setupAbilityUI_CI()
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == ABILITY_KEY_CI then ChaosImpact() end
    isAbilityActive_CI = false
local SoundService = game:GetService("SoundService")
-- // Animation Variables
local movementAnimation = Instance.new("Animation")
movementAnimation.AnimationId = "rbxassetid://74249210159048"
local movementAnimTrack = nil
-- // Knit Framework (Used in the game)
local Knit = require(ReplicatedStorage.Packages.Knit)
local StatesController = Knit.GetController("StatesController")
-- // --- CONFIGURABLE VALUES --- //
-- Key binding for PC
local ABILITY_KEY_GR = Enum.KeyCode.G  -- Default key for Glitch Rush
-- Cooldown
local COOLDOWN_GR = 3  -- Cooldown in seconds
-- Glitch Effect (Left-Right Illusion)
local GLITCH_DURATION = 1.5  -- Duration of glitch effect in seconds (adjustable: 1-2 seconds)
local GLITCH_FREQUENCY = 0.05  -- How quickly to move left-right (lower = faster)
local GLITCH_DISTANCE = 6  -- How far to move left/right during glitch effect
local GLITCH_ITERATIONS = 30  -- Number of left-right movements
-- First Dash
local DASH1_DISTANCE = 3.0  -- Distance of first forward dash in studs
local DASH1_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH1_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH1_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during first dash
-- Wait Time Between Dashes
local WAIT_BETWEEN_DASHES = 1.0  -- Wait time between dashes (in seconds)
-- Second Dash
local DASH2_DISTANCE = 3.0  -- Distance of second forward dash in studs
local DASH2_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH2_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH2_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during second dash
-- Third Dash
local DASH3_DISTANCE = 3.0  -- Distance of third forward dash in studs
local DASH3_STEPS = 5  -- Number of micro-steps to divide the dash into
local DASH3_STEP_DELAY = 0.01  -- Delay between micro-steps
local DASH3_SPEED_MULTIPLIER = 2.0  -- Temporary speed boost during third dash
-- Visual Effects
local GLITCH_COLOR_PRIMARY = Color3.fromRGB(255, 255, 255)  -- White
local GLITCH_COLOR_SECONDARY = Color3.fromRGB(0, 0, 0)  -- Black
-- // --- ANIMATION IDs --- //
local DASH_ANIMATION_ID = "rbxassetid://131979551237806"  -- Dash animation ID
-- // --- SOUND IDs --- //
local SOUND_ID_DASH = "rbxassetid://3084314259"  -- Updated dash sound effect ID
local SOUND_ID_ACTIVATION = "rbxassetid://YOUR_ACTIVATION_SOUND_ID"  -- Activation sound ID (placeholder)
local SOUND_ID_LEFT_RIGHT = "rbxassetid://6896112317"  -- Left-right movement sound ID
-- Sound Properties
local DASH_SOUND_VOLUME = 5
local DASH_SOUND_LIFETIME = 2.0  -- How long before the sound is automatically destroyed
local LEFT_RIGHT_SOUND_VOLUME = 5  -- Volume for left-right movement sound
-- // Button and UI Variables
local ABILITY_NAME_GR = "GlitchRush"
local BUTTON_NAME_GR = "custom"  -- As specified by user
local TIMER_TEXT_GR = "GLITCH RUSH"  -- As specified by user
local lastGlitchRushTime = 0
local glitchRushButton = nil
local isAbilityActive_GR = false
local dashAnimation = nil
local dashAnimTrack = nil
-- // Helper Functions
local function IsReady_GR() 
    return tick() - lastGlitchRushTime >= COOLDOWN_GR 
local function StartCooldown_GR()
    lastGlitchRushTime = tick()
    if glitchRushButton then
        local cooldownFrame = glitchRushButton:FindFirstChild("Cooldown")
                local tweenInfo = TweenInfo.new(COOLDOWN_GR, Enum.EasingStyle.Linear)
                uiGradient.Offset = Vector2.new(0, 0)
                tween:Play()
-- // Create and Play Sound Effect
local function CreateAndPlaySound(soundId, parent, volume, lifetime)
    -- Default values if not provided
    parent = parent or rootPart
    volume = volume or 1.0
    lifetime = lifetime or 2.0
    
    -- Validate parent
    if not parent or not parent:IsA("Instance") then
        warn("Sound Effect: Invalid parent for sound")
    -- Create sound instance
    sound.Volume = volume
    sound.Name = "AbilitySound_" .. tick()
    sound.Parent = parent
    -- Play the sound
    pcall(function()
        sound:Play()
    -- Schedule cleanup if lifetime is provided
    if lifetime > 0 then
        Debris:AddItem(sound, lifetime)
    return sound
-- // Create Looping Sound Effect
local function CreateLoopingSound(soundId, parent, volume)
    local sound = CreateAndPlaySound(soundId, parent, volume, 0) -- 0 lifetime means no auto-cleanup
    if sound then
        sound.Looped = true
-- // Stop and Clean Up Sound
local function StopAndCleanupSound(sound)
    if sound and sound.Parent then
            sound:Stop()
            sound:Destroy()
-- // Preload Dash Animation
local function PreloadDashAnimation()
    -- Create animation object
    dashAnimation = Instance.new("Animation")
    dashAnimation.AnimationId = DASH_ANIMATION_ID
    -- Load animation on humanoid
    if humanoid then
        dashAnimTrack = humanoid:LoadAnimation(dashAnimation)
        
        -- Configure animation properties
        dashAnimTrack.Priority = Enum.AnimationPriority.Action
        dashAnimTrack.Looped = false
        -- Note: FadeTime is not a property of AnimationTrack
        -- Instead, we'll pass the fade time when playing the animation
        warn("Glitch Rush: Failed to preload dash animation - humanoid not found")
-- // Get Player's Current Pointing Direction
local function GetPlayerPointingDirection(humanoid)
    -- First try to get direction from humanoid's MoveDirection
    if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
        return humanoid.MoveDirection.Unit
    -- If not moving, use the direction the character is facing
    if rootPart then
        return rootPart.CFrame.LookVector
    -- Fallback to camera direction if all else fails
    return Camera.CFrame.LookVector
-- // Perform smooth left-right movement for illusion effect
local function PerformLeftRightIllusion(rootPart, duration, frequency, distance, iterations)
    if not rootPart then return end
    -- Create and play the left-right movement sound (looping)
    local leftRightSound = CreateLoopingSound(SOUND_ID_LEFT_RIGHT, rootPart, LEFT_RIGHT_SOUND_VOLUME)
    local startTime = tick()
    local rightVector = rootPart.CFrame.RightVector -- Initial right vector for consistency
    -- Create a counter for iterations
    local iterationCount = 0
    local direction = 1  -- Start by moving right
    -- Create a connection to the heartbeat event for smooth movement
    local connection
    connection = RunService.Heartbeat:Connect(function()
        -- Check if we've exceeded the duration or iterations
        if (tick() - startTime > duration) or (iterationCount >= iterations) then
            if connection then
                connection:Disconnect()
                connection = nil
            return
        -- Only move at the frequency rate
        if (tick() - startTime) % frequency < 0.01 then
            -- Calculate movement offset - alternating left and right
            local sideOffset = rightVector * (direction * distance)
            -- Get current position and preserve Y value
            local currentPos = rootPart.Position
            local newPos = currentPos + sideOffset
            newPos = Vector3.new(newPos.X, currentPos.Y, newPos.Z)  -- Maintain Y position
            -- Move to the new position while maintaining current orientation
            local currentOrientation = rootPart.CFrame - rootPart.Position
            rootPart.CFrame = CFrame.new(newPos) * currentOrientation
            -- Flip direction for next movement
            direction = -direction
            iterationCount = iterationCount + 1
    -- Wait for the illusion effect to complete
    task.wait(duration)
    -- Ensure connection is cleaned up
    if connection then
        connection:Disconnect()
        connection = nil
    -- Stop and clean up the left-right movement sound
    StopAndCleanupSound(leftRightSound)
    -- No need to reset position - allow player to end up where they moved to
    return leftRightSound -- Return the sound reference in case we need to stop it early
-- // Perform anti-cheat safe forward dash
local function PerformAntiCheatSafeDash(rootPart, humanoid, direction, totalDistance, steps, stepDelay, speedMultiplier, isLastDash)
    if not rootPart or not direction or not humanoid then return end
    local stepDistance = totalDistance / steps
    local originalCFrame = rootPart.CFrame
    local originalWalkSpeed = humanoid.WalkSpeed
    -- Create a temporary speed boost effect
    humanoid.WalkSpeed = originalWalkSpeed * speedMultiplier
    -- Create a BodyVelocity for smoother movement
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(50000, 0, 50000)  -- Only apply force horizontally
    bodyVelocity.P = 1250  -- Adjust this for responsiveness
    bodyVelocity.Velocity = direction * (stepDistance / stepDelay) * 1.5  -- Slightly boost velocity for effect
    bodyVelocity.Parent = rootPart
    -- Play dash animation with fade time parameter
    if dashAnimTrack then
        dashAnimTrack:Play(0.1) -- 0.1 second fade time
        -- Try to load animation if not already loaded
        PreloadDashAnimation()
        if dashAnimTrack then
            dashAnimTrack:Play(0.1) -- 0.1 second fade time
            warn("Glitch Rush: Failed to play dash animation - track not available")
    -- Play dash sound effect
    CreateAndPlaySound(SOUND_ID_DASH, rootPart, DASH_SOUND_VOLUME, DASH_SOUND_LIFETIME)
    -- Perform the forward dash in small steps to avoid anti-cheat detection
    for i = 1, steps do
        -- Calculate the new position
        local newPos = rootPart.Position + (direction * stepDistance)
        newPos = Vector3.new(newPos.X, rootPart.Position.Y, newPos.Z)  -- Maintain Y position
        -- Move to the new position while maintaining orientation
        rootPart.CFrame = CFrame.new(newPos) * CFrame.Angles(
            originalCFrame:ToOrientation()
        )
        -- Small wait between steps
        task.wait(stepDelay)
    -- Clean up the BodyVelocity
    if bodyVelocity and bodyVelocity.Parent then
        bodyVelocity:Destroy()
    -- Restore original walk speed
    humanoid.WalkSpeed = originalWalkSpeed
    -- Explicitly stop the animation if this is the last dash
    if isLastDash and dashAnimTrack then
        dashAnimTrack:Stop()
    -- Otherwise animation will stop automatically since it's not looped
-- // Main Glitch Rush Function
local function GlitchRush()
    if isAbilityActive_GR then 
        return 
    if not IsReady_GR() then 
    -- Update character references
    if not (humanoid and rootPart) then 
    -- VFX CODE START
    local effectDuration = 5 -- Duration in seconds before the effect disappears
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    if not RunService:IsClient() then return end
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local effectPart = Instance.new("Part")
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Parent = workspace
    -- Initial position - directly on the player
    local effectCFrame = humanoidRootPart.CFrame
    effectPart.CFrame = effectCFrame
    local function createFolderPath(parent, path)
        if not path or path == "" then return parent end
        local current = parent
        for _, name in ipairs(string.split(path, ".")) do
            local existing = current:FindFirstChild(name)
            if not existing then
                local new = Instance.new("Folder")
                new.Name = name
                new.Parent = current
                current = new
                current = existing
        return current
        local parent = effectPart
                particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
        particle.LightInfluence = 0
        particle.Lifetime = NumberRange.new(0.300000, 0.400000)
        particle.SpreadAngle = Vector2.new(15.000000, 15.000000)
        particle.LockedToPart = false
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.598806, 0.000000), NumberSequenceKeypoint.new(0.720159, 0.618750), NumberSequenceKeypoint.new(0.872679, 0.925000), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0.000000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.500000, Color3.new(0.2, 0.2, 0.2)), ColorSequenceKeypoint.new(0.501000, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1.000000, Color3.new(1, 1, 1))})
        particle.VelocitySpread = 15
        particle.Speed = NumberRange.new(0.001000, 0.001000)
        particle.Brightness = 3
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 4.043619), NumberSequenceKeypoint.new(0.200000, 5.333644), NumberSequenceKeypoint.new(0.300000, 6.164438), NumberSequenceKeypoint.new(0.400000, 6.753995), NumberSequenceKeypoint.new(0.500000, 7.186415), NumberSequenceKeypoint.new(0.600000, 7.504354), NumberSequenceKeypoint.new(0.700000, 7.732507), NumberSequenceKeypoint.new(0.800000, 7.886009), NumberSequenceKeypoint.new(0.900000, 7.973793), NumberSequenceKeypoint.new(1.000000, 8.000000), NumberSequenceKeypoint.new(1.000000, 8.000000)})
        particle.RotSpeed = NumberRange.new(480.000000, 720.000000)
        particle.Rate = 25
        particle.Texture = "rbxassetid://12050306299"
        particle.LightEmission = -4
        particle.Lifetime = NumberRange.new(0.400000, 0.600000)
        particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 1.000000), NumberSequenceKeypoint.new(0.199602, 0.531250), NumberSequenceKeypoint.new(1.000000, 1.000000)})
        particle.Brightness = 1
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 3.538166), NumberSequenceKeypoint.new(0.200000, 4.666938), NumberSequenceKeypoint.new(0.300000, 5.393883), NumberSequenceKeypoint.new(0.400000, 5.909746), NumberSequenceKeypoint.new(0.500000, 6.288113), NumberSequenceKeypoint.new(0.600000, 6.566310), NumberSequenceKeypoint.new(0.700000, 6.765944), NumberSequenceKeypoint.new(0.800000, 6.900258), NumberSequenceKeypoint.new(0.900000, 6.977068), NumberSequenceKeypoint.new(1.000000, 7.000000), NumberSequenceKeypoint.new(1.000000, 7.000000)})
        particle.Rate = 20
        particle.Texture = "http://www.roblox.com/asset/?id=121270653244867"
        particle.Lifetime = NumberRange.new(0.500000, 0.800000)
        particle.SpreadAngle = Vector2.new(90.000000, 90.000000)
        particle.VelocitySpread = 90
        particle.Speed = NumberRange.new(20.000000, 50.000000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.400000, 0.600000), NumberSequenceKeypoint.new(1.000000, 0.000000)})
        particle.Rate = 30
        particle.Texture = "http://www.roblox.com/asset/?id=71165508990372"
        particle.Shape = Enum.ParticleEmitterShape.Disc
        particle.Lifetime = NumberRange.new(0.400000, 0.500000)
        particle.FlipbookLayout = Enum.ParticleFlipbookLayout.Grid8x8
        particle.Speed = NumberRange.new(3.000000, 8.000000)
        particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0.000000, 0.000000), NumberSequenceKeypoint.new(0.100000, 2.527262), NumberSequenceKeypoint.new(0.200000, 3.333527), NumberSequenceKeypoint.new(0.300000, 3.852774), NumberSequenceKeypoint.new(0.400000, 4.221247), NumberSequenceKeypoint.new(0.500000, 4.491509), NumberSequenceKeypoint.new(0.600000, 4.690222), NumberSequenceKeypoint.new(0.700000, 4.832817), NumberSequenceKeypoint.new(0.800000, 4.928756), NumberSequenceKeypoint.new(0.900000, 4.983620), NumberSequenceKeypoint.new(1.000000, 5.000000), NumberSequenceKeypoint.new(1.000000, 5.000000)})
        particle.Rate = 70
        particle.Texture = "rbxassetid://14201241100"
    -- Store the maximum lifetime for cleanup
    local maxLifetime = 0
        maxLifetime = math.max(maxLifetime, particle.Lifetime.Max)
    -- Client-side update loop to make the effect follow the player
    -- Function to properly clean up everything
    local function cleanupEffect()
        -- Disconnect the update connection if it exists
        if connection then
        -- Disable all particles
        for _, particle in ipairs(particles) do
            if particle and particle.Parent then
                particle.Enabled = false
        -- Destroy the effect part after a short delay to let particles fade
        task.delay(maxLifetime + 0.5, function()
            if effectPart and effectPart.Parent then
                effectPart:Destroy()
    -- Set up the connection
    connection = RunService.RenderStepped:Connect(function()
        -- Check if the timer has expired
        if tick() - startTime >= effectDuration then
            cleanupEffect()
        -- Update position to follow the player exactly
        if humanoidRootPart and humanoidRootPart.Parent then
            effectPart.CFrame = humanoidRootPart.CFrame
            -- If the humanoidRootPart is gone, clean up
    -- Safety cleanup in case the script is terminated
    game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
        cleanupEffect()
    -- VFX CODE END
    -- Play the movement animation when button is clicked
    if not movementAnimTrack then
        movementAnimTrack = humanoid:LoadAnimation(movementAnimation)
    if movementAnimTrack then
        movementAnimTrack:Play()
        -- Stop the animation after 2 seconds
        task.delay(4, function()
            if movementAnimTrack and movementAnimTrack.IsPlaying then
                movementAnimTrack:Stop()
    isAbilityActive_GR = true
    StartCooldown_GR()
    -- Play activation sound if provided
    if SOUND_ID_ACTIVATION ~= "rbxassetid://YOUR_ACTIVATION_SOUND_ID" then
        CreateAndPlaySound(SOUND_ID_ACTIVATION, rootPart, 1.0, 2.0)
    -- Start the ability execution in a separate thread
        local currentCharacter, currentRootPart, currentHumanoid = character, rootPart, humanoid
        local cleanupGuard = Instance.new("BoolValue", currentCharacter)
        cleanupGuard.Name = "GlitchRushCleanupGuard"
            if not cleanupGuard or not cleanupGuard.Parent then return end
            cleanupGuard:Destroy()
            isAbilityActive_GR = false
            -- Perform the left-right illusion effect
            PerformLeftRightIllusion(
                currentRootPart, 
                GLITCH_DURATION, 
                GLITCH_FREQUENCY, 
                GLITCH_DISTANCE, 
                GLITCH_ITERATIONS
            -- Get the current pointing direction for first dash
            local pointingDirection = GetPlayerPointingDirection(currentHumanoid)
            -- Perform first anti-cheat safe dash (not the last dash)
            PerformAntiCheatSafeDash(
                currentRootPart,
                currentHumanoid,
                pointingDirection,
                DASH1_DISTANCE,
                DASH1_STEPS,
                DASH1_STEP_DELAY,
                DASH1_SPEED_MULTIPLIER,
                false -- not the last dash
            -- Wait between first and second dashes
            task.wait(WAIT_BETWEEN_DASHES)
            -- Get the current pointing direction again for second dash
            -- This allows the player to change direction during the wait
            pointingDirection = GetPlayerPointingDirection(currentHumanoid)
            -- Perform second anti-cheat safe dash (not the last dash)
                DASH2_DISTANCE,
                DASH2_STEPS,
                DASH2_STEP_DELAY,
                DASH2_SPEED_MULTIPLIER,
            -- Wait between second and third dashes
            -- Get the current pointing direction again for third dash
            -- Perform third anti-cheat safe dash (this is the last dash)
                DASH3_DISTANCE,
                DASH3_STEPS,
                DASH3_STEP_DELAY,
                DASH3_SPEED_MULTIPLIER,
                true -- this is the last dash, stop animation after
            -- Short wait to ensure movement completes
            task.wait(0.2)
            warn("Glitch Rush Error: " .. tostring(pcallResult))
            -- Ensure walkspeed is restored even if there's an error
            if currentHumanoid and currentHumanoid.Parent then
                currentHumanoid.WalkSpeed = currentHumanoid.WalkSpeed > 0 and currentHumanoid.WalkSpeed or 16
            -- Ensure animation is stopped if there's an error
            if dashAnimTrack then
                dashAnimTrack:Stop()
-- // Clone Button Using Exact Path
local function CloneButtonUsingExactPath()
    -- Use the exact path provided by the user
    local sourceButton = player.PlayerGui.InGameUI.Bottom.Abilities["1"]
    if not sourceButton then
        warn("Source button not found at specified path. Keybind will still work.")
    -- Clone the button
    local clonedButton = sourceButton:Clone()
    clonedButton.Name = BUTTON_NAME_GR  -- "custom" as specified by user
    -- Update the Timer text to "GLITCH RUSH" as specified by user
    local timerText = clonedButton:FindFirstChild("Timer")
    if timerText and timerText:IsA("TextLabel") then
        timerText.Text = TIMER_TEXT_GR
    -- Reset cooldown if there's a cooldown frame
    local cooldownFrame = clonedButton:FindFirstChild("Cooldown")
    if cooldownFrame then
        local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
        if uiGradient then
            uiGradient.Offset = Vector2.new(0, 1) -- Reset cooldown
    -- Update colors to black and white theme
    for _, child in pairs(clonedButton:GetDescendants()) do
        if child:IsA("Frame") or child:IsA("ImageButton") or child:IsA("TextButton") then
            -- Skip cooldown frames
            if child.Name ~= "Cooldown" then
                child.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        if child:IsA("UIGradient") and child.Parent.Name ~= "Cooldown" then
            child.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
            })
        if child:IsA("UIStroke") then
            child.Color = Color3.fromRGB(255, 255, 255)
    -- Connect the button click
    local clickDetector = clonedButton:FindFirstChildOfClass("TextButton") or clonedButton
    if clickDetector and clickDetector:IsA("GuiButton") then
        clickDetector.MouseButton1Click:Connect(GlitchRush)
    -- Add to the same parent as the source button
    clonedButton.Parent = sourceButton.Parent
    return clonedButton
-- // PC Keybind Setup
    if input.KeyCode == ABILITY_KEY_GR then
        GlitchRush()
-- // Handle character changes
    -- Reload animation for new character
    PreloadDashAnimation()
-- // Initialize
local function Initialize()
    -- Preload dash animation
    glitchRushButton = CloneButtonUsingExactPath()
        warn("Failed to create Glitch Rush button, but keybind will still work")
Initialize()
-- Black Hole Strike with Integrated Ball VFX v3 (DIAGNOSTIC - Simple Sphere)
-- This script combines the original Black Hole Strike logic 
-- with the persistent ball VFX tracking (based on v11 test script).
-- Ball VFX (represented by a RED SPHERE) starts 4 seconds after button press and stops automatically after 5.5 seconds.
local character -- Will be updated
local humanoid -- Will be updated
local rootPart -- Will be updated
local playerValues -- Will be updated
    local knitPath = ReplicatedStorage:FindFirstChild("Packages",5)
    if not knitPath then warn("BHS_IntegratedVFX_v3_Diag: Packages not found in ReplicatedStorage"); return nil end
    local knitService = knitPath:FindFirstChild("Knit",5)
    if not knitService then warn("BHS_IntegratedVFX_v3_Diag: Knit not found in Packages"); return nil end
    local ballServicePath = knitService:FindFirstChild("Services",5)
    if not ballServicePath then warn("BHS_IntegratedVFX_v3_Diag: Services not found in Knit"); return nil end
    local ballService = ballServicePath:FindFirstChild("BallService",5)
    if not ballService then warn("BHS_IntegratedVFX_v3_Diag: BallService not found in Services"); return nil end
    local rePath = ballService:FindFirstChild("RE",5)
    if not rePath then warn("BHS_IntegratedVFX_v3_Diag: RE not found in BallService"); return nil end
    local remote = rePath:FindFirstChild("Shoot",5)
        warn("BHS_IntegratedVFX_v3_Diag: ShootRemote NOT found via Standard Path!");
-- // --- CONFIGURABLE VALUES (Black Hole Strike v22 Base + Integrated Ball VFX v3 Diag) --- //
local ABILITY_KEY_BHS = Enum.KeyCode.G -- User can change this
local COOLDOWN_BHS = 5 -- Cooldown in seconds (can be adjusted)
-- Shot Parameters
local ADJUSTABLE_INITIAL_FIREPOWER_BHS = 20 -- Power for the initial FireServer call
local ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS = 4 -- Delay AFTER button press BEFORE the shot is fired. Adjust to sync shot timing.
local ADJUSTABLE_SHOT_SPEED_BHS = 300    -- Speed of the ball (studs/second)
local SHOT_DURATION_BHS = 3   -- Duration BodyVelocity/BodyForce are active
-- Animation Parameters
local ANIMATION_ID_BHS = "rbxassetid://88134271748429" -- The main animation ID
local ANIMATION_DELAY_BHS = 0.1 -- Delay AFTER button press BEFORE animation starts.
local ANIMATION_SPEED_BHS = 1.5 -- Speed multiplier (e.g., 2 = twice as fast).
local ANIMATION_DURATION_BHS = 4.5  -- How long the animation should play in seconds (0 or less means play full length).
local ANIMATION_LOOPED_BHS = false -- Whether the animation should loop (ignored if ANIMATION_DURATION_BHS > 0)
-- SFX Parameters (SIMPLIFIED - Plays ONCE after delay, no loop/duration/cleanup)
local SFX_ID_BHS = "rbxassetid://5773418559" -- SFX ID
local SFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE SFX starts.
local SFX_VOLUME_BHS = 1 -- Volume for the SFX (0 to 1).
-- Character VFX Parameters (Original BHS VFX)
local VFX_ENABLED_BHS = true -- Set to false to disable this VFX
local VFX_DELAY_BHS = 4 -- Delay AFTER button press BEFORE VFX starts.
local VFX_DURATION_MULTIPLIER_BHS = 1.0 -- Adjust VFX duration (1.0 = default, 0.5 = half, 2.0 = double)
-- // --- Integrated Ball VFX Configuration (DIAGNOSTIC - RED SPHERE) --- //
local BALL_VFX_ENABLED = true -- Set to false to disable the integrated ball VFX (red sphere)
local BALL_VFX_SCRIPT_NAME = "BHS_IntegratedBallVFX_v3_Diag"
local BALL_VFX_START_DELAY = 4.0 -- Seconds after button press to START ball VFX (red sphere)
local BALL_VFX_DURATION = 5.5   -- Seconds the ball VFX (red sphere) should remain active AFTER starting
local TELEPORT_THRESHOLD_SQ = (50 * 50) -- Squared distance threshold to detect teleports (adjust if needed)
local STABILITY_FRAMES_REQUIRED = 3 -- How many consecutive frames the ball must be stable after a teleport
local MAX_WAIT_TIME_AFTER_TELEPORT = 5.0 -- Max seconds to wait for ball to stabilize before giving up
local ABILITY_NAME_BHS = "BlackHoleStrike_IntegratedVFX_v3_Diag"
local BUTTON_NAME_BHS = "BlackHoleStrikeButton_IntegratedVFX_v3_Diag"
local TIMER_TEXT_BHS = "BLACK HOLE STRIKE (DIAG)" -- Button text
local LAYOUT_ORDER_BHS = 7 -- Adjust as needed
local lastAbilityTime_BHS = 0
local blackHoleStrikeButton = nil
local isAbilityActive_BHS = false
local currentAnimationTrack_BHS = nil -- Variable to hold the active animation track
-- // --- Integrated Ball VFX State Variables --- //
local ballVFXPart = nil -- This will be the red sphere
local ballVFXHeartbeatConnection = nil
local ballVFXStopTimerConnection = nil -- To manage the auto-stop timer
local lastBallPosition = nil
local currentFollowState = "NORMAL" -- NORMAL, WAIT_BALL, WAIT_STABILITY
local stabilityCounter = 0
local waitStartTime = 0
-- // Helper Functions (Original BHS + Ball VFX Helpers)
            local b = (f:FindFirstChild("BallAnims") and f.BallAnims:FindFirstChild("BALL")) or f:FindFirstChild("BALL", true) -- Added recursive find
            elseif f:IsA("Model") and f.PrimaryPart and f.PrimaryPart:IsA("BasePart") then ball = f.PrimaryPart; break
local function playAnimation(humanoidRef, animationId, speed, looped)
    if not humanoidRef or not humanoidRef.Parent then return nil, nil end
    local animator = humanoidRef:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoidRef)
    local anim = Instance.new("Animation"); anim.AnimationId = animationId
    if speed and speed ~= 1 then track:AdjustSpeed(speed) end
    track.Looped = looped
    track:Play()
    return track, anim 
local function playSound(soundId, volume)
    sound.Volume = math.clamp(volume or 1, 0, 1) 
    sound.Looped = false
    sound.Parent = Workspace
    Debris:AddItem(sound, sound.TimeLength + 0.5) -- Add Debris cleanup
local function IsReady_BHS() return tick() - lastAbilityTime_BHS >= COOLDOWN_BHS end
local function StartCooldown_BHS()
    lastAbilityTime_BHS = tick()
    if blackHoleStrikeButton then
        local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
                local tweenInfo = TweenInfo.new(COOLDOWN_BHS, Enum.EasingStyle.Linear)
                local targetProperties = {Offset = Vector2.new(0, 1)}
                local tween = TweenService:Create(uiGradient, tweenInfo, targetProperties)
-- // --- Integrated Ball VFX Helper Functions (DIAGNOSTIC - RED SPHERE) --- //
local function createBallVFXPart()
    if ballVFXPart and ballVFXPart.Parent then ballVFXPart:Destroy() end -- Destroy previous if exists
    effectPart.Name = BALL_VFX_SCRIPT_NAME .. "_VFXPart_DiagSphere"
    effectPart.Shape = Enum.PartType.Ball
    effectPart.Size = Vector3.new(1.5, 1.5, 1.5) -- Make it visible
    effectPart.Color = Color3.fromRGB(255, 0, 0) -- Bright Red
    effectPart.Material = Enum.Material.Neon -- Make it glow slightly
    effectPart.Anchored = true -- Keep anchored, we set CFrame directly
    effectPart.CanTouch = false
    effectPart.Massless = true
    effectPart.Transparency = 0 -- Fully visible
    effectPart.Parent = Workspace
    -- NO PARTICLE EMITTERS IN DIAGNOSTIC VERSION
    ballVFXPart = effectPart -- Assign to the global state variable
    return effectPart
local function setBallEmittersEnabled(enabled) -- Renamed for clarity
    if not ballVFXPart or not ballVFXPart.Parent then return end
    -- In diagnostic mode, this just controls the visibility of the sphere
    if enabled then
        if ballVFXPart.Transparency ~= 0 then
            ballVFXPart.Transparency = 0
        if ballVFXPart.Transparency ~= 1 then
            ballVFXPart.Transparency = 1
-- // --- Integrated Ball VFX Heartbeat Update Function (Same logic as v2) --- //
local function BallVFXFollowHeartbeat(deltaTime)
    if not ballVFXPart or not ballVFXPart.Parent then
        if ballVFXHeartbeatConnection then ballVFXHeartbeatConnection:Disconnect(); ballVFXHeartbeatConnection = nil end
    local ball = findBall(1, 0) -- Only 1 retry needed here, findBall is called every frame
    if ball then
        local currentPosition = ball.Position
        local teleported = false
        if lastBallPosition then
            if (currentPosition - lastBallPosition).Magnitude > math.sqrt(TELEPORT_THRESHOLD_SQ) then -- Use sqrt here for comparison
                teleported = true
        if currentFollowState == "NORMAL" then
            if teleported then
                currentFollowState = "WAIT_BALL"
                setBallEmittersEnabled(false) -- Hide sphere
                stabilityCounter = 0
                waitStartTime = tick()
                lastBallPosition = nil -- Forget last position after teleport
                -- Normal update
                ballVFXPart.CFrame = ball.CFrame
                setBallEmittersEnabled(true) -- Show sphere
                lastBallPosition = currentPosition
        elseif currentFollowState == "WAIT_BALL" then
            if tick() - waitStartTime > MAX_WAIT_TIME_AFTER_TELEPORT then
                 currentFollowState = "NORMAL"
                 setBallEmittersEnabled(false)
                 lastBallPosition = nil
                -- Found ball, now check stability
                currentFollowState = "WAIT_STABILITY"
                lastBallPosition = currentPosition -- Start tracking stability from here
                setBallEmittersEnabled(false) -- Keep hidden until stable
        elseif currentFollowState == "WAIT_STABILITY" then
             if tick() - waitStartTime > MAX_WAIT_TIME_AFTER_TELEPORT then
             elseif teleported then
                 -- Ball jumped AGAIN while waiting for stability
                 currentFollowState = "WAIT_BALL" -- Go back to waiting for the ball
                 stabilityCounter = 0
                 waitStartTime = tick() -- Reset timeout timer
             else
                 -- Ball is found and didn't teleport this frame, increment stability counter
                 stabilityCounter = stabilityCounter + 1
                 if stabilityCounter >= STABILITY_FRAMES_REQUIRED then
                     currentFollowState = "NORMAL"
                     ballVFXPart.CFrame = ball.CFrame -- Snap to final stable position
                     setBallEmittersEnabled(true) -- Show sphere
                     lastBallPosition = currentPosition
                 else
                     -- Still waiting for more stable frames
    else -- Ball not found
            currentFollowState = "WAIT_BALL"
            setBallEmittersEnabled(false)
            stabilityCounter = 0
            waitStartTime = tick()
            lastBallPosition = nil
             currentFollowState = "WAIT_BALL"
             setBallEmittersEnabled(false)
             stabilityCounter = 0
             waitStartTime = tick()
             lastBallPosition = nil
                 -- Still waiting for ball to reappear
-- // --- Function to Start/Stop Ball VFX Tracking (Modified for Auto-Stop) --- //
local function StartBallVFXTracking()
    if not BALL_VFX_ENABLED then return end
    if ballVFXHeartbeatConnection then 
    -- Create the VFX part if it doesn't exist
        createBallVFXPart()
    if not ballVFXPart then 
        warn(BALL_VFX_SCRIPT_NAME .. ": Failed to create ball VFX part (Sphere). Cannot start tracking.")
    -- Reset state variables
    lastBallPosition = nil
    currentFollowState = "NORMAL"
    stabilityCounter = 0
    waitStartTime = 0
    setBallEmittersEnabled(false) -- Start with sphere hidden until ball is found
    -- Connect the heartbeat function
    ballVFXHeartbeatConnection = RunService.Heartbeat:Connect(BallVFXFollowHeartbeat)
    -- Schedule the automatic stop
    if ballVFXStopTimerConnection then ballVFXStopTimerConnection:Disconnect() end -- Cancel previous timer if any
    ballVFXStopTimerConnection = task.delay(BALL_VFX_DURATION, function()
        StopBallVFXTracking()
local function StopBallVFXTracking()
    -- Disconnect heartbeat and stop timer
    if ballVFXHeartbeatConnection then
        ballVFXHeartbeatConnection:Disconnect()
        ballVFXHeartbeatConnection = nil
    if ballVFXStopTimerConnection then 
        ballVFXStopTimerConnection = nil -- Clear the reference
    -- Destroy VFX part
    if ballVFXPart and ballVFXPart.Parent then
        ballVFXPart:Destroy()
        ballVFXPart = nil
-- // Main Ability Execution Logic (Modified for Timed Ball VFX Start)
local function BlackHoleStrike_Execute()
    if isAbilityActive_BHS then print(ABILITY_NAME_BHS .. ": Ability already active."); return end
    -- Pre-checks (Same as before)
    if not character then print(ABILITY_NAME_BHS .. ": Character not found."); return end
    humanoid = character:FindFirstChildOfClass("Humanoid")
    rootPart = character:FindFirstChild("HumanoidRootPart")
    playerValues = character:FindFirstChild("Values")
    if not (humanoid and rootPart and playerValues) then print(ABILITY_NAME_BHS .. ": Character components missing."); return end
    local hasBallValue = playerValues:FindFirstChild("HasBall")
    if not (hasBallValue and hasBallValue:IsA("BoolValue") and hasBallValue.Value) then print(ABILITY_NAME_BHS .. ": Player does not have ball."); return end
    if not ShootRemote then ShootRemote = findShootRemoteStandardPath(); if not ShootRemote then print(ABILITY_NAME_BHS .. ": ShootRemote missing!"); return end end
    if not IsReady_BHS() then print(ABILITY_NAME_BHS .. ": Ability on cooldown. Time left: " .. string.format("%.1f", COOLDOWN_BHS - (tick() - lastAbilityTime_BHS))); return end
    -- Cleanup potential leftovers before starting (Same as before)
    if rootPart and rootPart.Parent then cleanupAllMovers(rootPart) end
    local ballForPreCleanup = findBall(1,0); if ballForPreCleanup then cleanupAllMovers(ballForPreCleanup) end
    if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
    StopBallVFXTracking() -- Stop any previous ball VFX tracking
    -- Activate Ability
    isAbilityActive_BHS = true
    StartCooldown_BHS()
    -- Store references needed inside the spawn
    local currentCharacter_scope = character
    local currentHumanoid_scope = humanoid
    local currentRootPart_scope = rootPart
        local cleanupGuard_BHS = Instance.new("BoolValue", currentCharacter_scope)
        cleanupGuard_BHS.Name = ABILITY_NAME_BHS .. "_CleanupGuard"
        local ballInstance_thread_scope = nil
        local animationInstance_thread_scope = nil
        if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
        local function performCleanupAndReset_BHS_Thread()
            if not cleanupGuard_BHS or not cleanupGuard_BHS.Parent then return end; cleanupGuard_BHS:Destroy()
            if currentCharacter_scope and currentCharacter_scope:FindFirstChild("HumanoidRootPart") then cleanupAllMovers(currentCharacter_scope:FindFirstChild("HumanoidRootPart")) end
            local ballToClean = ballInstance_thread_scope or findBall(1,0)
            if ballToClean and ballToClean.Parent then cleanupAllMovers(ballToClean) end
            if currentAnimationTrack_BHS then currentAnimationTrack_BHS:Stop(); currentAnimationTrack_BHS = nil end
            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then animationInstance_thread_scope:Destroy() end
            -- *** Stop Ball VFX Tracking on Cleanup ***
            StopBallVFXTracking()
            isAbilityActive_BHS = false
            if not Camera then Camera = Workspace.CurrentCamera end
            if not Camera then warn(ABILITY_NAME_BHS .. ": Camera not found!"); performCleanupAndReset_BHS_Thread(); return end
            local aimVector = Camera.CFrame.LookVector
            -- // --- Schedule Ball VFX Start --- //
            if BALL_VFX_ENABLED then
                task.delay(BALL_VFX_START_DELAY, function()
                    if not cleanupGuard_BHS.Parent then return end -- Check if ability was cancelled
                    StartBallVFXTracking()
            -- // --- Animation, SFX, Character VFX Scheduling (Same as before) --- //
            -- Schedule Animation
            if ANIMATION_ID_BHS and ANIMATION_ID_BHS ~= "" and currentHumanoid_scope then
                task.delay(ANIMATION_DELAY_BHS, function()
                    if not cleanupGuard_BHS.Parent then return end
                    local track, animInstance = playAnimation(currentHumanoid_scope, ANIMATION_ID_BHS, ANIMATION_SPEED_BHS, ANIMATION_LOOPED_BHS)
                    if track then
                        currentAnimationTrack_BHS = track
                        animationInstance_thread_scope = animInstance
                        if ANIMATION_DURATION_BHS > 0 then
                            task.delay(ANIMATION_DURATION_BHS, function()
                                if not cleanupGuard_BHS.Parent then return end
                                if currentAnimationTrack_BHS and currentAnimationTrack_BHS == track and currentAnimationTrack_BHS.IsPlaying then
                                    currentAnimationTrack_BHS:Stop()
                                    if animationInstance_thread_scope and animationInstance_thread_scope.Parent then 
                                        Debris:AddItem(animationInstance_thread_scope, 0.1)
                                        animationInstance_thread_scope = nil
                                    end 
                                end
                            end)
                        elseif not ANIMATION_LOOPED_BHS then 
                            local effectiveLength = track.Length / (track.Speed > 0 and track.Speed or 1)
                            if animationInstance_thread_scope and animationInstance_thread_scope.Parent then
                                Debris:AddItem(animationInstance_thread_scope, effectiveLength + 0.1)
                            end
            -- Schedule SFX (SIMPLIFIED)
            if SFX_ID_BHS and SFX_ID_BHS ~= "" and SFX_ID_BHS ~= "rbxassetid://YOUR_SFX_ID_HERE" then
                 task.delay(SFX_DELAY_BHS, function()
                    local sound = playSound(SFX_ID_BHS, SFX_VOLUME_BHS)
                    if sound then
                    else
                        warn(ABILITY_NAME_BHS .. ": Failed to create sound instance for SFX.")
                 end)
            -- Schedule Character VFX (Original BHS VFX)
            if VFX_ENABLED_BHS then
                task.delay(VFX_DELAY_BHS, function()
                    local currentCharacter_vfx = player.Character
                    if not currentCharacter_vfx then print(ABILITY_NAME_BHS .. ": Char VFX - Character not found."); return end
                    local currentRootPart_vfx = currentCharacter_vfx:FindFirstChild("HumanoidRootPart")
                    if not currentRootPart_vfx then print(ABILITY_NAME_BHS .. ": Char VFX - RootPart not found."); return end
                    
                    local effectPart_vfx = Instance.new("Part")
                    effectPart_vfx.Name = ABILITY_NAME_BHS .. "_CharVFX_Part"
                    effectPart_vfx.Anchored = true
                    effectPart_vfx.CanCollide = false
                    effectPart_vfx.Transparency = 1
                    effectPart_vfx.Parent = Workspace
                    local forward_vfx = currentRootPart_vfx.CFrame.LookVector
                    local effectCFrame_vfx = CFrame.new(currentRootPart_vfx.Position + (forward_vfx * 5), currentRootPart_vfx.Position + (forward_vfx * 5) + forward_vfx)
                    effectPart_vfx.CFrame = effectCFrame_vfx
                    local particles_vfx = {}
                    -- ... (Original Character VFX Emitter Creation Code - Assume it's here) ...
                    do
                        local particle = Instance.new("ParticleEmitter")
                        particle.Name = "CharVFX_Emitter1"
                        -- ... Set properties ...
                        particle.Parent = effectPart_vfx
                        table.insert(particles_vfx, particle)
                    -- ... (End of Original Character VFX Emitter Creation Code) ...
                    for _, particle in ipairs(particles_vfx) do particle.Enabled = true end
                    local maxLifetime_vfx = 0; for _, p in ipairs(particles_vfx) do maxLifetime_vfx = math.max(maxLifetime_vfx, p.Lifetime.Max) end
                    local totalDuration_vfx = maxLifetime_vfx * 1.5 * VFX_DURATION_MULTIPLIER_BHS
                    task.delay(totalDuration_vfx, function()
                        if effectPart_vfx and effectPart_vfx.Parent then
                            for _, p in ipairs(particles_vfx) do if p and p.Parent then p.Enabled = false end end
                            task.wait(1)
                            if effectPart_vfx and effectPart_vfx.Parent then print(ABILITY_NAME_BHS .. ": Destroying Char VFX part."); effectPart_vfx:Destroy() end
                    end)
            -- // --- Pre-Shot Delay (Same as before) --- //
            if ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS > 0 then
                task.wait(ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS)
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled during pre-shot delay."); performCleanupAndReset_BHS_Thread(); return end 
            -- // --- Fire the Shot (Same as before) --- //
            local sOk, sErr = pcall(ShootRemote.FireServer, ShootRemote, ADJUSTABLE_INITIAL_FIREPOWER_BHS)
            if not sOk then warn(ABILITY_NAME_BHS .. ": ShootRemote:FireServer() failed: ", sErr); performCleanupAndReset_BHS_Thread(); return end
            task.wait(0.1) 
            if not cleanupGuard_BHS.Parent then print(ABILITY_NAME_BHS .. ": Ability cancelled after FireServer."); performCleanupAndReset_BHS_Thread(); return end
            -- // --- Find Ball and Apply Body Movers (Same as before) --- //
            ballInstance_thread_scope = findBall() -- Store the ball found after shooting
            if ballInstance_thread_scope then
                
                -- // --- Apply Body Movers (Same as before) --- //
                cleanupAllMovers(ballInstance_thread_scope) -- Clean previous movers
                local direction = aimVector
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = direction * ADJUSTABLE_SHOT_SPEED_BHS
                bodyVelocity.Parent = ballInstance_thread_scope
                Debris:AddItem(bodyVelocity, SHOT_DURATION_BHS)
                -- Schedule final cleanup for movers after duration
                task.delay(SHOT_DURATION_BHS + 0.1, function()
                    if ballInstance_thread_scope and ballInstance_thread_scope.Parent then
                         cleanupAllMovers(ballInstance_thread_scope)
                warn(ABILITY_NAME_BHS .. ": Ball not found after FireServer! Cannot apply movers.")
                -- Don't cleanup immediately, ball VFX might still be scheduled
                -- performCleanupAndReset_BHS_Thread() 
                -- return
            -- // --- Schedule Final Ability Cleanup (Same as before) --- //
            local maxDuration = math.max(ANIMATION_DURATION_BHS > 0 and (ANIMATION_DELAY_BHS + ANIMATION_DURATION_BHS) or 0, 
                                       SHOT_DURATION_BHS > 0 and (ADJUSTABLE_PRE_SHOT_MAIN_DELAY_BHS + SHOT_DURATION_BHS + 0.2) or 0,
                                       BALL_VFX_ENABLED and (BALL_VFX_START_DELAY + BALL_VFX_DURATION + 0.2) or 0) -- Include Ball VFX duration in cleanup calculation
            local cleanupDelay = maxDuration + 1.0 -- Add buffer
            task.delay(cleanupDelay, performCleanupAndReset_BHS_Thread)
            warn(ABILITY_NAME_BHS .. ": Error during execution: ", pcallResult)
            performCleanupAndReset_BHS_Thread() -- Ensure cleanup on error
-- // UI Creation (Modified Button Name)
local function CreateAbilityButton_BHS()
    if not playerGui then print(ABILITY_NAME_BHS .. ": PlayerGui not found."); return end
    local inGameUI = playerGui:WaitForChild("InGameUI", 10); if not inGameUI then warn(ABILITY_NAME_BHS .. ": InGameUI not found!"); return end
    local bottomFrame = inGameUI:WaitForChild("Bottom", 5); if not bottomFrame then warn(ABILITY_NAME_BHS .. ": Bottom frame not found!"); return end
    local abilitiesFrame = bottomFrame:WaitForChild("Abilities", 5); if not abilitiesFrame then warn(ABILITY_NAME_BHS .. ": Abilities frame not found!"); return end
    local templateButton = abilitiesFrame:FindFirstChild("1") or abilitiesFrame:FindFirstChildWhichIsA("ImageButton")
    if not templateButton then warn(ABILITY_NAME_BHS .. ": Template button (","1"," or ImageButton) not found! Cannot create button."); return end
    if abilitiesFrame:FindFirstChild(BUTTON_NAME_BHS) then abilitiesFrame[BUTTON_NAME_BHS]:Destroy() end
    blackHoleStrikeButton = templateButton:Clone()
    blackHoleStrikeButton.Name = BUTTON_NAME_BHS
    blackHoleStrikeButton.LayoutOrder = LAYOUT_ORDER_BHS
    blackHoleStrikeButton.Parent = abilitiesFrame
    local abilityTextLabel = blackHoleStrikeButton:FindFirstChild("Title") or blackHoleStrikeButton:FindFirstChild("Timer", true)
    if abilityTextLabel and abilityTextLabel:IsA("TextLabel") then abilityTextLabel.Text = TIMER_TEXT_BHS
    else warn(ABILITY_NAME_BHS .. ": Ability TextLabel (","Title"," or ","Timer",") not found.") end
    local keybindTextLabel = blackHoleStrikeButton:FindFirstChild("Key") or blackHoleStrikeButton:FindFirstChild("Keybind", true)
    if keybindTextLabel and keybindTextLabel:IsA("TextLabel") then keybindTextLabel.Text = ABILITY_KEY_BHS.Name
    else warn(ABILITY_NAME_BHS .. ": Keybind TextLabel (","Key"," or ","Keybind",") not found.") end
    local cooldownFrame = blackHoleStrikeButton:FindFirstChild("Cooldown")
    if not cooldownFrame then
        warn(ABILITY_NAME_BHS .. ": Cooldown frame missing in template, creating basic one.")
        cooldownFrame = Instance.new("Frame", blackHoleStrikeButton)
        cooldownFrame.Name = "Cooldown"
        cooldownFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        cooldownFrame.BackgroundTransparency = 0.5
        cooldownFrame.BorderSizePixel = 0
        cooldownFrame.Size = UDim2.new(1, 0, 1, 0)
        cooldownFrame.ZIndex = (blackHoleStrikeButton.ZIndex or 1) + 1
        local gradient = Instance.new("UIGradient", cooldownFrame)
        gradient.Rotation = 90
        gradient.Offset = Vector2.new(0,1) -- Start fully covered
    local uiGradient = cooldownFrame:FindFirstChildOfClass("UIGradient")
    if uiGradient then uiGradient.Offset = Vector2.new(0,1) end -- Ensure it starts covered
    local actualTimerLabel = blackHoleStrikeButton:FindFirstChild("ActualTimer", true)
    if actualTimerLabel then actualTimerLabel:Destroy() end
    blackHoleStrikeButton.MouseButton1Click:Connect(BlackHoleStrike_Execute)
local inputConnection_BHS = nil
local function HandleInput_BHS(input, gameProcessedEvent)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == ABILITY_KEY_BHS and input.UserInputState == Enum.UserInputState.Begin then
            BlackHoleStrike_Execute()
-- // Initialization
    CreateAbilityButton_BHS()
    if inputConnection_BHS then inputConnection_BHS:Disconnect() end
    inputConnection_BHS = UserInputService.InputBegan:Connect(HandleInput_BHS)
-- // Cleanup on Character Removal / Script Destroy
local function Cleanup_Global()
    isAbilityActive_BHS = false -- Prevent re-triggering during cleanup
    StopBallVFXTracking() -- Ensure ball VFX stops
    if blackHoleStrikeButton and blackHoleStrikeButton.Parent then blackHoleStrikeButton:Destroy(); blackHoleStrikeButton = nil end
    if inputConnection_BHS then inputConnection_BHS:Disconnect(); inputConnection_BHS = nil end
    -- Destroy any lingering cleanup guards
    if character and character.Parent then
        local guard = character:FindFirstChild(ABILITY_NAME_BHS .. "_CleanupGuard")
        if guard then guard:Destroy() end
player.CharacterAdded:Connect(function(newChar)
    Cleanup_Global() -- Clean up old stuff first
    task.wait(1) -- Give things a moment to settle
    Initialize()
player.CharacterRemoving:Connect(function(oldChar)
    Cleanup_Global()
-- Initial setup
-- Handle potential script destruction (e.g., if re-executed)
-- script.Destroying:Connect(Cleanup_Global) -- Uncomment if needed
